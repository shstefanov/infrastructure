{"version":3,"sources":["webpack:///./~/infrastructure-appcontroller-ractive/ractive-backbone-view.js","webpack:///./~/infrastructure-webpack/namespaces/App.js","webpack:///./~/infrastructure-webpack/namespaces/config.js","webpack:///./~/js-beautify/js/lib/beautify-css.js","webpack:///./~/js-beautify/js/lib/beautify.js","webpack:///./app/client/infrastructure/controllers/AppController.js","webpack:///./app/client/infrastructure/views/sections/Builder/Builder.js","webpack:///./app/client/infrastructure/views/sections/Docs/Docs.js","webpack:///./app/client/infrastructure/views/sections/HelloWorld/HelloWorld.js","webpack:///./app/client/infrastructure/views/sections/UnderConstruction/UnderConstruction.js","webpack:///./~/infrastructure/lib/Class.js","webpack:///./~/infrastructure/lib/helpers.js","webpack:///./app/client/infrastructure/controllers ^\\.\\/.*$","webpack:///./app/client/infrastructure/infrastructure.index.js","webpack:///./app/client/infrastructure/views/Layout.js","webpack:///./app/client/infrastructure/views/sections \\.\\/[^\\/]+\\/[^\\/]+\\.js$","webpack:///./app/client/infrastructure/views/sections/Docs/partials nonrecursive ^\\.\\/.*$","webpack:///./app/client/infrastructure/views/sections/Footer/Footer.js","webpack:///./app/client/infrastructure/views/sections/Header/Header.js","webpack:///./app/client/infrastructure/views/sections/MainContainer/MainContainer.js","webpack:///./app/client/infrastructure/views/sections/TopMenu/TomMenu.js","webpack:///./app/client/infrastructure/web_modules/prism.js","webpack:///./app/client/infrastructure/web_modules/prism.css","webpack:///./~/ractive-adaptors-backbone/dist/ractive-adaptors-backbone.js","webpack:///./~/infrastructure-appcontroller-ractive/Router.js","webpack:///./~/infrastructure-appcontroller-ractive/index.js","webpack:///./~/infrastructure-appcontroller-ractive/ractive-view.js","webpack:///./~/infrastructure-webpack/namespaces/_app.js","webpack:///./~/infrastructure/lib/EventedClass.js","webpack:///./~/infrastructure/lib/client/Controller.js","webpack:///./~/js-beautify/js/index.js","webpack:///./~/js-beautify/js/lib/beautify-html.js","webpack:///./app/client/infrastructure/routes.json","webpack:///./~/ractive/ractive.js","webpack:///./app/client/infrastructure/views/Layout.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Builder/Builder.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/Docs.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i1_SetupApplication.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i2_TheLogger.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i3_Configuration.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i4_ProcessMode.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i5_Structures.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Docs/partials/i6_Tests.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Footer/Footer.ractive.jade","webpack:///./app/client/infrastructure/views/sections/Header/Header.ractive.jade","webpack:///./app/client/infrastructure/views/sections/HelloWorld/HelloWorld.ractive.jade","webpack:///./app/client/infrastructure/views/sections/MainContainer/MainContainer.ractive.jade","webpack:///./app/client/infrastructure/views/sections/TopMenu/TopMenu.ractive.jade","webpack:///./app/client/infrastructure/views/sections/UnderConstruction/UnderConstruction.ractive.jade"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA,kCAAiC,6BAA6B;;;;;;;;ACN9D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8BAA6B,8BAA8B,IAAI,KAAK,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;;;;;;ACrCA;AACA,qB;;;;;;ACDA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC,wBAAwB;AACzD;AACA,8BAA6B;AAC7B;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB,cAAc;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,yCAAyC;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,yCAAyC;AACtD,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,wDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,qCAAqC;AAClD;AACA,uCAAsC;AACtC,cAAa,mBAAmB;AAChC,sCAAqC;AACrC;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;AACA;AACA,cAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,cAAa,uBAAuB;AACpC;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,EAAC;;;;;;;AC1eD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA,qBAAoB;AACpB,cAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC,6BAA4B;AAC5B;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,gFAA+E;AAC/E;AACA,wFAAuF;AACvF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B,wCAAwC;AACtE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B,cAAc;AACzC;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,UAAU;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qGAAoG;AACpG;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,uCAAsC;AACtC;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb,yDAAwD;AACxD;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA,6FAA4F;AAC5F;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAqE,UAAU;AAC/E;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAiD,KAAK,2EAA2E;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,0DAAyD;AACzD,2CAA0C;AAC1C;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gDAA+C;AAC/C;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa,2GAA2G;AACxH,iCAAgC,KAAK;AACrC,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2CAA0C;AAC1C,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,+CAA8C,2BAA2B;AACzE,yBAAwB,KAAK;AAC7B,8BAA6B;AAC7B;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,0CAAyC,qBAAqB;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,4DAA2D;AAC3D;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB;AACxB;AACA;;AAEA,yBAAwB;AACxB;AACA;;AAEA,yBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wDAAuD,IAAI,6BAA6B,IAAI,iEAAiE,IAAI;;AAEjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,+DAA8D,IAAI,6BAA6B,IAAI,iEAAiE,IAAI;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,oDAAmD;AACnD,kCAAiC;AACjC,oFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB,yCAAyC,wCAAwC;AACtG,qCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,qBAAoB;AACpB,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,EAAC;;;;;;;ACxpED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA,wF;AACA,IAAG;;AAEH,EAAC;;;;;;;ACxBD;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;;AAEA;;AAEA;AACA,6BAA4B,iBAAiB;;AAE7C,6E;AACA,kEAAiE,IAAI;AACrE,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA,yEAAwE,sBAAsB,WAAW,iBAAiB;AAC1H;AACA;AACA;AACA;AACA,MAAK;AACL;;;AAGA,EAAC;;;;;;;ACtDD;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;;AAEA,0CAAyC,gDAAgD;AACzF,0CAAyC,sCAAsC,GAAG;;AAElF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8DAA6D;AAC7D,qCAAoC,qDAAqD;AACzF,UAAS;AACT,qCAAoC,sCAAsC,GAAG;AAC7E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iC;AACA;;AAEA;AACA;AACA,wCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA4C,gBAAgB,iPAAiP,qBAAqB,+BAA+B,yBAAyB,wBAAwB,wGAAwG;;AAE1f;;;;;AAKA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,2BAA0B,sCAAsC;AAChE;;AAEA;AACA;;AAEA;AACA;AACA,iCAAgC,0BAA0B;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC7GA;AACA;;AAEA,+BAA8B,sBAAsB,kDAAkD,EAAE;;AAExG;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,aAAY,2BAA2B;AACvC;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,8BAA6B,gDAAgD,EAAE;;AAE/E;AACA;AACA,kCAAiC,kBAAkB,IAAI,8BAA8B;;AAErF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,wBAAuB,sDAAsD,8EAA8E,iBAAiB,mBAAmB,iBAAiB,uCAAuC,IAAI,+CAA+C,SAAS,yBAAyB;AAC5U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH,oCAAmC,QAAQ;AAC3C,2BAA0B,sEAAsE,QAAQ,4DAA4D,+CAA+C,0CAA0C,yBAAyB,MAAM,wBAAwB,sBAAsB,yBAAyB,WAAW,sBAAsB,6BAA6B,EAAE,IAAI,qCAAqC;AAC5c;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,WAAU;AACV,SAAQ;AACR;AACA,OAAM;;AAEN;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,0DAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uDAAuD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACfA,kCAAyB,KAAK;;AAE9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD,4DAA2D;AAC3D;AACA,KAAI;;;;AAIJ;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,EAAC;AACD;AACA;AACA,EAAC;;;;;;;ACjCD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAgC,6BAA6B,EAAE;;AAE/D,EAAC;;;;;;;ACXD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uDAAuD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,uDAAuD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnBA;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACTD;AACA;AACA;AACA;;AAEA,IAAG;;;AAGH,EAAC;;;;;;;ACRD;AACA,6HAA4H,kBAAkB,sDAAsD,MAAM,mBAAmB,wIAAwI,qBAAqB,0BAA0B,kBAAkB,sEAAsE,mBAAmB,qBAAqB,UAAU,sBAAsB,8DAA8D,SAAS,4CAA4C,uBAAuB,EAAE,UAAU,YAAY,qBAAqB,mCAAmC,yBAAyB,SAAS,gCAAgC,iBAAiB,WAAW,wBAAwB,eAAe,gDAAgD,SAAS,SAAS,uCAAuC,wDAAwD,UAAU,iDAAiD,4BAA4B,SAAS,qBAAqB,yKAAyK,WAAW,4BAA4B,8IAA8I,SAAS,gCAAgC,kCAAkC,gBAAgB,wBAAwB,gBAAgB,qPAAqP,uBAAuB,uCAAuC,kDAAkD,sDAAsD,6BAA6B,wBAAwB,8KAA8K,+BAA+B,kDAAkD,GAAG,6MAA6M,2BAA2B,sBAAsB,uCAAuC,wBAAwB,6BAA6B,MAAM,yBAAyB,cAAc,+CAA+C,WAAW,iCAAiC,YAAY,WAAW,KAAK,qDAAqD,eAAe,YAAY,WAAW,KAAK,WAAW,6BAA6B,sBAAsB,cAAc,gBAAgB,MAAM,mBAAmB,2FAA2F,aAAa,qCAAqC,6DAA6D,SAAS,QAAQ,MAAM,mBAAmB,kBAAkB,2BAA2B,mBAAmB,qBAAqB,6BAA6B,SAAS,QAAQ,2BAA2B,yCAAyC,+BAA+B,+BAA+B,qDAAqD,0BAA0B,WAAW,OAAO,gGAAgG,sBAAsB,gEAAgE,uDAAuD,wCAAwC,sBAAsB,SAAS,yEAAyE,mFAAmF,6FAA6F,kEAAkE,oEAAoE,8BAA8B,8CAA8C,iLAAiL,GAAG;AAC5jJ,yBAAwB,oHAAoH,yHAAyH,KAAK,kCAAkC,8CAA8C,eAAe,kDAAkD,sBAAsB,iCAAiC,4BAA4B,4BAA4B,oBAAoB,KAAK,GAAG,oCAAoC,+DAA+D,QAAQ;AACjpB,sBAAqB,mCAAmC,sBAAsB,SAAS,aAAa,gBAAgB,kFAAkF,EAAE,OAAO,GAAG,WAAW,wKAAwK,IAAI,oJAAoJ,OAAO,iHAAiH,sDAAsD,cAAc,uCAAuC,aAAa,8DAA8D,mDAAmD,0CAA0C,uBAAuB;AAC/7B,wBAAuB,UAAU,kDAAkD,EAAE,yCAAyC,sEAAsE,qIAAqI,uBAAuB,0TAA0T,IAAI;AAC9pB,4DAA2D,6dAA6d,uDAAuD,OAAO,6DAA6D,IAAI,kBAAkB,qBAAqB,0DAA0D,mBAAmB,qCAAqC,eAAe,aAAa,GAAG,IAAI,UAAU,6BAA6B,cAAc,GAAG,uBAAuB,kCAAkC,oBAAoB,uEAAuE,QAAQ,iIAAiI;AACxqC,cAAa,OAAO,WAAW,sCAAsC,WAAW,6CAA6C,uMAAuM,GAAG,EAAE,sCAAsC,4BAA4B,2BAA2B,GAAG,IAAI,MAAM,kBAAkB,SAAS,8DAA8D,UAAU,gBAAgB,uBAAuB,UAAU,qGAAqG,EAAE,2CAA2C,kCAAkC,gBAAgB,i4CAAi4C,sBAAsB,UAAU,gBAAgB,4IAA4I,sBAAsB,YAAY,gBAAgB,6BAA6B,sBAAsB,qFAAqF,IAAI,IAAI,2BAA2B,iMAAiM;AACtuF,aAAY,gBAAgB,qEAAqE,gBAAgB,8EAA8E,kBAAkB,uJAAuJ,SAAS,EAAE,eAAe,uDAAuD,kRAAkR,aAAa,6BAA6B,mDAAmD,4BAA4B,EAAE,0CAA0C,mCAAmC,iEAAiE,2JAA2J,gFAAgF,iBAAiB,MAAM,kBAAkB,0BAA0B,oCAAoC,uGAAuG,YAAY,kFAAkF,UAAU,OAAO,uCAAuC,4DAA4D,2FAA2F,4BAA4B,4BAA4B,oEAAoE;AACtzD,aAAY,4FAA4F,WAAW,sDAAsD,mIAAmI,yIAAyI,mEAAmE,qPAAqP,EAAE;;;;;;;;ACR/uB,0C;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;;;;;;;ACzHD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,I;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,iGAAgG;AAChG;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA,6BAA4B,kCAAkC;AAC9D,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;;;;;;;;;;AC1GA;AACA,4C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAW,IAAI;;AAEf;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL,+BAA8B;;AAE9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,oBAAoB,MAAM;AAC3D,YAAW;;AAEX;AACA,mB;AACA,QAAO;;AAEP,oBAAmB,2BAA2B,EAAE;;AAEhD;AACA;AACA;AACA,0D;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,4BAA2B,kEAAkE,eAAe;AAC5G,4BAA2B,kEAAkE,eAAe;AAC5G,4BAA2B,kEAAkE,aAAa,EAAE;AAC5G,4BAA2B,kEAAkE,aAAa,EAAE;AAC5G,4BAA2B,kEAAkE,aAAa,EAAE;AAC5G,4BAA2B,kEAAkE,aAAa,EAAE;AAC5G,qCAAoC,6BAA6B,4BAA4B,eAAe;AAC5G,gCAA+B,4DAA4D;;;AAG3F,EAAC;;;;;;;ACtKD;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA,sBAAqB,eAAe,mBAAmB;AACvD;AACA;AACA;AACA;AACA,gCAA+B,YAAY,mBAAmB,6BAA6B,wDAAwD;AACnJ;AACA;AACA;;AAEA,IAAG;;AAEH;AACA,0BAAyB,mBAAmB;AAC5C,IAAG;;AAEH;AACA,4DAA2D,WAAW,kBAAkB,GAAG,EAAE;AAC7F,IAAG;;AAEH;AACA;AACA,iBAAgB,eAAe;AAC/B;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA,EAAC;;;;;;;ACvGD;;AAEA;;AAEA;;AAEA;AACA,iC;AACA;AACA;AACA,E;;;;;;;ACTA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kDAAiD;AACjD,4BAA2B;AAC3B;;AAEA;AACA;AACA,iCAAgC;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA,yBAAwB,cAAc,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;AACD;;;;;;;ACzCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACtBD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;AACD;AACA;AACA;AACA;;AAEA;;AAEA,MAAK;AACL;;;;;;;;ACrDA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D,MAAM,OAAO;AACzE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,0BAAyB;AACzB;AACA,2CAA0C;AAC1C,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,4CAA2C;AAC3C;AACA;AACA,mCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B,MAAM,OAAO,MAAM;AAChD,8BAA6B,WAAW;AACxC,8BAA6B,MAAM,6BAA6B,KAAK,OAAO;AAC5E;AACA,0CAAyC,mBAAmB;AAC5D;AACA;AACA,0BAAyB,uBAAuB;AAChD;AACA,0BAAyB,gDAAgD;AACzE,2DAA0D,MAAM;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;;AAEA,oDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAiF;AACjF,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;;AAEA,8CAA6C;AAC7C,gDAA+C;AAC/C;AACA,mFAAkF;AAClF,kBAAiB,OAAO;AACxB;AACA,mFAAkF;AAClF;AACA,yFAAwF;AACxF,mEAAkE;AAClE;;AAEA,gDAA+C;AAC/C,gDAA+C;AAC/C,wDAAuD;AACvD,0CAAyC;AACzC,8EAA6E;AAC7E;AACA;AACA,yEAAwE;AACxE;AACA,uCAAsC;AACtC,uFAAsF;AACtF,8EAA6E;AAC7E;AACA,iFAAgF;AAChF,sEAAqE;AACrE;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kFAAiF;AACjF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,8CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,qCAAqC;AACpF;AACA;AACA;AACA,wCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+EAA8E;AAC9E,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sFAAqF,uCAAuC;AAC5H;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,gDAA+C;AAC/C;AACA;;AAEA;AACA,8CAA6C;;AAE7C,0GAAyG;AACzG;AACA;AACA;AACA;AACA;;AAEA,6EAA4E,wCAAwC;AACpH;AACA;AACA;AACA;AACA;;AAEA,mEAAkE,6DAA6D,uCAAuC;AACtK;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;;AAEA,wDAAuD;AACvD;AACA,kBAAiB,uCAAuC;AACxD,wDAAuD;AACvD,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,+EAA8E;AAC9E;AACA;AACA;AACA,kBAAiB,4DAA4D;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,wDAAwD;AACzE,0FAAyF;AACzF;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,uDAAsD;AACtD,mEAAkE;AAClE;AACA,sBAAqB,OAAO;AAC5B,oDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAwC;AACxC;;AAEA,qDAAoD;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA6D;AAC7D;AACA;AACA,0BAAyB,+CAA+C;AACxE;AACA;AACA,0BAAyB,yCAAyC;AAClE;AACA;AACA,0BAAyB,0CAA0C;AACnE;AACA;AACA,0BAAyB,6BAA6B,YAAY,MAAM;AACxE,4CAA2C;AAC3C;AACA,0BAAyB,wCAAwC,MAAM;AACvE;AACA;AACA,0BAAyB,wCAAwC,MAAM;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,qBAAqB;AAClD;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA8D,gEAAgE;AAC9H;AACA,4DAA2D;AAC3D;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA,0CAAyC;AACzC;;AAEA,iGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAgD;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA,+GAA8G;;AAE9G,8CAA6C;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;;AAEzC,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA,oCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qCAAoC;AACpC,yGAAwG;;AAExG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gIAA+H;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,KAAK;AAC7D;AACA,6EAA4E,sBAAsB;AAClG;AACA;AACA,0BAAyB;AACzB,iFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,EAAC;;;;;;;AC7/BD;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACNA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,6BAA6B;;AAE3C;AACA;AACA;AACA;AACA,oBAAmB,MAAM;AACzB,2BAA0B,OAAO;AACjC;;AAEA;AACA,YAAW;AACX,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;AACjD;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;;AAEjD;AACA,mEAAkE,WAAW;AAC7E;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,GAAG,QAAQ,WAAW,EAAE;AACtD,KAAI;AACJ;AACA;AACA;;AAEA;AACA,oDAAmD,QAAQ,WAAW,EAAE;AACxE;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,yFAAwF,aAAa;AACrG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yFAAwF,aAAa;AACrG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,sGAAqG,qBAAqB,2BAA2B,qBAAqB,2BAA2B,qBAAqB,6BAA6B,qBAAqB,4BAA4B;AACxS,mQAAkQ,uHAAuH,eAAe,EAAE;;AAE1Y;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2FAA0F,2BAA2B;AACrH;;AAEA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sFAAqF,aAAa;AAClG;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;;AAEA,kBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gBAAe,qDAAqD;AACpE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAkB;AAClB,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,WAAU;AACV,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB,MAAK;AACL,gBAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAQ,GAAG;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc,wBAAwB;AACtC;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAe,kBAAkB;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB;AACjB;;AAEA,kBAAiB;AACjB,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe,kBAAkB;AACjC,YAAW,cAAc;;AAEzB,yBAAwB,0BAA0B;AAClD,aAAY;AACZ,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA,cAAa,0BAA0B;;AAEvC,aAAY,iBAAiB;AAC7B,aAAY,cAAc;AAC1B,kBAAiB,yBAAyB;AAC1C,eAAc,gBAAgB;;AAE9B,cAAa;AACb,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,iDAAgD;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI,GAAG,+CAA+C;;AAEtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAuC,4CAA4C;AACnF;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAc,iBAAiB;AAC/B;AACA;;AAEA,UAAS,eAAe;AACxB;AACA;;AAEA,UAAS,SAAS;AAClB;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,aAAa;AAChC,MAAK;;AAEL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAiC,UAAU,EAAE,QAAQ;AACrD;AACA;AACA;AACA,oDAAmD,YAAY;AAC/D;AACA;;AAEA,sCAAqC,WAAW;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,yBAAyB;AAC9C;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uCAAsC;AACtC;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2OAA0O,cAAc,oBAAoB,QAAQ,KAAK,qCAAqC,kBAAkB,KAAK;AACrV;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA8C;;AAE9C;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAe,SAAS;AACxB,qBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+CAA8C;AAC9C,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,eAAc,wBAAwB;AACtC;;AAEA;AACA;AACA,yBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAqE,EAAE,cAAc,EAAE;;AAEvF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,8BAA6B;AAC7B;AACA;AACA;;AAEA;;AAEA,kDAAiD;AACjD;;AAEA,8BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,wDAAwD;;AAEvE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb,+CAA8C;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb,+CAA8C;;AAE9C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc;AACd,gDAA+C;;AAE/C;;AAEA,+CAA8C,UAAU;AACxD,0BAAyB,aAAa,QAAQ,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAc,8BAA8B;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAmB;AACnB,qDAAoD;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,eAAc;;AAEd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAe;AACf,KAAI;AACJ,gBAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,uBAAsB,MAAM,kBAAkB,SAAS;AACvD;;AAEA;AACA,+BAA8B,WAAW,SAAS,MAAM;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,MAAK;AACL;AACA,uBAAsB,MAAM,kBAAkB,SAAS;AACvD;;AAEA;AACA,6CAA4C,MAAM;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,WAAW;AACtC,0BAAyB,MAAM;AAC/B,8CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA,oGAAmG;;AAEnG;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAiC,0BAA0B,6BAA6B;AACxF;;AAEA;AACA;;AAEA;AACA;;AAEA,eAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC,GAAG;AACzC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI,EAAE;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI,EAAE;AACN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,KAAK,KAAK;AACtC,qCAAoC,KAAK,KAAK;AAC9C;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA,aAAY;AACZ,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;;AAEA;AACA,cAAa;AACb;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;;AAEA;;AAEA,8BAA6B;AAC7B,cAAa;AACb;;AAEA;AACA;;AAEA;;AAEA,+BAA8B;AAC9B,eAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,cAAa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAe;AACf;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA,mCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA,qBAAoB,gEAAgE;AACpF,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,SAAS,aAAa;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAmD,0EAA0E;AAC7H;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,yDAAwD;AACxD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+EAA8E,uBAAuB,OAAO,UAAU,kCAAkC,eAAe,gBAAgB,eAAe;;AAEtM;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA6C,0EAA0E;AACvH;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kGAAiG;;AAEjG;AACA;AACA,qDAAoD;AACpD;;AAEA;AACA;;AAEA;AACA;AACA,6DAA4D,OAAO;AACnE;AACA;;AAEA,yDAAwD,MAAM;;AAE9D,mBAAkB,mIAAmI,GAAG,kHAAkH,GAAG,kHAAkH,GAAG,6HAA6H;;AAE/f;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI,IAAI;AACR;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oDAAmD,cAAc;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ,wBAAuB;;AAEvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA,eAAc,sBAAsB;AACpC,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,UAAU;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB,iCAAiC;AACjD,eAAc,+BAA+B;AAC7C,aAAY;AACZ;;AAEA;AACA;AACA,mBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAsD,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,sEAAsE;AAC9F;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,eAAe;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B,YAAY;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,eAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;AACA,0DAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,MAAK;AACL;;AAEA;;AAEA,oBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,wDAAwD;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC,wBAAwB,uBAAuB;AACnF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,8BAA8B,mBAAmB;;AAE3E;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,SAAS;;AAEjC;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA6B,UAAU;AACvC;AACA,2BAA0B;AAC1B;;AAEA,8BAA6B,QAAQ;AACrC;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA,kDAAiD,QAAQ;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAoC;AACpC,0IAAyI,qBAAqB;AAC9J;AACA;;AAEA;AACA,2FAA0F,qBAAqB;AAC/G;AACA;AACA,KAAI;AACJ;AACA,kBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2KAA0K,qBAAqB;AAC/L;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA0B;AAC1B,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA,qBAAoB,0BAA0B;AAC9C;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA,oBAAmB,0BAA0B;AAC7C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yHAAwH,wBAAwB;AAChJ;;AAEA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAkD,eAAe;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAkD,kCAAkC;AACpF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mDAAkD,2BAA2B;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,sDAAqD,kBAAkB;AACvE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA,iCAAgC;AAChC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,sDAAqD;;AAErD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,yDAAwD,qBAAqB;AAC7E;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2JAA0J,eAAe;AACzK,UAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd,KAAI;AACJ;AACA,gBAAe;AACf,MAAK;AACL,gBAAe;AACf,MAAK;AACL,gBAAe;AACf;AACA,KAAI;AACJ;AACA;;AAEA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8FAA6F,qBAAqB;AAClH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,UAAU;AACxB,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,oCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4EAA2E;AAC3E;AACA;;AAEA;AACA,4CAA2C,gBAAgB;;AAE3D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAuE,mBAAmB;AAC1F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,KAAK,iDAAiD,mBAAmB;AACvG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAe,MAAM;AACrB;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA,qDAAoD,oDAAoD;AACxG,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAwD,qBAAqB;AAC7E;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8EAA6E,mBAAmB;;AAEhG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAmE,aAAa;AAChF;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA2B,WAAW,WAAW;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;AACA,iDAAgD,4BAA4B;AAC5E;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,IAAG;AACH,yBAAwB;AACxB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA4C,2DAA2D;AACvG;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6DAA4D;;AAE5D;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,SAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB;;AAEvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA,qBAAoB,iDAAiD;;AAErE;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,OAAM;;AAEN;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO,aAAa,MAAM;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,YAAW;AACX;;AAEA;AACA;AACA,KAAI;AACJ,+DAA8D;AAC9D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAiD,eAAe;AAChE;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,yBAAwB,iBAAiB;AACzC,0BAAyB;AACzB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,8BAA6B,eAAe;;AAE5C;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA,qCAAoC,kBAAkB;AACtD;AACA;;AAEA;AACA;AACA,2BAA0B,eAAe;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wDAAuD,KAAK,KAAK;AACjE;AACA,uBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI,OAAO;;AAEX;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,qDAAoD;AACpD,iDAAgD;;AAEhD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAoC,4BAA4B;;AAEhE;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD,UAAU;AACnE;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sPAAqP;AACrP,0DAAyD,mBAAmB;AAC5E;;AAEA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B,iBAAgB;AAChB,qBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAqC,UAAU;AAC/C;;AAEA;AACA;;AAEA;AACA,kEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA2C;AAC3C,WAAU;AACV;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA;AACA,mCAAkC;AAClC,UAAS;AACT;AACA;AACA,SAAQ;AACR;;AAEA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uDAAsD,2BAA2B;;AAEjF;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wGAAuG,yBAAyB;AAChI;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,0EAAyE,wBAAwB;AACjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA,gEAA+D,uCAAuC;AACtG;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,+BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAuC,qBAAqB;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ,wDAAuD,KAAK;AAC5D;AACA;AACA;;AAEA,4CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA,sEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA,iDAAgD;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,eAAe;;AAE9B;AACA,cAAa,6DAA6D;;AAE1E;AACA,eAAc;AACd,KAAI;;AAEJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,8BAA8B;AACzC,qBAAoB,8BAA8B;;AAElD;AACA,aAAY,iBAAiB;AAC7B,kBAAiB,qBAAqB;AACtC,YAAW,gBAAgB;;AAE3B;AACA,cAAa,uBAAuB;;AAEpC;AACA,UAAS,aAAa;AACtB,YAAW,4BAA4B;;AAEvC;AACA,cAAa,iBAAiB;;AAE9B;AACA,eAAc,0BAA0B,EAAE;AAC1C,iBAAgB,0BAA0B,EAAE;AAC5C,iBAAgB,0BAA0B,EAAE;AAC5C,aAAY,uCAAuC;AACnD,aAAY,0BAA0B,EAAE;AACxC,oBAAmB,8CAA8C;AACjE,eAAc,0BAA0B,EAAE;AAC1C,kBAAiB,0BAA0B;AAC3C;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAC;AACD;;;;;;;;AC1ugBA,sFAAqF,uCAAuC,iBAAiB,IAAI,oHAAoH,uCAAuC,kDAAkD,IAAI,yGAAyG,uCAAuC,iBAAiB,IAAI,a;;;;;;ACAvgB,kGAAiG,cAAc,uF;;;;;;ACA/G,iHAAgH,QAAQ,4BAA4B,cAAc,GAAG,GAAG,oCAAoC,sCAAsC,KAAK,4CAA4C,MAAM,QAAQ,8EAA8E,aAAa,0FAA0F,WAAW,yEAAyE,cAAc,GAAG,UAAU,+BAA+B,gDAAgD,YAAY,WAAW,KAAK,OAAO,0EAA0E,cAAc,GAAG,MAAM,+BAA+B,4CAA4C,YAAY,OAAO,mB;;;;;;ACAt4B,qKAAoK,uDAAuD,iCAAiC,oFAAoF,sCAAsC,iCAAiC,gHAAgH,mEAAmE,yHAAyH,uCAAuC,6CAA6C,uBAAuB,yCAAyC,KAAK,uSAAuS,0DAA0D,iCAAiC,iFAAiF,kCAAkC,iCAAiC,4GAA4G,sEAAsE,6FAA6F,kBAAkB,gCAAgC,qBAAqB,YAAY,gBAAgB,KAAK,GAAG,EAAE,oDAAoD,mCAAmC,4E;;;;;;ACAr0D,uOAAsO,yDAAyD,iCAAiC,+EAA+E,mCAAmC,iCAAiC,4GAA4G,qEAAqE,6FAA6F,kBAAkB,iBAAiB,YAAY,4CAA4C,YAAY,OAAO,KAAK,GAAG,sBAAsB,cAAc,gBAAgB,KAAK,GAAG,EAAE,qDAAqD,oCAAoC,4UAA4U,cAAc,kiBAAkiB,yDAAyD,iCAAiC,+EAA+E,mCAAmC,iCAAiC,2GAA2G,qEAAqE,6FAA6F,kBAAkB,iBAAiB,YAAY,2CAA2C,yBAAyB,OAAO,KAAK,GAAG,sBAAsB,cAAc,gBAAgB,KAAK,mDAAmD,GAAG,EAAE,oDAAoD,oCAAoC,oW;;;;;;ACA/qF,iYAAgY,0EAA0E,iCAAiC,yFAAyF,kDAAkD,iCAAiC,mGAAmG,gDAAgD,iCAAiC,+FAA+F,iDAAiD,iCAAiC,iGAAiG,oDAAoD,iCAAiC,uGAAuG,mDAAmD,iCAAiC,4HAA4H,sFAAsF,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,mDAAmD,mDAAmD,6CAA6C,qBAAqB,gBAAgB,mDAAmD,iCAAiC,OAAO,KAAK,GAAG,mDAAmD,iDAAiD,8DAA8D,iBAAiB,YAAY,2CAA2C,yBAAyB,OAAO,KAAK,IAAI,mDAAmD,kDAAkD,uMAAuM,oDAAoD,sNAAsN,qDAAqD,kEAAkE,wEAAwE,wCAAwC,qEAAqE,iDAAiD,+FAA+F,iDAAiD,yEAAyE,4FAA4F,qFAAqF,2EAA2E,sCAAsC,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,+DAA+D,yFAAyF,6CAA6C,+CAA+C,iCAAiC,GAAG,uNAAuN,oFAAoF,iCAAiC,oIAAoI,gGAAgG,kEAAkE,wEAAwE,iEAAiE,qEAAqE,iDAAiD,qEAAqE,yFAAyF,yDAAyD,+EAA+E,iDAAiD,yEAAyE,4FAA4F,4DAA4D,2EAA2E,uDAAuD,6CAA6C,qBAAqB,gBAAgB,sBAAsB,iBAAiB,OAAO,KAAK,GAAG,+DAA+D,qEAAqE,6FAA6F,sGAAsG,wBAAwB,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,+DAA+D,0DAA0D,6CAA6C,4CAA4C,iCAAiC,GAAG,0B;;;;;;ACA/8M,8QAA6Q,0EAA0E,iCAAiC,4FAA4F,uDAAuD,iCAAiC,6GAA6G,0CAA0C,iCAAiC,mHAAmH,sFAAsF,6FAA6F,kBAAkB,4BAA4B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,qDAAqD,wDAAwD,kEAAkE,iFAAiF,iDAAiD,qEAAqE,iDAAiD,qEAAqE,mGAAmG,qGAAqG,gFAAgF,iDAAiD,yEAAyE,qGAAqG,qEAAqE,2EAA2E,+CAA+C,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,+DAA+D,yGAAyG,sHAAsH,mEAAmE,6CAA6C,4CAA4C,iCAAiC,GAAG,2DAA2D,2CAA2C,ugB;;;;;;ACAnhG,iVAAgV,2EAA2E,iCAAiC,2HAA2H,uFAAuF,kEAAkE,8EAA8E,8CAA8C,qEAAqE,iDAAiD,qEAAqE,gGAAgG,gEAAgE,gFAAgF,iDAAiD,yEAAyE,kGAAkG,kEAAkE,6CAA6C,sGAAsG,qGAAqG,+EAA+E,4CAA4C,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,+DAA+D,8DAA8D,sHAAsH,gEAAgE,6CAA6C,2CAA2C,iCAAiC,GAAG,6DAA6D,yGAAyG,6CAA6C,4BAA4B,8OAA8O,2EAA2E,iCAAiC,oGAAoG,uCAAuC,iCAAiC,uGAAuG,uFAAuF,kEAAkE,8EAA8E,8CAA8C,qEAAqE,iDAAiD,qEAAqE,gGAAgG,gEAAgE,gFAAgF,iDAAiD,yEAAyE,kGAAkG,kEAAkE,6CAA6C,sGAAsG,sEAAsE,uFAAuF,iDAAiD,sEAAsE,2FAA2F,0FAA0F,gDAAgD,2FAA2F,2DAA2D,wEAAwE,4CAA4C,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,uIAAuI,4BAA4B,KAAK,EAAE,+FAA+F,4BAA4B,KAAK,EAAE,KAAK,EAAE,+DAA+D,8FAA8F,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,yDAAyD,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,8DAA8D,sHAAsH,gEAAgE,6CAA6C,4CAA4C,iCAAiC,GAAG,6DAA6D,oEAAoE,6CAA6C,4BAA4B,2DAA2D,wCAAwC,qzB;;;;;;ACAnrO,uJAAsJ,iEAAiE,iCAAiC,+FAA+F,2CAA2C,iCAAiC,6FAA6F,wCAAwC,iCAAiC,uFAAuF,uCAAuC,iCAAiC,4GAA4G,6EAA6E,0HAA0H,wCAAwC,mqCAAmqC,4CAA4C,6CAA6C,uHAAuH,mCAAmC,wBAAwB,yCAAyC,2BAA2B,gCAAgC,GAAG,uDAAuD,yCAAyC,kEAAkE,yEAAyE,yCAAyC,qEAAqE,iDAAiD,qEAAqE,2FAA2F,2DAA2D,gFAAgF,iDAAiD,yEAAyE,6FAA6F,6DAA6D,6CAA6C,iGAAiG,iEAAiE,uFAAuF,iDAAiD,mEAAmE,+EAA+E,yEAAyE,4EAA4E,iDAAiD,sEAAsE,sFAAsF,sDAAsD,gDAAgD,sFAAsF,sDAAsD,wEAAwE,6EAA6E,6EAA6E,kDAAkD,2EAA2E,YAAY,gDAAgD,qCAAqC,2BAA2B,0BAA0B,gCAAgC,uBAAuB,eAAe,OAAO,EAAE,KAAK,EAAE,sFAAsF,iGAAiG,gCAAgC,yEAAyE,eAAe,OAAO,EAAE,KAAK,EAAE,+CAA+C,6BAA6B,gCAAgC,eAAe,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,mEAAmE,uCAAuC,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,uIAAuI,4BAA4B,KAAK,EAAE,+FAA+F,4BAA4B,KAAK,EAAE,KAAK,EAAE,+DAA+D,oDAAoD,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,oDAAoD,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,yDAAyD,sHAAsH,2DAA2D,6CAA6C,4CAA4C,iCAAiC,GAAG,6DAA6D,+DAA+D,6CAA6C,4BAA4B,mOAAmO,+DAA+D,iCAAiC,2FAA2F,uCAAuC,iCAAiC,4GAA4G,2EAA2E,kEAAkE,yEAAyE,yCAAyC,qEAAqE,iDAAiD,qEAAqE,2FAA2F,2DAA2D,gFAAgF,iDAAiD,yEAAyE,6FAA6F,6DAA6D,6CAA6C,iGAAiG,iEAAiE,uDAAuD,mFAAmF,6EAA6E,8EAA8E,iDAAiD,mEAAmE,+EAA+E,+CAA+C,4EAA4E,iDAAiD,sEAAsE,sFAAsF,sDAAsD,gDAAgD,sFAAsF,sDAAsD,wEAAwE,iFAAiF,6CAA6C,qBAAqB,gBAAgB,sBAAsB,iCAAiC,OAAO,KAAK,GAAG,+DAA+D,6CAA6C,6EAA6E,kDAAkD,2EAA2E,YAAY,gDAAgD,qCAAqC,2BAA2B,0BAA0B,gCAAgC,uBAAuB,eAAe,OAAO,EAAE,KAAK,EAAE,sFAAsF,iGAAiG,gCAAgC,yEAAyE,eAAe,OAAO,EAAE,KAAK,EAAE,+CAA+C,6BAA6B,gCAAgC,eAAe,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,mEAAmE,uCAAuC,6FAA6F,kBAAkB,0BAA0B,sBAAsB,cAAc,WAAW,EAAE,GAAG,EAAE,+DAA+D,oDAAoD,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,oDAAoD,mEAAmE,iEAAiE,GAAG,0DAA0D,uCAAuC,GAAG,4BAA4B,+DAA+D,yDAAyD,sHAAsH,2DAA2D,6CAA6C,4CAA4C,iCAAiC,GAAG,6DAA6D,+DAA+D,6CAA6C,4BAA4B,2DAA2D,wCAAwC,uZ;;;;;;ACAtza,mC;;;;;;ACAA,2E;;;;;;ACAA,iI;;;;;;ACAA,wCAAuC,mBAAmB,MAAM,oCAAoC,GAAG,IAAI,MAAM,MAAM,0EAA0E,kDAAkD,GAAG,IAAI,KAAK,O;;;;;;ACA/P,2IAA0I,cAAc,2HAA2H,+CAA+C,mGAAmG,+CAA+C,8B;;;;;;ACApd,+C","file":"/home/stefan/projects/infrastructure/infrastructure-gh-pages/public/infrastructure.bundle.js","sourcesContent":["var Ractive    = require(\"./ractive-view.js\" );\n// Ractive.DEBUG  = config.ractive.debug;\n\nvar backboneAdaptor      = require( 'ractive-adaptors-backbone' );\nbackboneAdaptor.Backbone = require( 'backbone' );\n\nmodule.exports = Ractive.extend({ adapt: [ backboneAdaptor ] });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-appcontroller-ractive/ractive-backbone-view.js\n ** module id = 2\n ** module chunks = 1\n **/","// Main App namespace\nvar helpers = require(\"helpers\");\nvar _ = require(\"underscore\");\n\nvar App = module.exports = {\n  \n  bulk: function(context, iterator){\n    var result = {};\n    return _.chain( context.keys() )\n      .filter(function(path){ return !!path.match(/\\.[a-z]{2,6}$/i); }) // Omits module path without extensions\n      .map(function(path){\n        var prop_path = path.replace(/^\\.\\//, \"\").replace(/\\.js$/i, \"\");\n        var  prop_name, module;\n        if(iterator){\n          var cb_called = false;\n          iterator(prop_path, context, function(name, mod){\n            cb_called = true;\n            prop_name = name, module = arguments.length < 2 ? (name === null ? module : context(path)) : mod;\n          });\n          if(prop_name === null) return null;\n          if(!cb_called) module = context(path);\n          if(prop_name === undefined) prop_name = prop_path;\n        }\n        else{\n          prop_name = prop_path, module = context(path);\n        }\n        return [prop_name, module];\n     }).filter(_.isArray).object().value();\n  },\n\n  config: function(conf){\n    var config = require(\"config\");\n    _.extend(config, typeof conf === \"function\" ? App.bulk(conf, function(name, context, cb){\n      cb(name.replace(/\\.(js|json|yml|hson)$/i, \"\"));\n    }) : conf );\n  }\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-webpack/namespaces/App.js\n ** module id = 4\n ** module chunks = 1\n **/","// Config namespace object\nmodule.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-webpack/namespaces/config.js\n ** module id = 5\n ** module chunks = 1\n **/","/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n CSS Beautifier\n---------------\n\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\n\n    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n        http://jsbeautifier.org/\n\n    Usage:\n        css_beautify(source_text);\n        css_beautify(source_text, options);\n\n    The options are (default in brackets):\n        indent_size (4)                   — indentation size,\n        indent_char (space)               — character to indent with,\n        selector_separator_newline (true) - separate selectors with newline or\n                                            not (e.g. \"a,\\nbr\" or \"a, br\")\n        end_with_newline (false)          - end with a newline\n        newline_between_rules (true)      - add a new line after every css rule\n\n    e.g\n\n    css_beautify(css_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t',\n      'selector_separator': ' ',\n      'end_with_newline': false,\n      'newline_between_rules': true\n    });\n*/\n\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\n// http://www.w3.org/TR/css3-syntax/\n\n(function() {\n    function css_beautify(source_text, options) {\n        options = options || {};\n        source_text = source_text || '';\n        // HACK: newline parsing inconsistent. This brute force normalizes the input.\n        source_text = source_text.replace(/\\r\\n|[\\r\\u2028\\u2029]/g, '\\n')\n\n        var indentSize = options.indent_size || 4;\n        var indentCharacter = options.indent_char || ' ';\n        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;\n        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n        var newline_between_rules = (options.newline_between_rules === undefined) ? true : options.newline_between_rules;\n        var eol = options.eol ? options.eol : '\\n';\n\n        // compatibility\n        if (typeof indentSize === \"string\") {\n            indentSize = parseInt(indentSize, 10);\n        }\n\n        if(options.indent_with_tabs){\n            indentCharacter = '\\t';\n            indentSize = 1;\n        }\n\n        eol = eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n')\n\n\n        // tokenizer\n        var whiteRe = /^\\s+$/;\n        var wordRe = /[\\w$\\-_]/;\n\n        var pos = -1,\n            ch;\n        var parenLevel = 0;\n\n        function next() {\n            ch = source_text.charAt(++pos);\n            return ch || '';\n        }\n\n        function peek(skipWhitespace) {\n            var result = '';\n            var prev_pos = pos;\n            if (skipWhitespace) {\n                eatWhitespace();\n            }\n            result = source_text.charAt(pos + 1) || '';\n            pos = prev_pos - 1;\n            next();\n            return result;\n        }\n\n        function eatString(endChars) {\n            var start = pos;\n            while (next()) {\n                if (ch === \"\\\\\") {\n                    next();\n                } else if (endChars.indexOf(ch) !== -1) {\n                    break;\n                } else if (ch === \"\\n\") {\n                    break;\n                }\n            }\n            return source_text.substring(start, pos + 1);\n        }\n\n        function peekString(endChar) {\n            var prev_pos = pos;\n            var str = eatString(endChar);\n            pos = prev_pos - 1;\n            next();\n            return str;\n        }\n\n        function eatWhitespace() {\n            var result = '';\n            while (whiteRe.test(peek())) {\n                next();\n                result += ch;\n            }\n            return result;\n        }\n\n        function skipWhitespace() {\n            var result = '';\n            if (ch && whiteRe.test(ch)) {\n                result = ch;\n            }\n            while (whiteRe.test(next())) {\n                result += ch;\n            }\n            return result;\n        }\n\n        function eatComment(singleLine) {\n            var start = pos;\n            singleLine = peek() === \"/\";\n            next();\n            while (next()) {\n                if (!singleLine && ch === \"*\" && peek() === \"/\") {\n                    next();\n                    break;\n                } else if (singleLine && ch === \"\\n\") {\n                    return source_text.substring(start, pos);\n                }\n            }\n\n            return source_text.substring(start, pos) + ch;\n        }\n\n\n        function lookBack(str) {\n            return source_text.substring(pos - str.length, pos).toLowerCase() ===\n                str;\n        }\n\n        // Nested pseudo-class if we are insideRule\n        // and the next special character found opens\n        // a new block\n        function foundNestedPseudoClass() {\n            var openParen = 0;\n            for (var i = pos + 1; i < source_text.length; i++) {\n                var ch = source_text.charAt(i);\n                if (ch === \"{\") {\n                    return true;\n                } else if (ch === '(') {\n                    // pseudoclasses can contain ()\n                    openParen += 1;\n                } else if (ch === ')') {\n                    if (openParen == 0) {\n                        return false;\n                    }\n                    openParen -= 1;\n                } else if (ch === \";\" || ch === \"}\") {\n                    return false;\n                }\n            }\n            return false;\n        }\n\n        // printer\n        var basebaseIndentString = source_text.match(/^[\\t ]*/)[0];\n        var singleIndent = new Array(indentSize + 1).join(indentCharacter);\n        var indentLevel = 0;\n        var nestedLevel = 0;\n\n        function indent() {\n            indentLevel++;\n            basebaseIndentString += singleIndent;\n        }\n\n        function outdent() {\n            indentLevel--;\n            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);\n        }\n\n        var print = {};\n        print[\"{\"] = function(ch) {\n            print.singleSpace();\n            output.push(ch);\n            print.newLine();\n        };\n        print[\"}\"] = function(ch) {\n            print.newLine();\n            output.push(ch);\n            print.newLine();\n        };\n\n        print._lastCharWhitespace = function() {\n            return whiteRe.test(output[output.length - 1]);\n        };\n\n        print.newLine = function(keepWhitespace) {\n            if (output.length) {\n                if (!keepWhitespace && output[output.length - 1] !== '\\n') {\n                    print.trim();\n                }\n\n                output.push('\\n');\n\n                if (basebaseIndentString) {\n                    output.push(basebaseIndentString);\n                }\n            }\n        };\n        print.singleSpace = function() {\n            if (output.length && !print._lastCharWhitespace()) {\n                output.push(' ');\n            }\n        };\n\n        print.preserveSingleSpace = function() {\n            if (isAfterSpace) {\n                print.singleSpace();\n            }\n        };\n\n        print.trim = function() {\n            while (print._lastCharWhitespace()) {\n                output.pop();\n            }\n        };\n\n\n        var output = [];\n        /*_____________________--------------------_____________________*/\n\n        var insideRule = false;\n        var insidePropertyValue = false;\n        var enteringConditionalGroup = false;\n        var top_ch = '';\n        var last_top_ch = '';\n\n        while (true) {\n            var whitespace = skipWhitespace();\n            var isAfterSpace = whitespace !== '';\n            var isAfterNewline = whitespace.indexOf('\\n') !== -1;\n            last_top_ch = top_ch;\n            top_ch = ch;\n\n            if (!ch) {\n                break;\n            } else if (ch === '/' && peek() === '*') { /* css comment */\n                var header = indentLevel === 0;\n\n                if (isAfterNewline || header) {\n                    print.newLine();\n                }\n\n                output.push(eatComment());\n                print.newLine();\n                if (header) {\n                    print.newLine(true);\n                }\n            } else if (ch === '/' && peek() === '/') { // single line comment\n                if (!isAfterNewline && last_top_ch !== '{' ) {\n                    print.trim();\n                }\n                print.singleSpace();\n                output.push(eatComment());\n                print.newLine();\n            } else if (ch === '@') {\n                print.preserveSingleSpace();\n                output.push(ch);\n\n                // strip trailing space, if present, for hash property checks\n                var variableOrRule = peekString(\": ,;{}()[]/='\\\"\");\n\n                if (variableOrRule.match(/[ :]$/)) {\n                    // we have a variable or pseudo-class, add it and insert one space before continuing\n                    next();\n                    variableOrRule = eatString(\": \").replace(/\\s$/, '');\n                    output.push(variableOrRule);\n                    print.singleSpace();\n                }\n\n                variableOrRule = variableOrRule.replace(/\\s$/, '')\n\n                // might be a nesting at-rule\n                if (variableOrRule in css_beautify.NESTED_AT_RULE) {\n                    nestedLevel += 1;\n                    if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {\n                        enteringConditionalGroup = true;\n                    }\n                }\n            } else if (ch === '#' && peek() === '{') {\n              print.preserveSingleSpace();\n              output.push(eatString('}'));\n            } else if (ch === '{') {\n                if (peek(true) === '}') {\n                    eatWhitespace();\n                    next();\n                    print.singleSpace();\n                    output.push(\"{}\");\n                    print.newLine();\n                    if (newline_between_rules && indentLevel === 0) {\n                        print.newLine(true);\n                    }\n                } else {\n                    indent();\n                    print[\"{\"](ch);\n                    // when entering conditional groups, only rulesets are allowed\n                    if (enteringConditionalGroup) {\n                        enteringConditionalGroup = false;\n                        insideRule = (indentLevel > nestedLevel);\n                    } else {\n                        // otherwise, declarations are also allowed\n                        insideRule = (indentLevel >= nestedLevel);\n                    }\n                }\n            } else if (ch === '}') {\n                outdent();\n                print[\"}\"](ch);\n                insideRule = false;\n                insidePropertyValue = false;\n                if (nestedLevel) {\n                    nestedLevel--;\n                }\n                if (newline_between_rules && indentLevel === 0) {\n                    print.newLine(true);\n                }\n            } else if (ch === \":\") {\n                eatWhitespace();\n                if ((insideRule || enteringConditionalGroup) &&\n                    !(lookBack(\"&\") || foundNestedPseudoClass())) {\n                    // 'property: value' delimiter\n                    // which could be in a conditional group query\n                    insidePropertyValue = true;\n                    output.push(':');\n                    print.singleSpace();\n                } else {\n                    // sass/less parent reference don't use a space\n                    // sass nested pseudo-class don't use a space\n                    if (peek() === \":\") {\n                        // pseudo-element\n                        next();\n                        output.push(\"::\");\n                    } else {\n                        // pseudo-class\n                        output.push(':');\n                    }\n                }\n            } else if (ch === '\"' || ch === '\\'') {\n                print.preserveSingleSpace();\n                output.push(eatString(ch));\n            } else if (ch === ';') {\n                insidePropertyValue = false;\n                output.push(ch);\n                print.newLine();\n            } else if (ch === '(') { // may be a url\n                if (lookBack(\"url\")) {\n                    output.push(ch);\n                    eatWhitespace();\n                    if (next()) {\n                        if (ch !== ')' && ch !== '\"' && ch !== '\\'') {\n                            output.push(eatString(')'));\n                        } else {\n                            pos--;\n                        }\n                    }\n                } else {\n                    parenLevel++;\n                    print.preserveSingleSpace();\n                    output.push(ch);\n                    eatWhitespace();\n                }\n            } else if (ch === ')') {\n                output.push(ch);\n                parenLevel--;\n            } else if (ch === ',') {\n                output.push(ch);\n                eatWhitespace();\n                if (selectorSeparatorNewline && !insidePropertyValue && parenLevel < 1) {\n                    print.newLine();\n                } else {\n                    print.singleSpace();\n                }\n            } else if (ch === ']') {\n                output.push(ch);\n            } else if (ch === '[') {\n                print.preserveSingleSpace();\n                output.push(ch);\n            } else if (ch === '=') { // no whitespace before or after\n                eatWhitespace()\n                ch = '=';\n                output.push(ch);\n            } else {\n                print.preserveSingleSpace();\n                output.push(ch);\n            }\n        }\n\n\n        var sweetCode = '';\n        if (basebaseIndentString) {\n            sweetCode += basebaseIndentString;\n        }\n\n        sweetCode += output.join('').replace(/[\\r\\n\\t ]+$/, '');\n\n        // establish end_with_newline\n        if (end_with_newline) {\n            sweetCode += '\\n';\n        }\n\n        if (eol != '\\n') {\n            sweetCode = sweetCode.replace(/[\\n]/g, eol);\n        }\n\n        return sweetCode;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\n    css_beautify.NESTED_AT_RULE = {\n        \"@page\": true,\n        \"@font-face\": true,\n        \"@keyframes\": true,\n        // also in CONDITIONAL_GROUP_RULE below\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n    css_beautify.CONDITIONAL_GROUP_RULE = {\n        \"@media\": true,\n        \"@supports\": true,\n        \"@document\": true\n    };\n\n    /*global define */\n    if (typeof define === \"function\" && define.amd) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        define([], function() {\n            return {\n                css_beautify: css_beautify\n            };\n        });\n    } else if (typeof exports !== \"undefined\") {\n        // Add support for CommonJS. Just put this file somewhere on your require.paths\n        // and you will be able to `var html_beautify = require(\"beautify\").html_beautify`.\n        exports.css_beautify = css_beautify;\n    } else if (typeof window !== \"undefined\") {\n        // If we're running a web page and don't have either of the above, add our one global\n        window.css_beautify = css_beautify;\n    } else if (typeof global !== \"undefined\") {\n        // If we don't even have window, try global.\n        global.css_beautify = css_beautify;\n    }\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-beautify/js/lib/beautify-css.js\n ** module id = 6\n ** module chunks = 1\n **/","/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\n      http://jsbeautifier.org/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse-preserve-inline\" | \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/\n\n(function() {\n\n    var acorn = {};\n    (function (exports) {\n      // This section of code is taken from acorn.\n      //\n      // Acorn was written by Marijn Haverbeke and released under an MIT\n      // license. The Unicode regexps (for identifiers and whitespace) were\n      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n      //\n      // Git repositories for Acorn are available at\n      //\n      //     http://marijnhaverbeke.nl/git/acorn\n      //     https://github.com/marijnh/acorn.git\n\n      // ## Character categories\n\n      // Big ugly regular expressions that match characters in the\n      // whitespace, identifier, and identifier-start categories. These\n      // are only applied when a character is found to actually have a\n      // code point above 128.\n\n      var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n      var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n      var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n      var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n      var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n      // Whether a single character denotes a newline.\n\n      var newline = exports.newline = /[\\n\\r\\u2028\\u2029]/;\n\n      // Matches a whole line break (where CRLF is considered a single\n      // line break). Used to count lines.\n\n      // in javascript, these two differ\n      // in python they are the same, different methods are called on them\n      var lineBreak = exports.lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n      var allLineBreaks = exports.allLineBreaks = new RegExp(lineBreak.source, 'g');\n\n\n      // Test whether a given character code starts an identifier.\n\n      var isIdentifierStart = exports.isIdentifierStart = function(code) {\n        // permit $ (36) and @ (64). @ is used in ES7 decorators.\n        if (code < 65) return code === 36 || code === 64;\n        // 65 through 91 are uppercase letters.\n        if (code < 91) return true;\n        // permit _ (95).\n        if (code < 97) return code === 95;\n        // 97 through 123 are lowercase letters.\n        if (code < 123)return true;\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n      };\n\n      // Test whether a given character is part of an identifier.\n\n      var isIdentifierChar = exports.isIdentifierChar = function(code) {\n        if (code < 48) return code === 36;\n        if (code < 58) return true;\n        if (code < 65) return false;\n        if (code < 91) return true;\n        if (code < 97) return code === 95;\n        if (code < 123)return true;\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n      };\n    })(acorn);\n\n    function in_array(what, arr) {\n        for (var i = 0; i < arr.length; i += 1) {\n            if (arr[i] === what) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function trim(s) {\n        return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function ltrim(s) {\n        return s.replace(/^\\s+/g, '');\n    }\n\n    function rtrim(s) {\n        return s.replace(/\\s+$/g, '');\n    }\n\n    function js_beautify(js_source_text, options) {\n        \"use strict\";\n        var beautifier = new Beautifier(js_source_text, options);\n        return beautifier.beautify();\n    }\n\n    var MODE = {\n            BlockStatement: 'BlockStatement', // 'BLOCK'\n            Statement: 'Statement', // 'STATEMENT'\n            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\n            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\n            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\n            Conditional: 'Conditional', //'(COND-EXPRESSION)',\n            Expression: 'Expression' //'(EXPRESSION)'\n        };\n\n    function Beautifier(js_source_text, options) {\n        \"use strict\";\n        var output\n        var tokens = [], token_pos;\n        var Tokenizer;\n        var current_token;\n        var last_type, last_last_text, indent_string;\n        var flags, previous_flags, flag_store;\n        var prefix;\n\n        var handlers, opt;\n        var baseIndentString = '';\n\n        handlers = {\n            'TK_START_EXPR': handle_start_expr,\n            'TK_END_EXPR': handle_end_expr,\n            'TK_START_BLOCK': handle_start_block,\n            'TK_END_BLOCK': handle_end_block,\n            'TK_WORD': handle_word,\n            'TK_RESERVED': handle_word,\n            'TK_SEMICOLON': handle_semicolon,\n            'TK_STRING': handle_string,\n            'TK_EQUALS': handle_equals,\n            'TK_OPERATOR': handle_operator,\n            'TK_COMMA': handle_comma,\n            'TK_BLOCK_COMMENT': handle_block_comment,\n            'TK_COMMENT': handle_comment,\n            'TK_DOT': handle_dot,\n            'TK_UNKNOWN': handle_unknown,\n            'TK_EOF': handle_eof\n        };\n\n        function create_flags(flags_base, mode) {\n            var next_indent_level = 0;\n            if (flags_base) {\n                next_indent_level = flags_base.indentation_level;\n                if (!output.just_added_newline() &&\n                    flags_base.line_indent_level > next_indent_level) {\n                    next_indent_level = flags_base.line_indent_level;\n                }\n            }\n\n            var next_flags = {\n                mode: mode,\n                parent: flags_base,\n                last_text: flags_base ? flags_base.last_text : '', // last token text\n                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed\n                declaration_statement: false,\n                declaration_assignment: false,\n                multiline_frame: false,\n                inline_frame: false,\n                if_block: false,\n                else_block: false,\n                do_block: false,\n                do_while: false,\n                import_block: false,\n                in_case_statement: false, // switch(..){ INSIDE HERE }\n                in_case: false, // we're on the exact line with \"case 0:\"\n                case_body: false, // the indented case-action block\n                indentation_level: next_indent_level,\n                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n                start_line_index: output.get_line_number(),\n                ternary_depth: 0\n            };\n            return next_flags;\n        }\n\n        // Some interpreters have unexpected results with foo = baz || bar;\n        options = options ? options : {};\n        opt = {};\n\n        // compatibility\n        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\n            opt.brace_style = options.braces_on_own_line ? \"expand\" : \"collapse\";\n        }\n        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : \"collapse\");\n\n        // graceful handling of deprecated option\n        if (opt.brace_style === \"expand-strict\") {\n            opt.brace_style = \"expand\";\n        }\n\n        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;\n        opt.indent_char = options.indent_char ? options.indent_char : ' ';\n        opt.eol = options.eol ? options.eol : 'auto';\n        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\n        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;\n        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);\n        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;\n        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;\n        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;\n        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;\n        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;\n        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;\n        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;\n        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);\n        opt.e4x = (options.e4x === undefined) ? false : options.e4x;\n        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n        opt.comma_first = (options.comma_first === undefined) ? false : options.comma_first;\n\n        // For testing of beautify ignore:start directive\n        opt.test_output_raw = (options.test_output_raw === undefined) ? false : options.test_output_raw;\n\n        // force opt.space_after_anon_function to true if opt.jslint_happy\n        if(opt.jslint_happy) {\n            opt.space_after_anon_function = true;\n        }\n\n        if(options.indent_with_tabs){\n            opt.indent_char = '\\t';\n            opt.indent_size = 1;\n        }\n\n        if (opt.eol === 'auto') {\n            opt.eol = '\\n';\n            if (js_source_text && acorn.lineBreak.test(js_source_text || '')) {\n                opt.eol = js_source_text.match(acorn.lineBreak)[0];\n            }\n        }\n\n        opt.eol = opt.eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n')\n\n        //----------------------------------\n        indent_string = '';\n        while (opt.indent_size > 0) {\n            indent_string += opt.indent_char;\n            opt.indent_size -= 1;\n        }\n\n        var preindent_index = 0;\n        if(js_source_text && js_source_text.length) {\n            while ( (js_source_text.charAt(preindent_index) === ' ' ||\n                    js_source_text.charAt(preindent_index) === '\\t')) {\n                baseIndentString += js_source_text.charAt(preindent_index);\n                preindent_index += 1;\n            }\n            js_source_text = js_source_text.substring(preindent_index);\n        }\n\n        last_type = 'TK_START_BLOCK'; // last token type\n        last_last_text = ''; // pre-last token text\n        output = new Output(indent_string, baseIndentString);\n\n        // If testing the ignore directive, start with output disable set to true\n        output.raw = opt.test_output_raw;\n\n\n        // Stack of parsing/formatting states, including MODE.\n        // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n        // and formatted output.  This makes the beautifier less accurate than full parsers\n        // but also far more tolerant of syntax errors.\n        //\n        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n        // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n        // most full parsers would die, but the beautifier gracefully falls back to\n        // MODE.BlockStatement and continues on.\n        flag_store = [];\n        set_mode(MODE.BlockStatement);\n\n        this.beautify = function() {\n\n            /*jshint onevar:true */\n            var local_token, sweet_code;\n            Tokenizer = new tokenizer(js_source_text, opt, indent_string);\n            tokens = Tokenizer.tokenize();\n            token_pos = 0;\n\n            while (local_token = get_token()) {\n                for(var i = 0; i < local_token.comments_before.length; i++) {\n                    // The cleanest handling of inline comments is to treat them as though they aren't there.\n                    // Just continue formatting and the behavior should be logical.\n                    // Also ignore unknown tokens.  Again, this should result in better behavior.\n                    handle_token(local_token.comments_before[i]);\n                }\n                handle_token(local_token);\n\n                last_last_text = flags.last_text;\n                last_type = local_token.type;\n                flags.last_text = local_token.text;\n\n                token_pos += 1;\n            }\n\n            sweet_code = output.get_code();\n            if (opt.end_with_newline) {\n                sweet_code += '\\n';\n            }\n\n            if (opt.eol != '\\n') {\n                sweet_code = sweet_code.replace(/[\\n]/g, opt.eol);\n            }\n\n            return sweet_code;\n        };\n\n        function handle_token(local_token) {\n            var newlines = local_token.newlines;\n            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);\n\n            if (keep_whitespace) {\n                for (i = 0; i < newlines; i += 1) {\n                    print_newline(i > 0);\n                }\n            } else {\n                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {\n                    newlines = opt.max_preserve_newlines;\n                }\n\n                if (opt.preserve_newlines) {\n                    if (local_token.newlines > 1) {\n                        print_newline();\n                        for (var i = 1; i < newlines; i += 1) {\n                            print_newline(true);\n                        }\n                    }\n                }\n            }\n\n            current_token = local_token;\n            handlers[current_token.type]();\n        }\n\n        // we could use just string.split, but\n        // IE doesn't like returning empty strings\n        function split_linebreaks(s) {\n            //return s.split(/\\x0d\\x0a|\\x0a/);\n\n            s = s.replace(acorn.allLineBreaks, '\\n');\n            var out = [],\n                idx = s.indexOf(\"\\n\");\n            while (idx !== -1) {\n                out.push(s.substring(0, idx));\n                s = s.substring(idx + 1);\n                idx = s.indexOf(\"\\n\");\n            }\n            if (s.length) {\n                out.push(s);\n            }\n            return out;\n        }\n\n        var newline_restricted_tokens = ['break','contiue','return', 'throw'];\n        function allow_wrap_or_preserved_newline(force_linewrap) {\n            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\n\n            // Never wrap the first token on a line\n            if (output.just_added_newline()) {\n                return\n            }\n\n            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {\n                print_newline(false, true);\n            } else if (opt.wrap_line_length) {\n                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, newline_restricted_tokens)) {\n                    // These tokens should never have a newline inserted\n                    // between them and the following expression.\n                    return\n                }\n                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +\n                    (output.space_before_token ? 1 : 0);\n                if (proposed_line_length >= opt.wrap_line_length) {\n                    print_newline(false, true);\n                }\n            }\n        }\n\n        function print_newline(force_newline, preserve_statement_flags) {\n            if (!preserve_statement_flags) {\n                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {\n                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\n                        restore_mode();\n                    }\n                }\n            }\n\n            if (output.add_new_line(force_newline)) {\n                flags.multiline_frame = true;\n            }\n        }\n\n        function print_token_line_indentation() {\n            if (output.just_added_newline()) {\n                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {\n                    output.current_line.push(current_token.whitespace_before);\n                    output.space_before_token = false;\n                } else if (output.set_indent(flags.indentation_level)) {\n                    flags.line_indent_level = flags.indentation_level;\n                }\n            }\n        }\n\n        function print_token(printable_token) {\n            if (output.raw) {\n                output.add_raw_token(current_token)\n                return;\n            }\n\n            if (opt.comma_first && last_type === 'TK_COMMA'\n                && output.just_added_newline()) {\n                if(output.previous_line.last() === ',') {\n                    var popped = output.previous_line.pop();\n                    // if the comma was already at the start of the line,\n                    // pull back onto that line and reprint the indentation\n                    if(output.previous_line.is_empty()) {\n                         output.previous_line.push(popped);\n                         output.trim(true);\n                         output.current_line.pop();\n                         output.trim();\n                    }\n\n                    // add the comma in front of the next token\n                    print_token_line_indentation();\n                    output.add_token(',');\n                    output.space_before_token = true;\n                }\n            }\n\n            printable_token = printable_token || current_token.text;\n            print_token_line_indentation();\n            output.add_token(printable_token);\n        }\n\n        function indent() {\n            flags.indentation_level += 1;\n        }\n\n        function deindent() {\n            if (flags.indentation_level > 0 &&\n                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))\n                flags.indentation_level -= 1;\n        }\n\n        function set_mode(mode) {\n            if (flags) {\n                flag_store.push(flags);\n                previous_flags = flags;\n            } else {\n                previous_flags = create_flags(null, mode);\n            }\n\n            flags = create_flags(previous_flags, mode);\n        }\n\n        function is_array(mode) {\n            return mode === MODE.ArrayLiteral;\n        }\n\n        function is_expression(mode) {\n            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\n        }\n\n        function restore_mode() {\n            if (flag_store.length > 0) {\n                previous_flags = flags;\n                flags = flag_store.pop();\n                if (previous_flags.mode === MODE.Statement) {\n                    output.remove_redundant_indentation(previous_flags);\n                }\n            }\n        }\n\n        function start_of_object_property() {\n            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (\n                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));\n        }\n\n        function start_of_statement() {\n            if (\n                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||\n                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw']) && !current_token.wanted_newline) ||\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||\n                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||\n                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement\n                        && !flags.in_case\n                        && !(current_token.text === '--' || current_token.text === '++')\n                        && last_last_text !== 'function'\n                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||\n                    (flags.mode === MODE.ObjectLiteral && (\n                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))\n                ) {\n\n                set_mode(MODE.Statement);\n                indent();\n\n                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {\n                    flags.declaration_statement = true;\n                }\n\n                // Issue #276:\n                // If starting a new statement with [if, for, while, do], push to a new line.\n                // if (a) if (b) if(c) d(); else e(); else f();\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline(\n                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        function all_lines_start_with(lines, c) {\n            for (var i = 0; i < lines.length; i++) {\n                var line = trim(lines[i]);\n                if (line.charAt(0) !== c) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function each_line_matches_indent(lines, indent) {\n            var i = 0,\n                len = lines.length,\n                line;\n            for (; i < len; i++) {\n                line = lines[i];\n                // allow empty lines to pass through\n                if (line && line.indexOf(indent) !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function is_special_word(word) {\n            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);\n        }\n\n        function get_token(offset) {\n            var index = token_pos + (offset || 0);\n            return (index < 0 || index >= tokens.length) ? null : tokens[index];\n        }\n\n        function handle_start_expr() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            var next_mode = MODE.Expression;\n            if (current_token.text === '[') {\n\n                if (last_type === 'TK_WORD' || flags.last_text === ')') {\n                    // this is array index specifier, break immediately\n                    // a[x], fn()[x]\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {\n                        output.space_before_token = true;\n                    }\n                    set_mode(next_mode);\n                    print_token();\n                    indent();\n                    if (opt.space_in_paren) {\n                        output.space_before_token = true;\n                    }\n                    return;\n                }\n\n                next_mode = MODE.ArrayLiteral;\n                if (is_array(flags.mode)) {\n                    if (flags.last_text === '[' ||\n                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {\n                        // ], [ goes to new line\n                        // }, [ goes to new line\n                        if (!opt.keep_array_indentation) {\n                            print_newline();\n                        }\n                    }\n                }\n\n            } else {\n                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {\n                    next_mode = MODE.ForInitializer;\n                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {\n                    next_mode = MODE.Conditional;\n                } else {\n                    // next_mode = MODE.Expression;\n                }\n            }\n\n            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {\n                print_newline();\n            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {\n                // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n                allow_wrap_or_preserved_newline(current_token.wanted_newline);\n                // do nothing on (( and )( and ][ and ]( and .(\n            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\n                output.space_before_token = true;\n            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||\n                (flags.last_text === '*' && last_last_text === 'function')) {\n                // function() vs function ()\n                if (opt.space_after_anon_function) {\n                    output.space_before_token = true;\n                }\n            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {\n                if (opt.space_before_conditional) {\n                    output.space_before_token = true;\n                }\n            }\n\n            // Should be a space between await and an IIFE\n            if(current_token.text === '(' && last_type === 'TK_RESERVED' && flags.last_word === 'await'){\n                output.space_before_token = true;\n            }\n\n            // Support of this kind of newline preservation.\n            // a = (b &&\n            //     (c || d));\n            if (current_token.text === '(') {\n                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                    if (!start_of_object_property()) {\n                        allow_wrap_or_preserved_newline();\n                    }\n                }\n            }\n\n            // Support preserving wrapped arrow function expressions\n            // a.b('c',\n            //     () => d.e\n            // )\n            if (current_token.text === '(' && last_type !== 'TK_WORD' && last_type !== 'TK_RESERVED') {\n                allow_wrap_or_preserved_newline();\n            }\n\n            set_mode(next_mode);\n            print_token();\n            if (opt.space_in_paren) {\n                output.space_before_token = true;\n            }\n\n            // In all cases, if we newline while inside an expression it should be indented.\n            indent();\n        }\n\n        function handle_end_expr() {\n            // statements inside expressions are not valid syntax, but...\n            // statements must all be closed when their container closes\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n\n            if (flags.multiline_frame) {\n                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);\n            }\n\n            if (opt.space_in_paren) {\n                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {\n                    // () [] no inner space in empty parens like these, ever, ref #320\n                    output.trim();\n                    output.space_before_token = false;\n                } else {\n                    output.space_before_token = true;\n                }\n            }\n            if (current_token.text === ']' && opt.keep_array_indentation) {\n                print_token();\n                restore_mode();\n            } else {\n                restore_mode();\n                print_token();\n            }\n            output.remove_redundant_indentation(previous_flags);\n\n            // do {} while () // no statement required after\n            if (flags.do_while && previous_flags.mode === MODE.Conditional) {\n                previous_flags.mode = MODE.Expression;\n                flags.do_block = false;\n                flags.do_while = false;\n\n            }\n        }\n\n        function handle_start_block() {\n            // Check if this is should be treated as a ObjectLiteral\n            var next_token = get_token(1)\n            var second_token = get_token(2)\n            if (second_token && (\n                    (in_array(second_token.text, [':', ',']) && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))\n                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))\n                )) {\n                // We don't support TypeScript,but we didn't break it for a very long time.\n                // We'll try to keep not breaking it.\n                if (!in_array(last_last_text, ['class','interface'])) {\n                    set_mode(MODE.ObjectLiteral);\n                } else {\n                    set_mode(MODE.BlockStatement);\n                }\n            } else if (last_type === 'TK_OPERATOR' && flags.last_text === '=>') {\n                // arrow function: (param1, paramN) => { statements }\n                set_mode(MODE.BlockStatement);\n            } else if (in_array(last_type, ['TK_EQUALS', 'TK_START_EXPR', 'TK_COMMA', 'TK_OPERATOR']) ||\n                (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['return', 'throw', 'import']))\n                ) {\n                // Detecting shorthand function syntax is difficult by scanning forward,\n                //     so check the surrounding context.\n                // If the block is being returned, imported, passed as arg,\n                //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.\n                set_mode(MODE.ObjectLiteral);\n            } else {\n                set_mode(MODE.BlockStatement);\n            }\n\n            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';\n            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&\n                last_type === 'TK_END_EXPR';\n\n\n            if (opt.brace_style === \"expand\" ||\n                (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                if (last_type !== 'TK_OPERATOR' &&\n                    (empty_anonymous_function ||\n                        last_type === 'TK_EQUALS' ||\n                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {\n                    output.space_before_token = true;\n                } else {\n                    print_newline(false, true);\n                }\n            } else { // collapse\n                if (opt.brace_style === 'collapse-preserve-inline') {\n                    // search forward for a newline wanted inside this block\n                    var index = 0;\n                    var check_token = null;\n                    flags.inline_frame = true;\n                    do {\n                        index += 1;\n                        check_token = get_token(index);\n                        if (check_token.wanted_newline) {\n                            flags.inline_frame = false;\n                            break;\n                        }\n                    } while (check_token.type !== 'TK_EOF' &&\n                          !(check_token.type === 'TK_END_BLOCK' && check_token.opened === current_token))\n                }\n\n                if (is_array(previous_flags.mode) && (last_type === 'TK_START_EXPR' || last_type === 'TK_COMMA')) {\n                    // if we're preserving inline,\n                    // allow newline between comma and next brace.\n                    if (flags.inline_frame) {\n                        allow_wrap_or_preserved_newline();\n                        flags.inline_frame = true;\n                        previous_flags.multiline_frame = previous_flags.multiline_frame || flags.multiline_frame;\n                        flags.multiline_frame = false;\n                    } else if (last_type === 'TK_COMMA') {\n                        output.space_before_token = true;\n                    }\n                } else if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\n                    if (last_type === 'TK_START_BLOCK') {\n                        print_newline();\n                    } else {\n                        output.space_before_token = true;\n                    }\n                }\n            }\n            print_token();\n            indent();\n        }\n\n        function handle_end_block() {\n            // statements must all be closed when their container closes\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n            var empty_braces = last_type === 'TK_START_BLOCK';\n\n            if (opt.brace_style === \"expand\") {\n                if (!empty_braces) {\n                    print_newline();\n                }\n            } else {\n                // skip {}\n                if (!empty_braces) {\n                    if (flags.inline_frame) {\n                        output.space_before_token = true;\n                    } else if (is_array(flags.mode) && opt.keep_array_indentation) {\n                        // we REALLY need a newline here, but newliner would skip that\n                        opt.keep_array_indentation = false;\n                        print_newline();\n                        opt.keep_array_indentation = true;\n\n                    } else {\n                        print_newline();\n                    }\n                }\n            }\n            restore_mode();\n            print_token();\n        }\n\n        function handle_word() {\n            if (current_token.type === 'TK_RESERVED') {\n                if (in_array(current_token.text, ['set', 'get']) && flags.mode !== MODE.ObjectLiteral) {\n                    current_token.type = 'TK_WORD';\n                } else if (in_array(current_token.text, ['as', 'from']) && !flags.import_block) {\n                    current_token.type = 'TK_WORD';\n                } else if (flags.mode === MODE.ObjectLiteral) {\n                    var next_token = get_token(1);\n                    if (next_token.text == ':') {\n                        current_token.type = 'TK_WORD';\n                    }\n                }\n            }\n\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&\n                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&\n                last_type !== 'TK_EQUALS' &&\n                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {\n\n                print_newline();\n            }\n\n            if (flags.do_block && !flags.do_while) {\n                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {\n                    // do {} ## while ()\n                    output.space_before_token = true;\n                    print_token();\n                    output.space_before_token = true;\n                    flags.do_while = true;\n                    return;\n                } else {\n                    // do {} should always have while as the next word.\n                    // if we don't see the expected while, recover\n                    print_newline();\n                    flags.do_block = false;\n                }\n            }\n\n            // if may be followed by else, or not\n            // Bare/inline ifs are tricky\n            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n            if (flags.if_block) {\n                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {\n                    flags.else_block = true;\n                } else {\n                    while (flags.mode === MODE.Statement) {\n                        restore_mode();\n                    }\n                    flags.if_block = false;\n                    flags.else_block = false;\n                }\n            }\n\n            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {\n                print_newline();\n                if (flags.case_body || opt.jslint_happy) {\n                    // switch cases following one another\n                    deindent();\n                    flags.case_body = false;\n                }\n                print_token();\n                flags.in_case = true;\n                flags.in_case_statement = true;\n                return;\n            }\n\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {\n                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {\n                    // make sure there is a nice clean space of at least one blank line\n                    // before a new function definition\n                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {\n                        print_newline();\n                        print_newline(true);\n                    }\n                }\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export', 'async'])) {\n                        output.space_before_token = true;\n                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {\n                        output.space_before_token = true;\n                    } else {\n                        print_newline();\n                    }\n                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {\n                    // foo = function\n                    output.space_before_token = true;\n                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {\n                    // (function\n                } else {\n                    print_newline();\n                }\n            }\n\n            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline();\n                }\n            }\n\n            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {\n                print_token();\n                flags.last_word = current_token.text;\n                return;\n            }\n\n            prefix = 'NONE';\n\n            if (last_type === 'TK_END_BLOCK') {\n\n                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally', 'from']))) {\n                    prefix = 'NEWLINE';\n                } else {\n                    if (opt.brace_style === \"expand\" ||\n                        opt.brace_style === \"end-expand\" ||\n                        (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                        prefix = 'NEWLINE';\n                    } else {\n                        prefix = 'SPACE';\n                        output.space_before_token = true;\n                    }\n                }\n            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {\n                // TODO: Should this be for STATEMENT as well?\n                prefix = 'NEWLINE';\n            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\n                prefix = 'SPACE';\n            } else if (last_type === 'TK_STRING') {\n                prefix = 'NEWLINE';\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||\n                (flags.last_text === '*' && last_last_text === 'function')) {\n                prefix = 'SPACE';\n            } else if (last_type === 'TK_START_BLOCK') {\n                if (flags.inline_frame) {\n                    prefix = 'SPACE';\n                } else {\n                    prefix = 'NEWLINE';\n                }\n            } else if (last_type === 'TK_END_EXPR') {\n                output.space_before_token = true;\n                prefix = 'NEWLINE';\n            }\n\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\n                if (flags.last_text === 'else' || flags.last_text === 'export') {\n                    prefix = 'SPACE';\n                } else {\n                    prefix = 'NEWLINE';\n                }\n\n            }\n\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {\n                if (!(last_type === 'TK_END_BLOCK' && previous_flags.mode === MODE.BlockStatement) ||\n                    opt.brace_style === \"expand\" ||\n                    opt.brace_style === \"end-expand\" ||\n                    (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                    print_newline();\n                } else {\n                    output.trim(true);\n                    var line = output.current_line;\n                    // If we trimmed and there's something other than a close block before us\n                    // put a newline back in.  Handles '} // comment' scenario.\n                    if (line.last() !== '}') {\n                        print_newline();\n                    }\n                    output.space_before_token = true;\n                }\n            } else if (prefix === 'NEWLINE') {\n                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                    // no newline between 'return nnn'\n                    output.space_before_token = true;\n                } else if (last_type !== 'TK_END_EXPR') {\n                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {\n                        // no need to force newline on 'var': for (var x = 0...)\n                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {\n                            // no newline for } else if {\n                            output.space_before_token = true;\n                        } else {\n                            print_newline();\n                        }\n                    }\n                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\n                    print_newline();\n                }\n            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {\n                print_newline(); // }, in lists get a newline treatment\n            } else if (prefix === 'SPACE') {\n                output.space_before_token = true;\n            }\n            print_token();\n            flags.last_word = current_token.text;\n\n            if (current_token.type === 'TK_RESERVED') {\n                if (current_token.text === 'do') {\n                    flags.do_block = true;\n                } else if (current_token.text === 'if') {\n                    flags.if_block = true;\n                } else if (current_token.text === 'import') {\n                    flags.import_block = true;\n                } else if (flags.import_block && current_token.type === 'TK_RESERVED' && current_token.text === 'from') {\n                    flags.import_block = false;\n                }\n            }\n        }\n\n        function handle_semicolon() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n                // Semicolon can be the start (and end) of a statement\n                output.space_before_token = false;\n            }\n            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\n                restore_mode();\n            }\n\n            // hacky but effective for the moment\n            if (flags.import_block) {\n                flags.import_block = false;\n            }\n            print_token();\n        }\n\n        function handle_string() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n                // One difference - strings want at least a space before\n                output.space_before_token = true;\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' || flags.inline_frame) {\n                output.space_before_token = true;\n            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline();\n                }\n            } else {\n                print_newline();\n            }\n            print_token();\n        }\n\n        function handle_equals() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (flags.declaration_statement) {\n                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n                flags.declaration_assignment = true;\n            }\n            output.space_before_token = true;\n            print_token();\n            output.space_before_token = true;\n        }\n\n        function handle_comma() {\n            print_token();\n            output.space_before_token = true;\n            if (flags.declaration_statement) {\n                if (is_expression(flags.parent.mode)) {\n                    // do not break on comma, for(var a = 1, b = 2)\n                    flags.declaration_assignment = false;\n                }\n\n                if (flags.declaration_assignment) {\n                    flags.declaration_assignment = false;\n                    print_newline(false, true);\n                } else if (opt.comma_first) {\n                    // for comma-first, we want to allow a newline before the comma\n                    // to turn into a newline after the comma, which we will fixup later\n                    allow_wrap_or_preserved_newline();\n                }\n            } else if (flags.mode === MODE.ObjectLiteral ||\n                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {\n                if (flags.mode === MODE.Statement) {\n                    restore_mode();\n                }\n\n                if (!flags.inline_frame) {\n                    print_newline();\n                }\n            } else if (opt.comma_first) {\n                // EXPR or DO_BLOCK\n                // for comma-first, we want to allow a newline before the comma\n                // to turn into a newline after the comma, which we will fixup later\n                allow_wrap_or_preserved_newline();\n            }\n        }\n\n        function handle_operator() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                // \"return\" had a special handling in TK_WORD. Now we need to return the favor\n                output.space_before_token = true;\n                print_token();\n                return;\n            }\n\n            // hack for actionscript's import .*;\n            if (current_token.text === '*' && last_type === 'TK_DOT') {\n                print_token();\n                return;\n            }\n\n            if (current_token.text === ':' && flags.in_case) {\n                flags.case_body = true;\n                indent();\n                print_token();\n                print_newline();\n                flags.in_case = false;\n                return;\n            }\n\n            if (current_token.text === '::') {\n                // no spaces around exotic namespacing syntax operator\n                print_token();\n                return;\n            }\n\n            // Allow line wrapping between operators\n            if (last_type === 'TK_OPERATOR') {\n                allow_wrap_or_preserved_newline();\n            }\n\n            var space_before = true;\n            var space_after = true;\n\n            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {\n                // unary operators (and binary +/- pretending to be unary) special cases\n\n                space_before = false;\n                space_after = false;\n\n                // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n                // if there is a newline between -- or ++ and anything else we should preserve it.\n                if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {\n                    print_newline(false, true);\n                }\n\n                if (flags.last_text === ';' && is_expression(flags.mode)) {\n                    // for (;; ++i)\n                    //        ^^^\n                    space_before = true;\n                }\n\n                if (last_type === 'TK_RESERVED') {\n                    space_before = true;\n                } else if (last_type === 'TK_END_EXPR') {\n                    space_before = !(flags.last_text === ']' && (current_token.text === '--' || current_token.text === '++'));\n                } else if (last_type === 'TK_OPERATOR') {\n                    // a++ + ++b;\n                    // a - -b\n                    space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(flags.last_text, ['--', '-', '++', '+']);\n                    // + and - are not unary when preceeded by -- or ++ operator\n                    // a-- + b\n                    // a * +b\n                    // a - -b\n                    if (in_array(current_token.text, ['+', '-']) && in_array(flags.last_text, ['--', '++'])) {\n                        space_after = true;\n                    }\n                }\n\n\n                if (((flags.mode === MODE.BlockStatement && !flags.inline_frame) || flags.mode === MODE.Statement)\n                    && (flags.last_text === '{' || flags.last_text === ';')) {\n                    // { foo; --i }\n                    // foo(); --bar;\n                    print_newline();\n                }\n            } else if (current_token.text === ':') {\n                if (flags.ternary_depth === 0) {\n                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n                    space_before = false;\n                } else {\n                    flags.ternary_depth -= 1;\n                }\n            } else if (current_token.text === '?') {\n                flags.ternary_depth += 1;\n            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {\n                space_before = false;\n                space_after = false;\n            }\n            output.space_before_token = output.space_before_token || space_before;\n            print_token();\n            output.space_before_token = space_after;\n        }\n\n        function handle_block_comment() {\n            if (output.raw) {\n                output.add_raw_token(current_token)\n                if (current_token.directives && current_token.directives['preserve'] === 'end') {\n                    // If we're testing the raw output behavior, do not allow a directive to turn it off.\n                    if (!opt.test_output_raw) {\n                        output.raw = false;\n                    }\n                }\n                return;\n            }\n\n            if (current_token.directives) {\n                print_newline(false, true);\n                print_token();\n                if (current_token.directives['preserve'] === 'start') {\n                    output.raw = true;\n                }\n                print_newline(false, true);\n                return;\n            }\n\n            // inline block\n            if (!acorn.newline.test(current_token.text) && !current_token.wanted_newline) {\n                output.space_before_token = true;\n                print_token();\n                output.space_before_token = true;\n                return;\n            }\n\n            var lines = split_linebreaks(current_token.text);\n            var j; // iterator for this case\n            var javadoc = false;\n            var starless = false;\n            var lastIndent = current_token.whitespace_before;\n            var lastIndentLength = lastIndent.length;\n\n            // block comment starts with a new line\n            print_newline(false, true);\n            if (lines.length > 1) {\n                if (all_lines_start_with(lines.slice(1), '*')) {\n                    javadoc = true;\n                }\n                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {\n                    starless = true;\n                }\n            }\n\n            // first line always indented\n            print_token(lines[0]);\n            for (j = 1; j < lines.length; j++) {\n                print_newline(false, true);\n                if (javadoc) {\n                    // javadoc: reformat and re-indent\n                    print_token(' ' + ltrim(lines[j]));\n                } else if (starless && lines[j].length > lastIndentLength) {\n                    // starless: re-indent non-empty content, avoiding trim\n                    print_token(lines[j].substring(lastIndentLength));\n                } else {\n                    // normal comments output raw\n                    output.add_token(lines[j]);\n                }\n            }\n\n            // for comments of more than one line, make sure there's a new line after\n            print_newline(false, true);\n        }\n\n        function handle_comment() {\n            if (current_token.wanted_newline) {\n                print_newline(false, true);\n            } else {\n                output.trim(true);\n            }\n\n            output.space_before_token = true;\n            print_token();\n            print_newline(false, true);\n        }\n\n        function handle_dot() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                output.space_before_token = true;\n            } else {\n                // allow preserved newlines before dots in general\n                // force newlines on dots after close paren when break_chained - for bar().baz()\n                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);\n            }\n\n            print_token();\n        }\n\n        function handle_unknown() {\n            print_token();\n\n            if (current_token.text[current_token.text.length - 1] === '\\n') {\n                print_newline();\n            }\n        }\n\n        function handle_eof() {\n            // Unwind any open statements\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n        }\n    }\n\n\n    function OutputLine(parent) {\n        var _character_count = 0;\n        // use indent_count as a marker for lines that have preserved indentation\n        var _indent_count = -1;\n\n        var _items = [];\n        var _empty = true;\n\n        this.set_indent = function(level) {\n            _character_count = parent.baseIndentLength + level * parent.indent_length\n            _indent_count = level;\n        }\n\n        this.get_character_count = function() {\n            return _character_count;\n        }\n\n        this.is_empty = function() {\n            return _empty;\n        }\n\n        this.last = function() {\n            if (!this._empty) {\n              return _items[_items.length - 1];\n            } else {\n              return null;\n            }\n        }\n\n        this.push = function(input) {\n            _items.push(input);\n            _character_count += input.length;\n            _empty = false;\n        }\n\n        this.pop = function() {\n            var item = null;\n            if (!_empty) {\n                item = _items.pop();\n                _character_count -= item.length;\n                _empty = _items.length === 0;\n            }\n            return item;\n        }\n\n        this.remove_indent = function() {\n            if (_indent_count > 0) {\n                _indent_count -= 1;\n                _character_count -= parent.indent_length\n            }\n        }\n\n        this.trim = function() {\n            while (this.last() === ' ') {\n                var item = _items.pop();\n                _character_count -= 1;\n            }\n            _empty = _items.length === 0;\n        }\n\n        this.toString = function() {\n            var result = '';\n            if (!this._empty) {\n                if (_indent_count >= 0) {\n                    result = parent.indent_cache[_indent_count];\n                }\n                result += _items.join('')\n            }\n            return result;\n        }\n    }\n\n    function Output(indent_string, baseIndentString) {\n        baseIndentString = baseIndentString || '';\n        this.indent_cache = [ baseIndentString ];\n        this.baseIndentLength = baseIndentString.length;\n        this.indent_length = indent_string.length;\n        this.raw = false;\n\n        var lines =[];\n        this.baseIndentString = baseIndentString;\n        this.indent_string = indent_string;\n        this.previous_line = null;\n        this.current_line = null;\n        this.space_before_token = false;\n\n        this.add_outputline = function() {\n            this.previous_line = this.current_line;\n            this.current_line = new OutputLine(this);\n            lines.push(this.current_line);\n        }\n\n        // initialize\n        this.add_outputline();\n\n\n        this.get_line_number = function() {\n            return lines.length;\n        }\n\n        // Using object instead of string to allow for later expansion of info about each line\n        this.add_new_line = function(force_newline) {\n            if (this.get_line_number() === 1 && this.just_added_newline()) {\n                return false; // no newline on start of file\n            }\n\n            if (force_newline || !this.just_added_newline()) {\n                if (!this.raw) {\n                    this.add_outputline();\n                }\n                return true;\n            }\n\n            return false;\n        }\n\n        this.get_code = function() {\n            var sweet_code = lines.join('\\n').replace(/[\\r\\n\\t ]+$/, '');\n            return sweet_code;\n        }\n\n        this.set_indent = function(level) {\n            // Never indent your first output indent at the start of the file\n            if (lines.length > 1) {\n                while(level >= this.indent_cache.length) {\n                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);\n                }\n\n                this.current_line.set_indent(level);\n                return true;\n            }\n            this.current_line.set_indent(0);\n            return false;\n        }\n\n        this.add_raw_token = function(token) {\n            for (var x = 0; x < token.newlines; x++) {\n                this.add_outputline();\n            }\n            this.current_line.push(token.whitespace_before);\n            this.current_line.push(token.text);\n            this.space_before_token = false;\n        }\n\n        this.add_token = function(printable_token) {\n            this.add_space_before_token();\n            this.current_line.push(printable_token);\n        }\n\n        this.add_space_before_token = function() {\n            if (this.space_before_token && !this.just_added_newline()) {\n                this.current_line.push(' ');\n            }\n            this.space_before_token = false;\n        }\n\n        this.remove_redundant_indentation = function (frame) {\n            // This implementation is effective but has some issues:\n            //     - can cause line wrap to happen too soon due to indent removal\n            //           after wrap points are calculated\n            // These issues are minor compared to ugly indentation.\n\n            if (frame.multiline_frame ||\n                frame.mode === MODE.ForInitializer ||\n                frame.mode === MODE.Conditional) {\n                return;\n            }\n\n            // remove one indent from each line inside this section\n            var index = frame.start_line_index;\n            var line;\n\n            var output_length = lines.length;\n            while (index < output_length) {\n                lines[index].remove_indent();\n                index++;\n            }\n        }\n\n        this.trim = function(eat_newlines) {\n            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n            this.current_line.trim(indent_string, baseIndentString);\n\n            while (eat_newlines && lines.length > 1 &&\n                this.current_line.is_empty()) {\n                lines.pop();\n                this.current_line = lines[lines.length - 1]\n                this.current_line.trim();\n            }\n\n            this.previous_line = lines.length > 1 ? lines[lines.length - 2] : null;\n        }\n\n        this.just_added_newline = function() {\n            return this.current_line.is_empty();\n        }\n\n        this.just_added_blankline = function() {\n            if (this.just_added_newline()) {\n                if (lines.length === 1) {\n                    return true; // start of the file and newline = blank\n                }\n\n                var line = lines[lines.length - 2];\n                return line.is_empty();\n            }\n            return false;\n        }\n    }\n\n\n    var Token = function(type, text, newlines, whitespace_before, mode, parent) {\n        this.type = type;\n        this.text = text;\n        this.comments_before = [];\n        this.newlines = newlines || 0;\n        this.wanted_newline = newlines > 0;\n        this.whitespace_before = whitespace_before || '';\n        this.parent = null;\n        this.opened = null;\n        this.directives = null;\n    }\n\n    function tokenizer(input, opts, indent_string) {\n\n        var whitespace = \"\\n\\r\\t \".split('');\n        var digit = /[0-9]/;\n        var digit_bin = /[01]/;\n        var digit_oct = /[01234567]/;\n        var digit_hex = /[0123456789abcdefABCDEF]/;\n\n        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: => **').split(' ');\n        // words which should always start on new line.\n        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');\n        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as']);\n\n        //  /* ... */ comment ends with nearest */ or end of file\n        var block_comment_pattern = /([\\s\\S]*?)((?:\\*\\/)|$)/g;\n\n        // comment ends just before nearest linefeed or end of file\n        var comment_pattern = /([^\\n\\r\\u2028\\u2029]*)/g;\n\n        var directives_block_pattern = /\\/\\* beautify( \\w+[:]\\w+)+ \\*\\//g;\n        var directive_pattern = / (\\w+)[:](\\w+)/g;\n        var directives_end_ignore_pattern = /([\\s\\S]*?)((?:\\/\\*\\sbeautify\\signore:end\\s\\*\\/)|$)/g;\n\n        var template_pattern = /((<\\?php|<\\?=)[\\s\\S]*?\\?>)|(<%[\\s\\S]*?%>)/g\n\n        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;\n        var input_length;\n\n        this.tokenize = function() {\n            // cache the source's length.\n            input_length = input.length\n            parser_pos = 0;\n            in_html_comment = false\n            tokens = [];\n\n            var next, last;\n            var token_values;\n            var open = null;\n            var open_stack = [];\n            var comments = [];\n\n            while (!(last && last.type === 'TK_EOF')) {\n                token_values = tokenize_next();\n                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\n                while(next.type === 'TK_COMMENT' || next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {\n                    if (next.type === 'TK_BLOCK_COMMENT') {\n                        next.directives = token_values[2];\n                    }\n                    comments.push(next);\n                    token_values = tokenize_next();\n                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\n                }\n\n                if (comments.length) {\n                    next.comments_before = comments;\n                    comments = [];\n                }\n\n                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {\n                    next.parent = last;\n                    open_stack.push(open);\n                    open = next;\n                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&\n                    (open && (\n                        (next.text === ']' && open.text === '[') ||\n                        (next.text === ')' && open.text === '(') ||\n                        (next.text === '}' && open.text === '{')))) {\n                    next.parent = open.parent;\n                    next.opened = open\n\n                    open = open_stack.pop();\n                }\n\n                tokens.push(next);\n                last = next;\n            }\n\n            return tokens;\n        }\n\n        function get_directives (text) {\n            if (!text.match(directives_block_pattern)) {\n                return null;\n            }\n\n            var directives = {};\n            directive_pattern.lastIndex = 0;\n            var directive_match = directive_pattern.exec(text);\n\n            while (directive_match) {\n                directives[directive_match[1]] = directive_match[2];\n                directive_match = directive_pattern.exec(text);\n            }\n\n            return directives;\n        }\n\n        function tokenize_next() {\n            var i, resulting_string;\n            var whitespace_on_this_line = [];\n\n            n_newlines = 0;\n            whitespace_before_token = '';\n\n            if (parser_pos >= input_length) {\n                return ['', 'TK_EOF'];\n            }\n\n            var last_token;\n            if (tokens.length) {\n                last_token = tokens[tokens.length-1];\n            } else {\n                // For the sake of tokenizing we can pretend that there was on open brace to start\n                last_token = new Token('TK_START_BLOCK', '{');\n            }\n\n\n            var c = input.charAt(parser_pos);\n            parser_pos += 1;\n\n            while (in_array(c, whitespace)) {\n\n                if (acorn.newline.test(c)) {\n                    if (!(c === '\\n' && input.charAt(parser_pos-2) === '\\r')) {\n                        n_newlines += 1;\n                        whitespace_on_this_line = [];\n                    }\n                } else {\n                    whitespace_on_this_line.push(c);\n                }\n\n                if (parser_pos >= input_length) {\n                    return ['', 'TK_EOF'];\n                }\n\n                c = input.charAt(parser_pos);\n                parser_pos += 1;\n            }\n\n            if(whitespace_on_this_line.length) {\n                whitespace_before_token = whitespace_on_this_line.join('');\n            }\n\n            if (digit.test(c) || (c === '.' && digit.test(input.charAt(parser_pos)))) {\n                var allow_decimal = true;\n                var allow_e = true;\n                var local_digit = digit;\n\n                if (c === '0' && parser_pos < input_length && /[XxOoBb]/.test(input.charAt(parser_pos))) {\n                    // switch to hex/oct/bin number, no decimal or e, just hex/oct/bin digits\n                    allow_decimal = false;\n                    allow_e = false;\n                    if ( /[Bb]/.test(input.charAt(parser_pos)) ) {\n                        local_digit = digit_bin;\n                    } else if ( /[Oo]/.test(input.charAt(parser_pos)) ) {\n                        local_digit = digit_oct;\n                    } else {\n                        local_digit = digit_hex;\n                    }\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n                } else if (c === '.') {\n                    // Already have a decimal for this literal, don't allow another\n                    allow_decimal = false;\n                } else {\n                    // we know this first loop will run.  It keeps the logic simpler.\n                    c = '';\n                    parser_pos -= 1;\n                }\n\n                // Add the digits\n                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n\n                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n                        allow_decimal = false;\n                    } else if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n\n                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {\n                            c += input.charAt(parser_pos);\n                            parser_pos += 1;\n                        }\n\n                        allow_e = false;\n                        allow_decimal = false;\n                    }\n                }\n\n                return [c, 'TK_WORD'];\n            }\n\n            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {\n                if (parser_pos < input_length) {\n                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n                        if (parser_pos === input_length) {\n                            break;\n                        }\n                    }\n                }\n\n                if (!(last_token.type === 'TK_DOT' ||\n                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))\n                    && in_array(c, reserved_words)) {\n                    if (c === 'in') { // hack for 'in' operator\n                        return [c, 'TK_OPERATOR'];\n                    }\n                    return [c, 'TK_RESERVED'];\n                }\n\n                return [c, 'TK_WORD'];\n            }\n\n            if (c === '(' || c === '[') {\n                return [c, 'TK_START_EXPR'];\n            }\n\n            if (c === ')' || c === ']') {\n                return [c, 'TK_END_EXPR'];\n            }\n\n            if (c === '{') {\n                return [c, 'TK_START_BLOCK'];\n            }\n\n            if (c === '}') {\n                return [c, 'TK_END_BLOCK'];\n            }\n\n            if (c === ';') {\n                return [c, 'TK_SEMICOLON'];\n            }\n\n            if (c === '/') {\n                var comment = '';\n                // peek for comment /* ... */\n                if (input.charAt(parser_pos) === '*') {\n                    parser_pos += 1;\n                    block_comment_pattern.lastIndex = parser_pos;\n                    var comment_match = block_comment_pattern.exec(input);\n                    comment = '/*' + comment_match[0];\n                    parser_pos += comment_match[0].length;\n                    var directives = get_directives(comment);\n                    if (directives && directives['ignore'] === 'start') {\n                        directives_end_ignore_pattern.lastIndex = parser_pos;\n                        comment_match = directives_end_ignore_pattern.exec(input)\n                        comment += comment_match[0];\n                        parser_pos += comment_match[0].length;\n                    }\n                    comment = comment.replace(acorn.allLineBreaks, '\\n');\n                    return [comment, 'TK_BLOCK_COMMENT', directives];\n                }\n                // peek for comment // ...\n                if (input.charAt(parser_pos) === '/') {\n                    parser_pos += 1;\n                    comment_pattern.lastIndex = parser_pos;\n                    var comment_match = comment_pattern.exec(input);\n                    comment = '//' + comment_match[0];\n                    parser_pos += comment_match[0].length;\n                    return [comment, 'TK_COMMENT'];\n                }\n\n            }\n\n            var startXmlRegExp = /^<([-a-zA-Z:0-9_.]+|{.+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{.+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{.+?}))*\\s*(\\/?)\\s*>/\n\n            if (c === '`' || c === \"'\" || c === '\"' || // string\n                (\n                    (c === '/') || // regexp\n                    (opts.e4x && c === \"<\" && input.slice(parser_pos - 1).match(startXmlRegExp)) // xml\n                ) && ( // regex and xml can only appear in specific locations during parsing\n                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\n                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&\n                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||\n                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',\n                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'\n                    ]))\n                )) {\n\n                var sep = c,\n                    esc = false,\n                    has_char_escapes = false;\n\n                resulting_string = c;\n\n                if (sep === '/') {\n                    //\n                    // handle regexp\n                    //\n                    var in_char_class = false;\n                    while (parser_pos < input_length &&\n                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&\n                            !acorn.newline.test(input.charAt(parser_pos)))) {\n                        resulting_string += input.charAt(parser_pos);\n                        if (!esc) {\n                            esc = input.charAt(parser_pos) === '\\\\';\n                            if (input.charAt(parser_pos) === '[') {\n                                in_char_class = true;\n                            } else if (input.charAt(parser_pos) === ']') {\n                                in_char_class = false;\n                            }\n                        } else {\n                            esc = false;\n                        }\n                        parser_pos += 1;\n                    }\n                } else if (opts.e4x && sep === '<') {\n                    //\n                    // handle e4x xml literals\n                    //\n\n                    var xmlRegExp = /<(\\/?)([-a-zA-Z:0-9_.]+|{.+?}|!\\[CDATA\\[[\\s\\S]*?\\]\\])(\\s+{.+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|\"[^\"]*\"|{.+?}))*\\s*(\\/?)\\s*>/g;\n                    var xmlStr = input.slice(parser_pos - 1);\n                    var match = xmlRegExp.exec(xmlStr);\n                    if (match && match.index === 0) {\n                        var rootTag = match[2];\n                        var depth = 0;\n                        while (match) {\n                            var isEndTag = !! match[1];\n                            var tagName = match[2];\n                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\n                            if (tagName === rootTag && !isSingletonTag) {\n                                if (isEndTag) {\n                                    --depth;\n                                } else {\n                                    ++depth;\n                                }\n                            }\n                            if (depth <= 0) {\n                                break;\n                            }\n                            match = xmlRegExp.exec(xmlStr);\n                        }\n                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;\n                        xmlStr = xmlStr.slice(0, xmlLength);\n                        parser_pos += xmlLength - 1;\n                        xmlStr = xmlStr.replace(acorn.allLineBreaks, '\\n');\n                        return [xmlStr, \"TK_STRING\"];\n                    }\n                } else {\n                    //\n                    // handle string\n                    //\n                    var parse_string = function(delimiter, allow_unescaped_newlines, start_sub) {\n                        // Template strings can travers lines without escape characters.\n                        // Other strings cannot\n                        var current_char;\n                        while (parser_pos < input_length) {\n                            current_char = input.charAt(parser_pos);\n                            if (!(esc || (current_char !== delimiter &&\n                                (allow_unescaped_newlines || !acorn.newline.test(current_char))))) {\n                                break;\n                            }\n\n                            // Handle \\r\\n linebreaks after escapes or in template strings\n                            if ((esc || allow_unescaped_newlines) && acorn.newline.test(current_char)) {\n                                if (current_char === '\\r' && input.charAt(parser_pos + 1) === '\\n') {\n                                    parser_pos += 1;\n                                    current_char = input.charAt(parser_pos);\n                                }\n                                resulting_string += '\\n';\n                            } else {\n                                resulting_string += current_char;\n                            }\n                            if (esc) {\n                                if (current_char === 'x' || current_char === 'u') {\n                                    has_char_escapes = true;\n                                }\n                                esc = false;\n                            } else {\n                                esc = current_char === '\\\\';\n                            }\n\n                            parser_pos += 1;\n\n                            if (start_sub && resulting_string.indexOf(start_sub, resulting_string.length - start_sub.length) !== -1) {\n                                if (delimiter === '`') {\n                                    parse_string('}', allow_unescaped_newlines, '`')\n                                }  else {\n                                    parse_string('`', allow_unescaped_newlines, '${')\n                                }\n                            }\n                        }\n                    }\n                    if (sep === '`') {\n                        parse_string('`', true, '${')\n                    }  else {\n                        parse_string(sep)\n                    }\n                }\n\n                if (has_char_escapes && opts.unescape_strings) {\n                    resulting_string = unescape_string(resulting_string);\n                }\n\n                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {\n                    resulting_string += sep;\n                    parser_pos += 1;\n\n                    if (sep === '/') {\n                        // regexps may have modifiers /regexp/MOD , so fetch those, too\n                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {\n                            resulting_string += input.charAt(parser_pos);\n                            parser_pos += 1;\n                        }\n                    }\n                }\n                return [resulting_string, 'TK_STRING'];\n            }\n\n            if (c === '#') {\n\n                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {\n                    // shebang\n                    resulting_string = c;\n                    while (parser_pos < input_length && c !== '\\n') {\n                        c = input.charAt(parser_pos);\n                        resulting_string += c;\n                        parser_pos += 1;\n                    }\n                    return [trim(resulting_string) + '\\n', 'TK_UNKNOWN'];\n                }\n\n\n\n                // Spidermonkey-specific sharp variables for circular references\n                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\n                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\n                var sharp = '#';\n                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {\n                    do {\n                        c = input.charAt(parser_pos);\n                        sharp += c;\n                        parser_pos += 1;\n                    } while (parser_pos < input_length && c !== '#' && c !== '=');\n                    if (c === '#') {\n                        //\n                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\n                        sharp += '[]';\n                        parser_pos += 2;\n                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\n                        sharp += '{}';\n                        parser_pos += 2;\n                    }\n                    return [sharp, 'TK_WORD'];\n                }\n            }\n\n            if (c === '<' && (input.charAt(parser_pos) === '?' || input.charAt(parser_pos) === '%')) {\n                template_pattern.lastIndex = parser_pos - 1;\n                var template_match = template_pattern.exec(input);\n                if(template_match) {\n                    c = template_match[0];\n                    parser_pos += c.length - 1;\n                    c = c.replace(acorn.allLineBreaks, '\\n');\n                    return [c, 'TK_STRING'];\n                }\n            }\n\n            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\n                parser_pos += 3;\n                c = '<!--';\n                while (!acorn.newline.test(input.charAt(parser_pos)) && parser_pos < input_length) {\n                    c += input.charAt(parser_pos);\n                    parser_pos++;\n                }\n                in_html_comment = true;\n                return [c, 'TK_COMMENT'];\n            }\n\n            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\n                in_html_comment = false;\n                parser_pos += 2;\n                return ['-->', 'TK_COMMENT'];\n            }\n\n            if (c === '.') {\n                return [c, 'TK_DOT'];\n            }\n\n            if (in_array(c, punct)) {\n                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n                    if (parser_pos >= input_length) {\n                        break;\n                    }\n                }\n\n                if (c === ',') {\n                    return [c, 'TK_COMMA'];\n                } else if (c === '=') {\n                    return [c, 'TK_EQUALS'];\n                } else {\n                    return [c, 'TK_OPERATOR'];\n                }\n            }\n\n            return [c, 'TK_UNKNOWN'];\n        }\n\n\n        function unescape_string(s) {\n            var esc = false,\n                out = '',\n                pos = 0,\n                s_hex = '',\n                escaped = 0,\n                c;\n\n            while (esc || pos < s.length) {\n\n                c = s.charAt(pos);\n                pos++;\n\n                if (esc) {\n                    esc = false;\n                    if (c === 'x') {\n                        // simple hex-escape \\x24\n                        s_hex = s.substr(pos, 2);\n                        pos += 2;\n                    } else if (c === 'u') {\n                        // unicode-escape, \\u2134\n                        s_hex = s.substr(pos, 4);\n                        pos += 4;\n                    } else {\n                        // some common escape, e.g \\n\n                        out += '\\\\' + c;\n                        continue;\n                    }\n                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {\n                        // some weird escaping, bail out,\n                        // leaving whole string intact\n                        return s;\n                    }\n\n                    escaped = parseInt(s_hex, 16);\n\n                    if (escaped >= 0x00 && escaped < 0x20) {\n                        // leave 0x00...0x1f escaped\n                        if (c === 'x') {\n                            out += '\\\\x' + s_hex;\n                        } else {\n                            out += '\\\\u' + s_hex;\n                        }\n                        continue;\n                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n                        // single-quote, apostrophe, backslash - escape these\n                        out += '\\\\' + String.fromCharCode(escaped);\n                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {\n                        // we bail out on \\x7f..\\xff,\n                        // leaving whole string escaped,\n                        // as it's probably completely binary\n                        return s;\n                    } else {\n                        out += String.fromCharCode(escaped);\n                    }\n                } else if (c === '\\\\') {\n                    esc = true;\n                } else {\n                    out += c;\n                }\n            }\n            return out;\n        }\n\n    }\n\n\n    if (typeof define === \"function\" && define.amd) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        define([], function() {\n            return { js_beautify: js_beautify };\n        });\n    } else if (typeof exports !== \"undefined\") {\n        // Add support for CommonJS. Just put this file somewhere on your require.paths\n        // and you will be able to `var js_beautify = require(\"beautify\").js_beautify`.\n        exports.js_beautify = js_beautify;\n    } else if (typeof window !== \"undefined\") {\n        // If we're running a web page and don't have either of the above, add our one global\n        window.js_beautify = js_beautify;\n    } else if (typeof global !== \"undefined\") {\n        // If we don't even have window, try global.\n        global.js_beautify = js_beautify;\n    }\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-beautify/js/lib/beautify.js\n ** module id = 7\n ** module chunks = 1\n **/","var _ = require(\"underscore\");\n\nmodule.exports = require(\"infrastructure-appcontroller-ractive\").extend(\"AppController\", {\n  Layout: require(\"infrastructure.views.Layout\"),\n  config: \"app\",\n  /*\n\tResolved config can contain the following working options:\n\tcontainer: String // selector, where the app will initialize it's Layout view\n\tpushState: Boolean\n\n\n\n  */\n\n  routes: {\n    \"setContext\": \"setContext\",\n  },\n\n  contaxtParams: [\"screen\", \"tab\", \"context\", \"action\", \"param_1\", \"param_2\", \"param_3\", \"param_4\"],\n\n  setContext: function( screen_name, tab, context, action ){\n    this.reset( \"state\", _.chain(this.contaxtParams).zip(arguments).object().value() ); \n  },\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/controllers/AppController.js\n ** module id = 8\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./Builder.ractive.jade\"),\n  style:    require(\"./Builder.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Builder/Builder.js\n ** module id = 9\n ** module chunks = 1\n **/","var App = require(\"App\");\n\n// Prism highlighter themes and stuff can be downloaded from http://prismjs.com/download.html\n\nvar beautify = require('js-beautify').js_beautify;\n// beautify(tag.innerHTML, { indent_size: 2 });\n\nvar partials = App.bulk(require.context(\"./partials\", false),function(name, context, cb){ \n  cb(name.replace(/\\.ractive\\.(jade|html)$/, \"\").replace(/^i[\\d]{1,2}_/, \"\"));\n});\n\nmodule.exports = require(\"View\").extend({\n  template: require(\"./Docs.ractive.jade\"),\n  style:    require(\"./Docs.less\"),\n  data: {\n    items: Object.keys(partials)\n  },\n  partials: {\n    TabPartial: function(){\n      return partials[this.get(\"state.tab\")];\n    }\n  },\n\n  computed: {\n    previous: function(){\n      var items = this.get(\"items\");\n      var tab  = this.get(\"state.tab\");\n      return items[items.indexOf(tab) - 1];\n    },\n    next: function(){\n      var items = this.get(\"items\");\n      var tab   = this.get(\"state.tab\");\n      return items[items.indexOf(tab) + 1];\n    },\n  },\n\n  onrender: function(){\n    window.scrollTo(0, 0);\n\n    this.observe(\"state.tab\", function(val){\n      if(!val) return;\n      var codes = this.el.querySelectorAll(\"code\");\n      if(!codes) return;\n      for(var i=0; i< codes.length; i++){\n        if(codes[i].className.indexOf(\"javascript\") > -1){\n          codes[i].innerHTML = beautify(codes[i].innerHTML.replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\"), { indent_size: 2 });\n        }\n      }\n      Prism.highlightAll();\n      window.scrollTo(0, 0);\n    })\n  }\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/Docs.js\n ** module id = 10\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./HelloWorld.ractive.jade\"),\n  style:    require(\"./HelloWorld.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/HelloWorld/HelloWorld.js\n ** module id = 11\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./UnderConstruction.ractive.jade\"),\n  style:    require(\"./UnderConstruction.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/UnderConstruction/UnderConstruction.js\n ** module id = 12\n ** module chunks = 1\n **/","var _ = require(\"underscore\");\n\nvar with_constructor    = \"function @@(){return proto.constructor.apply(this, arguments)}\";\nvar without_constructor = \"function @@(){ return parent.apply(this, arguments); };\";\n\n// var extend = function(name, proto, statics){\n  \n//   var parent = this;\n//   if(typeof name === \"string\" && /^[a-z][a-z0-9]*$/i.test(name)){\n//     name = name;\n//   }\n//   else{\n//     statics = proto;\n//     proto = name;\n//     name = \"child\";\n//   }\n\n//   name = (parent.__className) || \"child\"+\"_\"+name;\n\n//   // The constructor function for the new subclass is either defined by you\n//   // (the \"constructor\" property in your `extend` definition), or defaulted\n//   // by us to simply call the parent's constructor.\n\n//   // if (protoProps && _.has(protoProps, 'constructor')) { //first call parent's constructor, then current\n//   //   eval(\"function \"+name+\"(){return protoProps.constructor.apply(this, arguments)}\");\n//   // } else {\n//   //   eval(\"function \"+name+\"(){ return parent.apply(this, arguments); };\");\n//   // }\n\n//   eval((proto && _.has(proto, 'constructor')?with_constructor:without_constructor).replace(\"@@\", name))\n//   var child = eval(name);\n\n//   // Add static properties to the constructor function, if supplied.\n//   _.extend(child, parent, statics);\n\n//   // Set the prototype chain to inherit from `parent`, without calling\n//   // `parent`'s constructor function.\n//   var Surrogate = function(){\n//     this.constructor = child; \n//   };\n\n//   Surrogate.prototype = parent.prototype;\n//   child.prototype = new Surrogate;\n//   child.__className = (statics || {}).__className || name;\n\n//   // Add prototype properties (instance properties) to the subclass,\n//   // if supplied.\n//   if (proto) _.extend(child.prototype, proto);\n\n//   // Set a convenience property in case the parent's prototype is needed\n//   // later.\n//   child.__super__ = parent.prototype;\n\n//   return eval(name);\n// };\n\nvar Class = function(){\n  if(this.initialize) this.initialize.apply(this, arguments);\n};\nClass.__className = \"Class\";\n// minified version will work faster\nClass.extend = function(name,proto,statics){var parent=this;\"string\"==typeof name&&/^[a-z][a-z0-9]*$/i.test(name)?name=name:(statics=proto,proto=name,name=\"child\"),name=parent.__className||\"child_\"+name,eval((proto&&_.has(proto,\"constructor\")?with_constructor:without_constructor).replace(\"@@\",name));var child=eval(name);_.extend(child,parent,statics);var Surrogate=function(){this.constructor=child};return Surrogate.prototype=parent.prototype,child.prototype=new Surrogate,child.__className=(statics||{}).__className||name,proto&&_.extend(child.prototype,proto),child.__super__=parent.prototype,eval(name)};\n\nmodule.exports = Class;\n\n\n\n\n// Original extend function in case evaluating class names is not good idea\n// var _ = require(\"underscore\");\n\n// var extend = function(protoProps, staticProps) {\n//   var parent = this;\n//   var child;\n\n//   // The constructor function for the new subclass is either defined by you\n//   // (the \"constructor\" property in your `extend` definition), or defaulted\n//   // by us to simply call the parent's constructor.\n//   if (protoProps && _.has(protoProps, 'constructor')) {\n//     child = protoProps.constructor;\n//   } else {\n//     child = function(){ return parent.apply(this, arguments); };\n//   }\n\n//   // Add static properties to the constructor function, if supplied.\n//   _.extend(child, parent, staticProps);\n\n//   // Set the prototype chain to inherit from `parent`, without calling\n//   // `parent`'s constructor function.\n//   var Surrogate = function(){ this.constructor = child; };\n//   Surrogate.prototype = parent.prototype;\n//   child.prototype = new Surrogate;\n\n//   // Add prototype properties (instance properties) to the subclass,\n//   // if supplied.\n//   if (protoProps) _.extend(child.prototype, protoProps);\n\n//   // Set a convenience property in case the parent's prototype is needed\n//   // later.\n//   child.__super__ = parent.prototype;\n\n//   return child;\n// };\n\n// var Class = function(){\n//   if(this.initialize) this.initialize.apply(this, arguments);\n// };\n// Class.prototype.extend = extend;\n\n// module.exports = Class;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure/lib/Class.js\n ** module id = 13\n ** module chunks = 1\n **/","var _ = require(\"underscore\");\nvar helpers = module.exports = {\n  \n  everyIs: function(iterator){ return function(val){ return _.isArray(val) && _.every(val, iterator);} },\n\n  isOneOf: function(){\n    var comparators = Array.prototype.slice.call(arguments);\n    return function(val){\n      return _.some(comparators, function(comparator){\n        return comparator(val);\n      });\n    }\n  },\n\n  deepExtend: function(target, source){\n    for(var key in source){\n      if(_.isObject(target[key]) && _.isObject(source[key])){\n        helpers.deepExtend(target[key], source[key]);\n      }\n      else { target[key] = source[key]; }\n    }\n  },\n\n  filterObject: function(obj, iterator){\n    var result = {};\n    for(key in obj)\n      !!iterator(key, obj[key]) && (result[key] = obj[key]);\n    return result;\n  },\n\n  //Warning !!! - changing passed object\n  cleanObject: function(obj){ for(key in obj) !obj[key] && (delete obj[key]); },\n\n  // Takes number n and returns function that can be executed n times\n  // when n becomes 0, will be executed callback m in context C with arguments a,b and c\n  counter: function(n,m,C,a,b,c){return function(){n--;n===0&&m.call(C||this,a,b,c)}},\n  \n  // Generates a chain of functions\n  chain: function(fns, context){\n    var self = this;\n    fns = fns.map(function(f){\n      if(typeof f !== \"function\") {\n        return function(){\n          var ctx = this;\n          var args = Array.prototype.slice.call(arguments);\n          var chain_cb = args.pop();\n          helpers.amap(f, function(ob_fn, amap_cb){\n            ob_fn.apply(ctx, args.concat([amap_cb]));\n          }, chain_cb);\n        };\n      }\n      else{\n        return f;\n      }\n    });\n\n    var ft = \"function\", sl = [].slice, em = \"callback not found!!\";\n    return function(X){var t,n=context||this,a=fns,r=-1,f=sl.call(arguments);if(t=f.pop(),typeof t!==ft&&(n=t,t=f.pop()),typeof t!==ft)throw new Error(em);var l=function(){var f=arguments[0];if(f)return t(f);if(!a[++r])return t.apply(n,arguments);try{a[r].apply(n,sl.call(arguments,1).concat([l]))}catch(f){t.call(n,f.message||f)}};l.finish=t,fns.length?(r++,f.push(l),fns[0].apply(n,f)):(f.unshift(null),t.apply(n,f))};\n    // return function(){\n    //   var cb,c=context||this,ch=fns,ptr=-1;\n    //   var a=sl.call(arguments);\n    //   cb = a.pop();\n    //   if(typeof cb!==ft) c=cb,cb=a.pop();\n    //   if(typeof cb!==ft) throw new Error(em);\n    //   var n=function(){\n    //     var e=arguments[0];\n    //     if(e) return cb(e);\n    //     if(!ch[++ptr]) return cb.apply(c, arguments);\n    //     try{ch[ptr].apply(c,sl.call(arguments,1).concat([n]));}\n    //     catch(e){cb.call(c,e.message || e);}\n    //   }\n    //   n.finish=cb;\n    //   if(fns.length){\n    //     ptr++;\n    //     a.push(n);\n    //     fns[0].apply(c,a);\n    //   }\n    //   else{\n    //     a.unshift(null);\n    //     cb.apply(c,a);\n    //   }\n    // };\n\n  },\n\n  amapCompose: function(obj, iterator){\n    return function(ob, itr, cb){\n      helpers.amap( ob||obj, itr||iterator, cb, this);\n    }\n  },\n\n  runFnsIterator: function(fn, cb){fn(cb);},\n  amap: function(r,n,t,a){a=a||this,n?Array.isArray(n)&&(n=this.chain(n)):n=this.runFnsIterator;var i,e;if(Array.isArray(r)?(e=r.length,i=new Array(r.length)):(i={},e=Object.keys(r).length,r.forEach=function(n){for(var t in r)\"forEach\"!==t&&n(r[t],t,r)}),0===e)return t(null,r);var f;r.forEach(function(r,c){setTimeout(function(){n.call(a,r,function(r,n){if(f!==!0){if(r)return f=!0,t(r);i[c]=n,e--,0===e&&t(null,i)}})},0)}),Array.isArray(r)||delete r.forEach},\n  // amap: function(arr, iterator, cb, ctx){\n  //   ctx = ctx || this;\n  //   if(!iterator) iterator = this.runFnsIterator;\n  //   else if(Array.isArray(iterator)) iterator = this.chain(iterator);\n  //   var results, counter;\n  //   if(!Array.isArray(arr)){\n  //     results = {};\n  //     counter = Object.keys(arr).length;\n  //     arr.forEach = function(itr){\n  //       for(var key in arr) {\n  //         if(key===\"forEach\") continue;\n  //         itr(arr[key], key, arr);\n  //       }\n  //     }\n  //   }\n  //   else{\n  //     counter = arr.length;\n  //     results = new Array(arr.length);\n  //   }\n  //   if(counter===0) return cb(null, arr);\n\n  //   var  error;\n  //   arr.forEach(function(el, idx, arr){\n  //     setTimeout(function(){\n  //       iterator.call(ctx, el, function(err, result){\n  //         if(error === true) return;\n  //         if(err){error = true; return cb(err);}\n  //         results[idx] = result;\n  //         counter--;\n  //         if(counter===0) {\n  //           cb(null, results);\n  //         }\n  //       });\n  //     }, 0);\n  //   });\n  //   if(!Array.isArray(arr)) delete arr.forEach;\n  // },\n\n  parseArgs: function(a){\n    var r    = { params: Array.prototype.call.slice(a), ctx: global};\n    var last = Array.prototype.call.slice(a, -2);\n    var l1   = last.pop();\n    var l2   = last.pop();\n    if(typeof l1 === \"function\"){\n      r.cb   = r.params.pop();\n      return r;\n    }\n    else if(typeof l2 === \"function\"){\n      r.ctx  = r.params.pop();\n      r.cb   = r.params.pop();\n      return r;\n    }\n    return r;\n  },\n\n  defaultize: function(base, target){\n    if(Array.isArray(target)) target.forEach(function(t){_.defaults(t, base)});\n    else{\n      for(var key in target){\n        _.defaults(target[key], base);\n      }\n    }\n    return target;\n  },\n\n  instantiate: function(objects, Prototype){\n    if(_.isArray(objects)){\n      return objects.map(function(object){\n        return new Prototype(object);\n      });\n    }\n    else if(_.isObject(objects)){\n      var result = {};\n      for(var key in objects){\n        result[key] = new Prototype(objects[key]);\n      }\n      return result;\n    }\n    else{\n      return new Prototype(objects);\n    }\n  },\n\n  traverse: function(obj, iterator, path){\n    path = path || [];\n    for(var key in obj){\n      (function(name, val){\n        if(_.isObject(val) && (typeof val !== \"function\")){\n          return helpers.traverse(val, iterator, path.concat([name]));\n        }\n        iterator(val, name, obj, path.concat([name]));\n      })(key, obj[key]);\n    }\n  },\n\n  resolve: function(target, path){\n    var parts = path.split(\".\"), parent = target, last_target = parts.pop();\n    for(var i = 0; i< parts.length; i++){\n      if(!parent.hasOwnProperty(parts[i]) && !parent.__proto__.hasOwnProperty(parts[i])){\n        return undefined;\n      }\n      parent = parent[parts[i]];\n    }\n    return parent[last_target];\n  },\n\n  patch: function(target, path, val){\n    if(typeof path === \"object\"){\n      for(var key in path) helpers.patch(target, key, path[key]);\n      return;\n    }\n    var parts = path.split(\".\"), parent = target, last = parts.pop();\n    for(var i = 0; i< parts.length; i++){\n      if(!parent.hasOwnProperty(parts[i]) && !parent.__proto__.hasOwnProperty(parts[i])) parent[parts[i]] = {};\n      parent = parent[parts[i]];\n    }\n    var real_target = (!parent[last] && !parent.__proto__[last] ? parent : ( !parent.__proto__[last] ? parent : parent.__proto__ ) );\n    real_target[last] = val;\n  }\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure/lib/helpers.js\n ** module id = 14\n ** module chunks = 1\n **/","var map = {\n\t\"./AppController\": 8,\n\t\"./AppController.js\": 8\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 15;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/controllers ^\\.\\/.*$\n ** module id = 15\n ** module chunks = 1\n **/","var App = require(\"App\");  //{  }\n\nrequire(\"prism\");\nrequire(\"prism.css\");\n\nApp.Controllers = App.bulk(require.context(\"./controllers\"));\n\nApp.config({\n  debug: true,\n  app: {\n    // container: \"#main-container\",\n    pushState: false\n  }\n});\n\n\n// console.log(App.Rainbow.color(\"var App = require('App');\", \"javascript\", function(code){\n//   console.log(arguments)\n// }));\n\n\n\nvar app = require(\"app\");\n\napp.init({\n  App:          App,\n  config:       require(\"config\"),\n  settings:     window.settings || {},\n  routes:       require(\"./routes.json\"),\n  data:         {}\n}, function(err){\n  if(err) throw err;\n  console.log(\"app initialized\");\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/infrastructure.index.js\n ** module id = 16\n ** module chunks = 1\n **/","var App = require(\"App\");\n\nmodule.exports = require(\"View\").extend({\n\n  template: require(\"./Layout.ractive.jade\"),\n  style:    require(\"./Layout.less\"),\n  \n  components: App.bulk(\n    require.context(\"./sections\", true, /\\.\\/[^/]+\\/[^\\/]+\\.js$/),\n    function(name, context, cb){ cb(name.split(\"/\").shift()); }),\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/Layout.js\n ** module id = 17\n ** module chunks = 1\n **/","var map = {\n\t\"./Builder/Builder.js\": 9,\n\t\"./Docs/Docs.js\": 10,\n\t\"./Footer/Footer.js\": 20,\n\t\"./Header/Header.js\": 21,\n\t\"./HelloWorld/HelloWorld.js\": 11,\n\t\"./MainContainer/MainContainer.js\": 22,\n\t\"./TopMenu/TomMenu.js\": 23,\n\t\"./UnderConstruction/UnderConstruction.js\": 12\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 18;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections \\.\\/[^\\/]+\\/[^\\/]+\\.js$\n ** module id = 18\n ** module chunks = 1\n **/","var map = {\n\t\"./i1_SetupApplication.ractive.jade\": 51,\n\t\"./i2_TheLogger.ractive.jade\": 52,\n\t\"./i3_Configuration.ractive.jade\": 53,\n\t\"./i4_ProcessMode.ractive.jade\": 54,\n\t\"./i5_Structures.ractive.jade\": 55,\n\t\"./i6_Tests.ractive.jade\": 56\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 19;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials nonrecursive ^\\.\\/.*$\n ** module id = 19\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./Footer.ractive.jade\"),\n  style:    require(\"./Footer.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Footer/Footer.js\n ** module id = 20\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./Header.ractive.jade\"),\n  style:    require(\"./Header.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Header/Header.js\n ** module id = 21\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./MainContainer.ractive.jade\"),\n  style:    require(\"./MainContainer.less\"),\n  components: {\n    Docs:              require(\"../Docs/Docs.js\"       ),\n    Builder:           require(\"../Builder/Builder.js\" ),\n    UnderConstruction: require(\"../UnderConstruction/UnderConstruction.js\" ),\n    HelloWorld:        require(\"../HelloWorld/HelloWorld.js\" ),\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/MainContainer/MainContainer.js\n ** module id = 22\n ** module chunks = 1\n **/","module.exports = require(\"View\").extend({\n  template: require(\"./TopMenu.ractive.jade\"),\n  style:    require(\"./TopMenu.less\"),\n  components: {\n\n  },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/TopMenu/TomMenu.js\n ** module id = 23\n ** module chunks = 1\n **/","/* http://prismjs.com/download.html?themes=prism-okaidia&languages=markup+css+clike+javascript+bash&plugins=line-highlight+line-numbers */\nvar _self=\"undefined\"!=typeof window?window:\"undefined\"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i,t=_self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):\"Array\"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/\\u00a0/g,\" \")},type:function(e){return Object.prototype.toString.call(e).match(/\\[object (\\w+)\\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case\"Object\":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case\"Array\":return e.map&&e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==n)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),\"Object\"===t.util.type(e[r])?t.languages.DFS(e[r],n):\"Array\"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},plugins:{},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'),l=0;a=r[l++];)t.highlightElement(a,e===!0,n)},highlightElement:function(n,a,r){for(var l,i,o=n;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,\"\"])[1],i=t.languages[l]),n.className=n.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+l,o=n.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,\"\").replace(/\\s+/g,\" \")+\" language-\"+l);var s=n.textContent,u={element:n,language:l,grammar:i,code:s};if(!s||!i)return t.hooks.run(\"complete\",u),void 0;if(t.hooks.run(\"before-highlight\",u),a&&_self.Worker){var g=new Worker(t.filename);g.onmessage=function(e){u.highlightedCode=e.data,t.hooks.run(\"before-insert\",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),t.hooks.run(\"after-highlight\",u),t.hooks.run(\"complete\",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=t.highlight(u.code,u.grammar,u.language),t.hooks.run(\"before-insert\",u),u.element.innerHTML=u.highlightedCode,r&&r.call(n),t.hooks.run(\"after-highlight\",u),t.hooks.run(\"complete\",u)},highlight:function(e,a,r){var l=t.tokenize(e,a);return n.stringify(t.util.encode(l),r)},tokenize:function(e,n){var a=t.Token,r=[e],l=n.rest;if(l){for(var i in l)n[i]=l[i];delete n.rest}e:for(var i in n)if(n.hasOwnProperty(i)&&n[i]){var o=n[i];o=\"Array\"===t.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),P=[p,1];b&&P.push(b);var A=new a(i,g?t.tokenize(m,g):m,h);P.push(A),w&&P.push(w),Array.prototype.splice.apply(r,P)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if(\"string\"==typeof e)return e;if(\"Array\"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join(\"\");var l={type:e.type,content:n.stringify(e.content,a,r),tag:\"span\",classes:[\"token\",e.type],attributes:{},language:a,parent:r};if(\"comment\"==l.type&&(l.attributes.spellcheck=\"true\"),e.alias){var i=\"Array\"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}t.hooks.run(\"wrap\",l);var o=\"\";for(var s in l.attributes)o+=(o?\" \":\"\")+s+'=\"'+(l.attributes[s]||\"\")+'\"';return\"<\"+l.tag+' class=\"'+l.classes.join(\" \")+'\" '+o+\">\"+l.content+\"</\"+l.tag+\">\"},!_self.document)return _self.addEventListener?(_self.addEventListener(\"message\",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code,l=n.immediateClose;_self.postMessage(t.highlight(r,t.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.getElementsByTagName(\"script\");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute(\"data-manual\")&&document.addEventListener(\"DOMContentLoaded\",t.highlightAll)),_self.Prism}();\"undefined\"!=typeof module&&module.exports&&(module.exports=Prism),\"undefined\"!=typeof global&&(global.Prism=Prism);\nPrism.languages.markup={comment:/<!--[\\w\\W]*?-->/,prolog:/<\\?[\\w\\W]+?\\?>/,doctype:/<!DOCTYPE[\\w\\W]+?>/,cdata:/<!\\[CDATA\\[[\\w\\W]*?]]>/i,tag:{pattern:/<\\/?(?!\\d)[^\\s>\\/=.$<]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\\\1|\\\\?(?!\\1)[\\w\\W])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i,inside:{tag:{pattern:/^<\\/?[^\\s>\\/]+/i,inside:{punctuation:/^<\\/?/,namespace:/^[^\\s>\\/:]+:/}},\"attr-value\":{pattern:/=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/i,inside:{punctuation:/[=>\"']/}},punctuation:/\\/?>/,\"attr-name\":{pattern:/[^\\s>\\/]+/,inside:{namespace:/^[^\\s>\\/:]+:/}}}},entity:/&#?[\\da-z]{1,8};/i},Prism.hooks.add(\"wrap\",function(a){\"entity\"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,\"&\"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;\nPrism.languages.css={comment:/\\/\\*[\\w\\W]*?\\*\\//,atrule:{pattern:/@[\\w-]+?.*?(;|(?=\\s*\\{))/i,inside:{rule:/@[\\w-]+/}},url:/url\\((?:([\"'])(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1|.*?)\\)/i,selector:/[^\\{\\}\\s][^\\{\\};]*?(?=\\s*\\{)/,string:/(\"|')(\\\\(?:\\r\\n|[\\w\\W])|(?!\\1)[^\\\\\\r\\n])*\\1/,property:/(\\b|\\B)[\\w-]+(?=\\s*:)/i,important:/\\B!important\\b/i,\"function\":/[-a-z0-9]+(?=\\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.util.clone(Prism.languages.css),Prism.languages.markup&&(Prism.languages.insertBefore(\"markup\",\"tag\",{style:{pattern:/(<style[\\w\\W]*?>)[\\w\\W]*?(?=<\\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:\"language-css\"}}),Prism.languages.insertBefore(\"inside\",\"attr-value\",{\"style-attr\":{pattern:/\\s*style=(\"|').*?\\1/i,inside:{\"attr-name\":{pattern:/^\\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\\s*=\\s*['\"]|['\"]\\s*$/,\"attr-value\":{pattern:/.+/i,inside:Prism.languages.css}},alias:\"language-css\"}},Prism.languages.markup.tag));\nPrism.languages.clike={comment:[{pattern:/(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//,lookbehind:!0},{pattern:/(^|[^\\\\:])\\/\\/.*/,lookbehind:!0}],string:/([\"'])(\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\"class-name\":{pattern:/((?:\\b(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/i,lookbehind:!0,inside:{punctuation:/(\\.|\\\\)/}},keyword:/\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/,\"boolean\":/\\b(true|false)\\b/,\"function\":/[a-z0-9_]+(?=\\()/i,number:/\\b-?(?:0x[\\da-f]+|\\d*\\.?\\d+(?:e[+-]?\\d+)?)\\b/i,operator:/--?|\\+\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\|\\|?|\\?|\\*|\\/|~|\\^|%/,punctuation:/[{}[\\];(),.:]/};\nPrism.languages.javascript=Prism.languages.extend(\"clike\",{keyword:/\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\b/,number:/\\b-?(0x[\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\d*\\.?\\d+([Ee][+-]?\\d+)?|NaN|Infinity)\\b/,\"function\":/[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*(?=\\()/i}),Prism.languages.insertBefore(\"javascript\",\"keyword\",{regex:{pattern:/(^|[^\\/])\\/(?!\\/)(\\[.+?]|\\\\.|[^\\/\\\\\\r\\n])+\\/[gimyu]{0,5}(?=\\s*($|[\\r\\n,.;})]))/,lookbehind:!0}}),Prism.languages.insertBefore(\"javascript\",\"class-name\",{\"template-string\":{pattern:/`(?:\\\\`|\\\\?[^`])*`/,inside:{interpolation:{pattern:/\\$\\{[^}]+\\}/,inside:{\"interpolation-punctuation\":{pattern:/^\\$\\{|\\}$/,alias:\"punctuation\"},rest:Prism.languages.javascript}},string:/[\\s\\S]+/}}}),Prism.languages.markup&&Prism.languages.insertBefore(\"markup\",\"tag\",{script:{pattern:/(<script[\\w\\W]*?>)[\\w\\W]*?(?=<\\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:\"language-javascript\"}}),Prism.languages.js=Prism.languages.javascript;\n!function(e){var t={variable:[{pattern:/\\$?\\(\\([\\w\\W]+?\\)\\)/,inside:{variable:[{pattern:/(^\\$\\(\\([\\w\\W]+)\\)\\)/,lookbehind:!0},/^\\$\\(\\(/],number:/\\b-?(?:0x[\\dA-Fa-f]+|\\d*\\.?\\d+(?:[Ee]-?\\d+)?)\\b/,operator:/--?|-=|\\+\\+?|\\+=|!=?|~|\\*\\*?|\\*=|\\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\\^=?|\\|\\|?|\\|=|\\?|:/,punctuation:/\\(\\(?|\\)\\)?|,|;/}},{pattern:/\\$\\([^)]+\\)|`[^`]+`/,inside:{variable:/^\\$\\(|^`|\\)$|`$/}},/\\$(?:[a-z0-9_#\\?\\*!@]+|\\{[^}]+\\})/i]};e.languages.bash={shebang:{pattern:/^#!\\s*\\/bin\\/bash|^#!\\s*\\/bin\\/sh/,alias:\"important\"},comment:{pattern:/(^|[^\"{\\\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\\s*)(?:\"|')?(\\w+?)(?:\"|')?\\s*\\r?\\n(?:[\\s\\S])*?\\r?\\n\\2/g,lookbehind:!0,inside:t},{pattern:/(\"|')(?:\\\\?[\\s\\S])*?\\1/g,inside:t}],variable:t.variable,\"function\":{pattern:/(^|\\s|;|\\||&)(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|\\s|;|\\||&)/,lookbehind:!0},keyword:{pattern:/(^|\\s|;|\\||&)(?:let|:|\\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|\\s|;|\\||&)/,lookbehind:!0},\"boolean\":{pattern:/(^|\\s|;|\\||&)(?:true|false)(?=$|\\s|;|\\||&)/,lookbehind:!0},operator:/&&?|\\|\\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];]/};var a=t.variable[1].inside;a[\"function\"]=e.languages.bash[\"function\"],a.keyword=e.languages.bash.keyword,a.boolean=e.languages.bash.boolean,a.operator=e.languages.bash.operator,a.punctuation=e.languages.bash.punctuation}(Prism);\n!function(){function e(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function t(e,t){return t=\" \"+t+\" \",(\" \"+e.className+\" \").replace(/[\\n\\t]/g,\" \").indexOf(t)>-1}function n(e,n,i){for(var o,a=n.replace(/\\s+/g,\"\").split(\",\"),l=+e.getAttribute(\"data-line-offset\")||0,d=r()?parseInt:parseFloat,c=d(getComputedStyle(e).lineHeight),s=0;o=a[s++];){o=o.split(\"-\");var u=+o[0],m=+o[1]||u,h=document.createElement(\"div\");h.textContent=Array(m-u+2).join(\" \\n\"),h.className=(i||\"\")+\" line-highlight\",t(e,\"line-numbers\")||(h.setAttribute(\"data-start\",u),m>u&&h.setAttribute(\"data-end\",m)),h.style.top=(u-l-1)*c+\"px\",t(e,\"line-numbers\")?e.appendChild(h):(e.querySelector(\"code\")||e).appendChild(h)}}function i(){var t=location.hash.slice(1);e(\".temporary.line-highlight\").forEach(function(e){e.parentNode.removeChild(e)});var i=(t.match(/\\.([\\d,-]+)$/)||[,\"\"])[1];if(i&&!document.getElementById(t)){var r=t.slice(0,t.lastIndexOf(\".\")),o=document.getElementById(r);o&&(o.hasAttribute(\"data-line\")||o.setAttribute(\"data-line\",\"\"),n(o,i,\"temporary \"),document.querySelector(\".temporary.line-highlight\").scrollIntoView())}}if(\"undefined\"!=typeof self&&self.Prism&&self.document&&document.querySelector){var r=function(){var e;return function(){if(\"undefined\"==typeof e){var t=document.createElement(\"div\");t.style.fontSize=\"13px\",t.style.lineHeight=\"1.5\",t.style.padding=0,t.style.border=0,t.innerHTML=\"&nbsp;<br />&nbsp;\",document.body.appendChild(t),e=38===t.offsetHeight,document.body.removeChild(t)}return e}}(),o=0;Prism.hooks.add(\"complete\",function(t){var r=t.element.parentNode,a=r&&r.getAttribute(\"data-line\");r&&a&&/pre/i.test(r.nodeName)&&(clearTimeout(o),e(\".line-highlight\",r).forEach(function(e){e.parentNode.removeChild(e)}),n(r,a),o=setTimeout(i,1))}),window.addEventListener&&window.addEventListener(\"hashchange\",i)}}();\n!function(){\"undefined\"!=typeof self&&self.Prism&&self.document&&Prism.hooks.add(\"complete\",function(e){if(e.code){var t=e.element.parentNode,s=/\\s*\\bline-numbers\\b\\s*/;if(t&&/pre/i.test(t.nodeName)&&(s.test(t.className)||s.test(e.element.className))&&!e.element.querySelector(\".line-numbers-rows\")){s.test(e.element.className)&&(e.element.className=e.element.className.replace(s,\"\")),s.test(t.className)||(t.className+=\" line-numbers\");var n,a=e.code.match(/\\n(?!$)/g),l=a?a.length+1:1,m=new Array(l+1);m=m.join(\"<span></span>\"),n=document.createElement(\"span\"),n.className=\"line-numbers-rows\",n.innerHTML=m,t.hasAttribute(\"data-start\")&&(t.style.counterReset=\"linenumber \"+(parseInt(t.getAttribute(\"data-start\"),10)-1)),e.element.appendChild(n)}}})}();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/web_modules/prism.js\n ** module id = 24\n ** module chunks = 1\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/web_modules/prism.css\n ** module id = 25\n ** module chunks = 1\n **/","/*** IMPORTS FROM imports-loader ***/\nvar define = false;\nvar _ = require('underscore');\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\tglobal.Ractive.adaptors.Backbone = factory()\n}(this, function () { 'use strict';\n\n\tvar lockProperty = \"_ractiveAdaptorsBackboneLock\";\n\n\tfunction acquireLock(key) {\n\t\tkey[lockProperty] = (key[lockProperty] || 0) + 1;\n\t\treturn function release() {\n\t\t\tkey[lockProperty] -= 1;\n\t\t\tif (!key[lockProperty]) {\n\t\t\t\tdelete key[lockProperty];\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction isLocked(key) {\n\t\treturn !!key[lockProperty];\n\t}\n\n\tvar adaptor = {\n\t\t// self-init, if being used as a <script> tag\n\t\tBackbone: typeof window !== \"undefined\" && window.Backbone || null,\n\n\t\tfilter: function filter(object) {\n\t\t\tif (!adaptor.Backbone) {\n\t\t\t\tthrow new Error(\"Could not find Backbone. You must do `adaptor.Backbone = Backbone` - see https://github.com/ractivejs/ractive-adaptors-backbone#installation for more information\");\n\t\t\t}\n\t\t\treturn object instanceof adaptor.Backbone.Model || object instanceof adaptor.Backbone.Collection;\n\t\t},\n\t\twrap: function wrap(ractive, object, keypath, prefix) {\n\t\t\tif (object instanceof adaptor.Backbone.Model) {\n\t\t\t\treturn new BackboneModelWrapper(ractive, object, keypath, prefix);\n\t\t\t}\n\n\t\t\treturn new BackboneCollectionWrapper(ractive, object, keypath, prefix);\n\t\t}\n\t};\n\n\tfunction BackboneModelWrapper(ractive, model, keypath, prefix) {\n\t\tthis.value = model;\n\n\t\tmodel.on(\"change\", this.modelChangeHandler = function () {\n\t\t\tvar release = acquireLock(model);\n\t\t\tractive.set(prefix(model.changed));\n\t\t\trelease();\n\t\t});\n\t}\n\n\tBackboneModelWrapper.prototype = {\n\t\tteardown: function teardown() {\n\t\t\tthis.value.off(\"change\", this.modelChangeHandler);\n\t\t},\n\t\tget: function get() {\n\t\t\treturn this.value.toJSON();\n\t\t},\n\t\tset: function set(keypath, value) {\n\t\t\t// Only set if the model didn't originate the change itself, and\n\t\t\t// only if it's an immediate child property\n\t\t\tif (!isLocked(this.value) && keypath.indexOf(\".\") === -1) {\n\t\t\t\tthis.value.set(keypath, value);\n\t\t\t}\n\t\t},\n\t\treset: function reset(object) {\n\t\t\t// If the new object is a Backbone model, assume this one is\n\t\t\t// being retired. Ditto if it's not a model at all\n\t\t\tif (object instanceof adaptor.Backbone.Model || !(object instanceof Object)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Otherwise if this is a POJO, reset the model\n\t\t\t//Backbone 1.1.2 no longer has reset and just uses set\n\t\t\tthis.value.set(object);\n\t\t}\n\t};\n\n\tfunction BackboneCollectionWrapper(ractive, collection, keypath) {\n\t\tthis.value = collection;\n\n\t\tcollection.on(\"add remove reset sort\", this.changeHandler = function () {\n\t\t\t// TODO smart merge. It should be possible, if awkward, to trigger smart\n\t\t\t// updates instead of a blunderbuss .set() approach\n\t\t\tvar release = acquireLock(collection);\n\t\t\tractive.set(keypath, collection.models);\n\t\t\trelease();\n\t\t});\n\t}\n\n\tBackboneCollectionWrapper.prototype = {\n\t\tteardown: function teardown() {\n\t\t\tthis.value.off(\"add remove reset sort\", this.changeHandler);\n\t\t},\n\t\tget: function get() {\n\t\t\treturn this.value.models;\n\t\t},\n\t\treset: function reset(models) {\n\t\t\tif (isLocked(this.value)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If the new object is a Backbone collection, assume this one is\n\t\t\t// being retired. Ditto if it's not a collection at all\n\t\t\tif (models instanceof adaptor.Backbone.Collection || Object.prototype.toString.call(models) !== \"[object Array]\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Otherwise if this is a plain array, reset the collection\n\t\t\tthis.value.reset(models);\n\t\t}\n\t};\n\n\tvar ractive_adaptors_backbone = adaptor;\n\n\treturn ractive_adaptors_backbone;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ractive-adaptors-backbone/dist/ractive-adaptors-backbone.js\n ** module id = 36\n ** module chunks = 1\n **/","// Backbone router needs jQuery to select 'window' and to attach 2 events to it\n// Creating simple mockup\n\nvar Backbone               = require(\"backbone\");\nvar Class                  = require(\"infrastructure/lib/Class\");\n\nif(!Backbone.$){\n  var jQueryMockup = {\n    on: function(event, handler){\n      this.el.addEventListener(event, handler);\n      return jQueryMockup;\n    },\n    off: function(event, handler){\n      this.el.removeEventListener(event, handler);\n      return jQueryMockup;\n    }\n  };\n\n  Backbone.$ = function(el){\n    jQueryMockup.el = el;\n    return jQueryMockup;\n  }  \n}\n\nfunction getLink(elem){\n  if(elem.nodeName === \"A\") return elem;\n  else if(!elem.parentNode) return null;\n  else return getLink(elem.parentNode);\n}\n\nfunction getHref(elem, rootPath){\n  if(!elem || !elem.href) return false;\n  var href = elem.getAttribute(\"href\");\n  if( href.indexOf( \"/\" ) === 0 ){\n    if( href.indexOf(rootPath) === 0 ) return href;\n    else return false;\n  }\n  else if( href.indexOf( \"javascript:\" ) === -1 ) return rootPath + \"/\" + href;\n  return false;\n}\n\nvar BaseRouter = Backbone.Router.extend({\n  \n  initialize: function(routes, options){\n\n    this.routes = routes;\n    this.options = options || {};\n    var pushState = this.options.pushState;\n\n    var router  = this;\n    var rootPath = document.getElementsByTagName(\"base\")[0].href.replace(window.location.origin, \"\");\n    this.rootPath = rootPath;\n    if(pushState){\n      document.body.addEventListener(\"click\", function(e){\n        var href = getHref(getLink(e.target), rootPath);\n        if(href) {\n          e.preventDefault();\n          router.navigate(href.replace(/^\\//, \"\"), true);\n        }\n      });\n    }\n    else{\n      document.body.addEventListener(\"click\", function(e){\n        var href = getHref(getLink(e.target), rootPath);\n        if(href) {\n          if(href.indexOf(rootPath) === 0) href = href.replace(rootPath, \"\").replace(/^\\//, \"\"); // strip rootPath from href\n          e.preventDefault();\n          router.navigate(href, true);\n        }\n      });\n    }\n  },\n\n  startHistory: function(){\n    Backbone.history.start({pushState: this.options.pushState});\n  },\n\n  back: function(n){\n    Backbone.history.back(n || -1);\n  },\n\n  bindRoutes: function(){\n    var rootPath = this.rootPath;\n    var rootPrefix;\n    if(this.options.pushState){\n      rootPrefix = rootPath.replace(/^\\//, \"\");\n    }\n    else rootPrefix = \"\";\n\n    for(var routePath in this.routes){\n      var routeName = this.routes[routePath];\n      if(Array.isArray(routeName)){\n        for(var i=0;i<routeName.length;i++){\n          this.route((rootPrefix+routePath).replace(/^\\/+/,\"\").replace(/\\/+$/,\"\").replace(/\\/+/,\"/\"), routeName[i]);\n        }\n      }\n      else{\n        this.route((rootPrefix+routePath).replace(/^\\/+/,\"\").replace(/\\/+$/,\"\").replace(/\\/+/,\"/\"), routeName);\n      }\n    }\n  }\n\n});\n\nBaseRouter.__className = \"Router\";\nBaseRouter.extend      = Class.extend;\nmodule.exports         = BaseRouter;\n\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-appcontroller-ractive/Router.js\n ** module id = 37\n ** module chunks = 1\n **/","var _            = require(\"underscore\");\nvar helpers      = require(\"infrastructure/lib/helpers\"); \nvar Controller   = require(\"infrastructure/lib/client/Controller\");\nvar Router       = require(\"./Router\");\n\n/*\n  // Every controller can:\n  {\n\n    data: {...},  // attach data to main data namespace\n    \n    routes: {\n      route_name: \"method\" or [\"method\", \"method_2\"],\n    },\n\n    observe: {\n      dataPath: \"method\" or [\"method\", \"method_2\"],\n    },\n\n    events: {\n      event_name: \"method\" or [\"method\", \"method_2\"],\n    },\n\n    config: \"config.path\" or { ... }\n\n  }\n*/\n\nmodule.exports = Controller.extend(\"BaseRactiveAppController\", {\n\n  init: function(options, cb){\n    var self = this;\n    if(!document.body){\n      window.onload = function(){\n        self.init(options, cb);\n      }\n      return;\n    }\n    var app_config = {};\n    if(this.config && typeof this.config === \"string\") app_config = helpers.resolve(options.config, this.config);\n\n    this.options  = options;\n    this.config   = options.config;\n    this.settings = options.settings;\n\n    // this.setupRouter(options);\n\n    helpers.chain([\n\n      function(cb){\n        if(options.routes){\n          this.setupRouter(options.routes, app_config);\n          cb();\n        }\n        else cb();\n      },\n\n      function(cb){\n        if(this.Layout){\n          var container = app_config.container;\n          var element;\n          if(!container) element = document.body;\n          else           element = document.querySelector(container);\n          var self = this;\n          this.layout = new (this.Layout)({\n            data: options.data,\n            el:   element,\n            onrender: function(){ self.layout = this; cb(); }\n          });\n\n        }\n        else cb();  \n      },\n\n      function(cb){ this.setupControllers(cb); },\n\n      function(cb){\n        if(options.routes){\n          this.router.bindRoutes(this.routes);\n          this.router.startHistory(app_config.pushState);          \n        }\n        this.trigger(\"ready\");\n        cb();\n      }\n\n    ])(cb, this);\n\n  },\n\n  setupRouter: function(routes, app_config){\n    this.router = new Router(routes, app_config);\n  },\n\n  setupControllers: function(cb){\n    var self       = this;\n    var App        = this.options.App;\n    var observers  = [];\n    var data       = this.options.data;\n    var config     = this.config;\n\n    this.routes && this.bindRoutes(this);\n\n    if(this.data) _.extend(data, this.data );\n\n    var controllerNames = _.without(_.keys(App.Controllers), \"AppController\");\n    controllerNames = _.sortBy(controllerNames, function(controllerName){\n      return typeof App.Controllers[controllerName].prototype.initOrder === \"number\"\n        ? App.Controllers[controllerName].prototype.initOrder\n        : controllerNames.length;\n    });\n    var initChain = controllerNames.map(function(controllerName){\n      var controllerPrototype = App.Controllers[controllerName];\n\n      if(controllerPrototype.prototype.config){\n        if(_.isString(controllerPrototype.prototype.config)){\n          controllerPrototype.prototype.config = helpers.resolve(config, controllerPrototype.prototype.config);\n        }\n      }\n\n      if(controllerPrototype.prototype.data) self.set(controllerPrototype.prototype.data );\n      var controller = self[controllerName] = new controllerPrototype();\n      controller.routes && controller.bindRoutes(self);\n      controller.app = self;\n      if(controller.observe && self.bindObserver){\n        observers.push(controller);\n      }\n      return controller;\n    }).map(function(controller){\n      if(!controller.init || controller.init.length!=2) return function(cb){\n        controller.init.call(controller, self.options);\n        cb();\n      }\n      return function(cb){\n        controller.init.call(controller, self.options, cb );\n      }\n    });\n\n    helpers.chain(initChain)(function(err){\n      if(err) return cb(err);\n      if(observers.length > 0){\n        observers.forEach(function(observer){\n          self.bindObserver(observer);\n        });\n      }\n      cb();\n    });\n  },\n\n  bindObserver: function(observer){\n    for(var key in observer.observe){\n      if(typeof observer[observer.observe[key]] === \"function\"){\n        this.observe( key, observer[observer.observe[key]].bind(observer) );\n      }\n    }\n  },\n\n  get:          function(){ return   this.layout.get          .apply(this.layout, arguments);              },\n  fetch:        function(){ return   this.layout.fetch        .apply(this.layout, arguments);              },\n  set:          function(){          this.layout.set          .apply(this.layout, arguments); return this; },\n  observe:      function(){          this.layout.observe      .apply(this.layout, arguments); return this; },\n  toggle:       function(){          this.layout.toggle       .apply(this.layout, arguments); return this; },\n  radioToggle:  function(){          this.layout.radioToggle  .apply(this.layout, arguments); return this; },\n  reset:        function(path, val){ this.layout.set(path, null); this.layout.set(path, val);              },\n  navigate:     function(path){      this.router.navigate(path.replace(/^\\//, \"\"), true ) },\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-appcontroller-ractive/index.js\n ** module id = 38\n ** module chunks = 1\n **/","var _          = require(\"underscore\");\nvar Ractive    = require(\"ractive\" );\n\nvar config     = require(\"config\");\nRactive.DEBUG  = config.debug;\n\nmodule.exports = Ractive.extend({\n\n  data:{\n    \n    condition: function(condition, val_1, vl_2){\n      return condition ? val_1 : (vl_2 || null);\n    },\n\n    resolveComponent: function(name, properties){\n      \n      if(this.partials[name]) return name;\n\n      var component, partial, components = this.__proto__.constructor.components;\n      try{\n        if(!components[name]) throw new Error(\"Component not found\");\n        partial   = { \"v\":3, \"t\": [{ \"t\":7, \"e\": name } ] };\n        this.partials[name]   = partial;\n        if(properties) this.bindComponentVars(partial, properties );\n      }\n      catch(err){\n        this.partials[name] = {\"v\":3,\"t\":[{\"t\":7,\"e\":\"p\",\"a\":{\"class\":\"alert alert-danger\"},\"f\":[\"Error: Component '\"+name+\"'' can't be resolved\"]}]};\n      }\n      return name;\n    }\n\n  },\n\n  oninit: function() {\n    if(this.initialize) { this.initialize(); }\n  },\n\n  bindComponentVars: function(partial, properties){\n    partial.t[0].a = _.mapObject(properties, function(val){ return [ { \"t\":2, \"r\": val } ]; });\n  },\n\n  toggle: function(path){\n    var paths = Array.prototype.slice.call(arguments);\n    for(var i=0;i<paths.length;i++){\n      this.set(paths[i], !this.get(paths[i]));\n    }\n  },\n\n  fetch: function(obj){\n    var result = {};\n    for(var key in obj) {\n      var target = obj[key];\n      if(target.indexOf(\"*\")){\n        var parts = target.split(/[.\\[]\\*[.\\]]/);\n        var targetObj = this.get(parts[0]);\n        if(!target[1]){\n          result[key] = targetObj;\n        }\n        else if(_.isArray(targetObj)){\n          result[key] = new Array(targetObj.length);\n          for(var i=0;i<targetObj.length;i++){\n            result[key][i] = this.get(target.replace(\"*\", i));\n          }\n        }\n        else if(_.isObject(targetObj)){\n          result[key] = {};\n          for(var targetKey in targetObj){\n            result[key][targetKey] = this.get(target.replace(\"*\", targetKey));\n          }\n        }\n        else{\n          result[key] = targetObj;\n        }\n      }\n      else{\n        result[key] = this.get(target);\n      }\n    }\n    return result;\n  },\n\n  radioToggle: function(path, exclusive){\n    var parts      = path.split(\".\");\n    var parentPath = parts.slice(0,-1).join(\".\");\n    var target     = parts.slice(-1).pop();\n    var active     = this.get(parentPath+\".__active\");\n    if(exclusive && target === active) return;\n    if(active){\n      this.toggle(parentPath+\".\"+active);\n    }\n    if(target === active){\n      this.set(parentPath+\".__active\", null);\n      return this;\n    }\n    else{\n      this.set(parentPath+\".__active\", target);\n      this.toggle(path);\n    }\n    return this;\n  }\n\n\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-appcontroller-ractive/ractive-view.js\n ** module id = 39\n ** module chunks = 1\n **/","var App = require(\"App\");\n\nmodule.exports = new App.Controllers.AppController();\n\nvar config = require(\"config\");\n\nif(config.debug === true) {\n\twindow.app    = module.exports; \n\twindow.App    = App;\n\twindow.config = config;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure-webpack/namespaces/_app.js\n ** module id = 40\n ** module chunks = 1\n **/","\nvar Backbone = require(\"backbone\");\nvar Class = require(\"./Class\");\n\nvar _ = require(\"underscore\");\n\nvar EventedClass = Class.extend(\"EventedClass\", _.extend(Backbone.Events, {\n  \n  // EventedClass's constructor handles props like:\n  // events:{\n  //   \"event_name\": \"method name\",\n  //   \"evt\": [\"method1\", \"method2\", function(){}],\n  //   \"event\": function(){ ... }\n  // }\n\n  constructor: function(){\n    if(_.isObject(this.events)){\n      for(event in this.events){ var evt = this.events[event];\n        \n        if(_.isFunction(evt)) this.on(event, evt, this);\n        \n        else if(_.isString(evt) && _.isFunction(this[evt])){\n          this.on(event, this[evt], this);\n        }\n        \n        else if(_.isArray(evt)){\n          for(var i = 0;i< evt.length;i++){ var meth = evt[i];\n            if(_.isString(meth) && _.isFunction(this[meth])){\n              this.on(event, this[meth], this);\n            }\n            else if(_.isFunction(meth)){\n              this.on(event, meth, this);\n            }\n          }\n        }\n      }\n    }\n    Class.apply(this, arguments);\n  }\n\n}), Backbone.Events);\nmodule.exports = EventedClass;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure/lib/EventedClass.js\n ** module id = 41\n ** module chunks = 1\n **/","var _ = require(\"underscore\");\nvar EventedClass = require(\"../EventedClass.js\");\n\nmodule.exports = EventedClass.extend(\"Controller\", {\n\n  bindRoutes: function(app){\n    for(var key in this.routes){\n      var handlerName = this.routes[key];\n      if(Array.isArray(handlerName)){\n        for(var i=0;i<handlerName.length;i++){\n          if(_.isFunction(this[handlerName[i]])){\n            app.router.on(\"route:\"+key, this[handlerName[i]], this);\n          }\n        }\n      }\n      else{\n        if(_.isFunction(this[handlerName])){\n          app.router.on(\"route:\"+key, this[handlerName], this);\n        }\n      }\n    }\n  }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/infrastructure/lib/client/Controller.js\n ** module id = 42\n ** module chunks = 1\n **/","/**\nThe following batches are equivalent:\n\nvar beautify_js = require('js-beautify');\nvar beautify_js = require('js-beautify').js;\nvar beautify_js = require('js-beautify').js_beautify;\n\nvar beautify_css = require('js-beautify').css;\nvar beautify_css = require('js-beautify').css_beautify;\n\nvar beautify_html = require('js-beautify').html;\nvar beautify_html = require('js-beautify').html_beautify;\n\nAll methods returned accept two arguments, the source string and an options object.\n**/\n\nfunction get_beautify(js_beautify, css_beautify, html_beautify) {\n    // the default is js\n    var beautify = function (src, config) {\n        return js_beautify.js_beautify(src, config);\n    };\n\n    // short aliases\n    beautify.js   = js_beautify.js_beautify;\n    beautify.css  = css_beautify.css_beautify;\n    beautify.html = html_beautify.html_beautify;\n\n    // legacy aliases\n    beautify.js_beautify   = js_beautify.js_beautify;\n    beautify.css_beautify  = css_beautify.css_beautify;\n    beautify.html_beautify = html_beautify.html_beautify;\n\n    return beautify;\n}\n\nif (typeof define === \"function\" && define.amd) {\n    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n    define([\n        \"./lib/beautify\",\n        \"./lib/beautify-css\",\n        \"./lib/beautify-html\"\n    ], function(js_beautify, css_beautify, html_beautify) {\n        return get_beautify(js_beautify, css_beautify, html_beautify);\n    });\n} else {\n    (function(mod) {\n        var js_beautify = require('./lib/beautify');\n        var css_beautify = require('./lib/beautify-css');\n        var html_beautify = require('./lib/beautify-html');\n\n        mod.exports = get_beautify(js_beautify, css_beautify, html_beautify);\n\n    })(module);\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-beautify/js/index.js\n ** module id = 43\n ** module chunks = 1\n **/","/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n    http://jsbeautifier.org/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)  — indent <head> and <body> sections,\n    indent_size (default 4)          — indentation size,\n    indent_char (default space)      — character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false,\n      'extra_liners': ['/html']\n    });\n*/\n\n(function() {\n\n    function trim(s) {\n        return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function ltrim(s) {\n        return s.replace(/^\\s+/g, '');\n    }\n\n    function rtrim(s) {\n        return s.replace(/\\s+$/g,'');\n    }\n\n    function style_html(html_source, options, js_beautify, css_beautify) {\n        //Wrapper function to invoke all the necessary constructors and deal with the output.\n\n        var multi_parser,\n            indent_inner_html,\n            indent_size,\n            indent_character,\n            wrap_line_length,\n            brace_style,\n            unformatted,\n            preserve_newlines,\n            max_preserve_newlines,\n            indent_handlebars,\n            wrap_attributes,\n            wrap_attributes_indent_size,\n            end_with_newline,\n            extra_liners,\n            eol;\n\n        options = options || {};\n\n        // backwards compatibility to 1.3.4\n        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&\n                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {\n            options.wrap_line_length = options.max_char;\n        }\n\n        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;\n        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);\n        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;\n        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;\n        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);\n        unformatted = options.unformatted || [\n            // https://www.w3.org/TR/html5/dom.html#phrasing-content\n            'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',\n            'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',\n            'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',\n            'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',\n            'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',\n            'video', 'wbr', 'text',\n            // prexisting - not sure of full effect of removing, leaving in\n            'acronym', 'address', 'big', 'dt', 'ins', 'small', 'strike', 'tt',\n            'pre',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6'\n        ];\n        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\n        max_preserve_newlines = preserve_newlines ?\n            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))\n            : 0;\n        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;\n        wrap_attributes = (options.wrap_attributes === undefined) ? 'auto' : options.wrap_attributes;\n        wrap_attributes_indent_size = (isNaN(parseInt(options.wrap_attributes_indent_size, 10))) ? indent_size : parseInt(options.wrap_attributes_indent_size, 10);\n        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n        extra_liners = (typeof options.extra_liners == 'object') && options.extra_liners ?\n            options.extra_liners.concat() : (typeof options.extra_liners === 'string') ?\n            options.extra_liners.split(',') : 'head,body,/html'.split(',');\n        eol = options.eol ? options.eol : '\\n';\n\n        if(options.indent_with_tabs){\n            indent_character = '\\t';\n            indent_size = 1;\n        }\n\n        eol = eol.replace(/\\\\r/, '\\r').replace(/\\\\n/, '\\n')\n\n        function Parser() {\n\n            this.pos = 0; //Parser position\n            this.token = '';\n            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n                parent: 'parent1',\n                parentcount: 1,\n                parent1: ''\n            };\n            this.tag_type = '';\n            this.token_text = this.last_token = this.last_text = this.token_type = '';\n            this.newlines = 0;\n            this.indent_content = indent_inner_html;\n\n            this.Utils = { //Uilities made available to the various functions\n                whitespace: \"\\n\\r\\t \".split(''),\n\n                single_token: [\n                    // HTLM void elements - aka self-closing tags - aka singletons\n                    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n                    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',\n                    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',\n                    // NOTE: Optional tags - are not understood.\n                    // https://www.w3.org/TR/html5/syntax.html#optional-tags\n                    // The rules for optional tags are too complex for a simple list\n                    // Also, the content of these tags should still be indented in many cases.\n                    // 'li' is a good exmple.\n\n                    // Doctype and xml elements\n                    '!doctype', '?xml',\n                    // ?php tag\n                    '?php',\n                    // other tags that were in this list, keeping just in case\n                    'basefont', 'isindex'\n                ],\n                extra_liners: extra_liners, //for tags that need a line of whitespace before them\n                in_array: function(what, arr) {\n                    for (var i = 0; i < arr.length; i++) {\n                        if (what === arr[i]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n\n            // Return true if the given text is composed entirely of whitespace.\n            this.is_whitespace = function(text) {\n                for (var n = 0; n < text.length; n++) {\n                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n\n            this.traverse_whitespace = function() {\n                var input_char = '';\n\n                input_char = this.input.charAt(this.pos);\n                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                    this.newlines = 0;\n                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (preserve_newlines && input_char === '\\n' && this.newlines <= max_preserve_newlines) {\n                            this.newlines += 1;\n                        }\n\n                        this.pos++;\n                        input_char = this.input.charAt(this.pos);\n                    }\n                    return true;\n                }\n                return false;\n            };\n\n            // Append a space to the given content (string array) or, if we are\n            // at the wrap_line_length, append a newline/indentation.\n            // return true if a newline was added, false if a space was added\n            this.space_or_wrap = function(content) {\n                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached\n                    this.print_newline(false, content);\n                    this.print_indentation(content);\n                    return true;\n                } else {\n                    this.line_char_count++;\n                    content.push(' ');\n                    return false;\n                }\n            };\n\n            this.get_content = function() { //function to capture regular content between tags\n                var input_char = '',\n                    content = [],\n                    space = false; //if a space is needed\n\n                while (this.input.charAt(this.pos) !== '<') {\n                    if (this.pos >= this.input.length) {\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                        continue;\n                    }\n\n                    if (indent_handlebars) {\n                        // Handlebars parsing is complicated.\n                        // {{#foo}} and {{/foo}} are formatted tags.\n                        // {{something}} should get treated as content, except:\n                        // {{else}} specifically behaves like {{#if}} and {{/if}}\n                        var peek3 = this.input.substr(this.pos, 3);\n                        if (peek3 === '{{#' || peek3 === '{{/') {\n                            // These are tags and not content.\n                            break;\n                        } else if (peek3 === '{{!') {\n                            return [this.get_tag(), 'TK_TAG_HANDLEBARS_COMMENT'];\n                        } else if (this.input.substr(this.pos, 2) === '{{') {\n                            if (this.get_tag(true) === '{{else}}') {\n                                break;\n                            }\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                    this.line_char_count++;\n                    content.push(input_char); //letter at-a-time (or string) inserted to an array\n                }\n                return content.length ? content.join('') : '';\n            };\n\n            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify\n                if (this.pos === this.input.length) {\n                    return ['', 'TK_EOF'];\n                }\n                var input_char = '';\n                var content = '';\n                var reg_match = new RegExp('</' + name + '\\\\s*>', 'igm');\n                reg_match.lastIndex = this.pos;\n                var reg_array = reg_match.exec(this.input);\n                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script\n                if (this.pos < end_script) { //get everything in between the script tags\n                    content = this.input.substring(this.pos, end_script);\n                    this.pos = end_script;\n                }\n                return content;\n            };\n\n            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object\n                if (this.tags[tag + 'count']) { //check for the existence of this tag type\n                    this.tags[tag + 'count']++;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                } else { //otherwise initialize this tag type\n                    this.tags[tag + 'count'] = 1;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                }\n                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n            };\n\n            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer\n                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\n                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n                    while (temp_parent) { //till we reach '' (the initial value);\n                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\n                            break;\n                        }\n                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n                    }\n                    if (temp_parent) { //if we caught something\n                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n                    }\n                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n                    if (this.tags[tag + 'count'] === 1) {\n                        delete this.tags[tag + 'count'];\n                    } else {\n                        this.tags[tag + 'count']--;\n                    }\n                }\n            };\n\n            this.indent_to_tag = function(tag) {\n                // Match the indentation level to the last use of this tag, but don't remove it.\n                if (!this.tags[tag + 'count']) {\n                    return;\n                }\n                var temp_parent = this.tags.parent;\n                while (temp_parent) {\n                    if (tag + this.tags[tag + 'count'] === temp_parent) {\n                        break;\n                    }\n                    temp_parent = this.tags[temp_parent + 'parent'];\n                }\n                if (temp_parent) {\n                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];\n                }\n            };\n\n            this.get_tag = function(peek) { //function to get a full tag and parse its type\n                var input_char = '',\n                    content = [],\n                    comment = '',\n                    space = false,\n                    first_attr = true,\n                    tag_start, tag_end,\n                    tag_start_char,\n                    orig_pos = this.pos,\n                    orig_line_char_count = this.line_char_count;\n\n                peek = peek !== undefined ? peek : false;\n\n                do {\n                    if (this.pos >= this.input.length) {\n                        if (peek) {\n                            this.pos = orig_pos;\n                            this.line_char_count = orig_line_char_count;\n                        }\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\n                        space = true;\n                        continue;\n                    }\n\n                    if (input_char === \"'\" || input_char === '\"') {\n                        input_char += this.get_unformatted(input_char);\n                        space = true;\n\n                    }\n\n                    if (input_char === '=') { //no space before =\n                        space = false;\n                    }\n\n                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {\n                        //no space after = or before >\n                        var wrapped = this.space_or_wrap(content);\n                        var indentAttrs = wrapped && input_char !== '/' && wrap_attributes !== 'force';\n                        space = false;\n                        if (!first_attr && wrap_attributes === 'force' &&  input_char !== '/') {\n                            this.print_newline(false, content);\n                            this.print_indentation(content);\n                            indentAttrs = true;\n                        }\n                        if (indentAttrs) {\n                            //indent attributes an auto or forced line-wrap\n                            for (var count = 0; count < wrap_attributes_indent_size; count++) {\n                                content.push(indent_character);\n                            }\n                        }\n                        for (var i = 0; i < content.length; i++) {\n                          if (content[i] === ' ') {\n                            first_attr = false;\n                            break;\n                          }\n                        }\n                    }\n\n                    if (indent_handlebars && tag_start_char === '<') {\n                        // When inside an angle-bracket tag, put spaces around\n                        // handlebars not inside of strings.\n                        if ((input_char + this.input.charAt(this.pos)) === '{{') {\n                            input_char += this.get_unformatted('}}');\n                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {\n                                input_char = ' ' + input_char;\n                            }\n                            space = true;\n                        }\n                    }\n\n                    if (input_char === '<' && !tag_start_char) {\n                        tag_start = this.pos - 1;\n                        tag_start_char = '<';\n                    }\n\n                    if (indent_handlebars && !tag_start_char) {\n                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] === '{') {\n                            if (input_char === '#' || input_char === '/' || input_char === '!') {\n                                tag_start = this.pos - 3;\n                            } else {\n                                tag_start = this.pos - 2;\n                            }\n                            tag_start_char = '{';\n                        }\n                    }\n\n                    this.line_char_count++;\n                    content.push(input_char); //inserts character at-a-time (or string)\n\n                    if (content[1] && (content[1] === '!' || content[1] === '?' || content[1] === '%')) { //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        content = [this.get_comment(tag_start)];\n                        break;\n                    }\n\n                    if (indent_handlebars && content[1] && content[1] === '{' && content[2] && content[2] === '!') { //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        content = [this.get_comment(tag_start)];\n                        break;\n                    }\n\n                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {\n                        break;\n                    }\n                } while (input_char !== '>');\n\n                var tag_complete = content.join('');\n                var tag_index;\n                var tag_offset;\n\n                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends\n                    tag_index = tag_complete.indexOf(' ');\n                } else if (tag_complete.charAt(0) === '{') {\n                    tag_index = tag_complete.indexOf('}');\n                } else { //otherwise go with the tag ending\n                    tag_index = tag_complete.indexOf('>');\n                }\n                if (tag_complete.charAt(0) === '<' || !indent_handlebars) {\n                    tag_offset = 1;\n                } else {\n                    tag_offset = tag_complete.charAt(2) === '#' ? 3 : 2;\n                }\n                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();\n                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||\n                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                    }\n                } else if (indent_handlebars && tag_complete.charAt(0) === '{' && tag_check === 'else') {\n                    if (!peek) {\n                        this.indent_to_tag('if');\n                        this.tag_type = 'HANDLEBARS_ELSE';\n                        this.indent_content = true;\n                        this.traverse_whitespace();\n                    }\n                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\n                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function\n                    content.push(comment);\n                    tag_end = this.pos - 1;\n                    this.tag_type = 'SINGLE';\n                } else if (tag_check === 'script' &&\n                    (tag_complete.search('type') === -1 ||\n                    (tag_complete.search('type') > -1 &&\n                    tag_complete.search(/\\b(text|application)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json)/) > -1))) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'SCRIPT';\n                    }\n                } else if (tag_check === 'style' &&\n                    (tag_complete.search('type') === -1 ||\n                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'STYLE';\n                    }\n                } else if (tag_check.charAt(0) === '!') { //peek for <! comment\n                    // for comments content is already correct.\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                        this.traverse_whitespace();\n                    }\n                } else if (!peek) {\n                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\n                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n                        this.tag_type = 'END';\n                    } else { //otherwise it's a start-tag\n                        this.record_tag(tag_check); //push it on the tag stack\n                        if (tag_check.toLowerCase() !== 'html') {\n                            this.indent_content = true;\n                        }\n                        this.tag_type = 'START';\n                    }\n\n                    // Allow preserving of newlines after a start or end tag\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                    }\n\n                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\n                        this.print_newline(false, this.output);\n                        if (this.output.length && this.output[this.output.length - 2] !== '\\n') {\n                            this.print_newline(true, this.output);\n                        }\n                    }\n                }\n\n                if (peek) {\n                    this.pos = orig_pos;\n                    this.line_char_count = orig_line_char_count;\n                }\n\n                return content.join(''); //returns fully formatted tag\n            };\n\n            this.get_comment = function(start_pos) { //function to return comment content in its entirety\n                // this is will have very poor perf, but will work for now.\n                var comment = '',\n                    delimiter = '>',\n                    matched = false;\n\n                this.pos = start_pos;\n                var input_char = this.input.charAt(this.pos);\n                this.pos++;\n\n                while (this.pos <= this.input.length) {\n                    comment += input_char;\n\n                    // only need to check for the delimiter if the last chars match\n                    if (comment.charAt(comment.length - 1) === delimiter.charAt(delimiter.length - 1) &&\n                        comment.indexOf(delimiter) !== -1) {\n                        break;\n                    }\n\n                    // only need to search for custom delimiter for the first few characters\n                    if (!matched && comment.length < 10) {\n                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment\n                            delimiter = '<![endif]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...\n                            delimiter = ']]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...\n                            delimiter = ']>';\n                            matched = true;\n                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...\n                            delimiter = '-->';\n                            matched = true;\n                        } else if (comment.indexOf('{{!') === 0) { // {{! handlebars comment\n                            delimiter = '}}';\n                            matched = true;\n                        } else if (comment.indexOf('<?') === 0) { // {{! handlebars comment\n                            delimiter = '?>';\n                            matched = true;\n                        } else if (comment.indexOf('<%') === 0) { // {{! handlebars comment\n                            delimiter = '%>';\n                            matched = true;\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                }\n\n                return comment;\n            };\n\n            function tokenMatcher(delimiter) {\n              var token = '';\n\n              var add = function (str) {\n                var newToken = token + str.toLowerCase();\n                token = newToken.length <= delimiter.length ? newToken : newToken.substr(newToken.length - delimiter.length, delimiter.length);\n              };\n\n              var doesNotMatch = function () {\n                return token.indexOf(delimiter) === -1;\n              };\n\n              return {\n                add: add,\n                doesNotMatch: doesNotMatch\n              };\n            }\n\n            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety\n                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {\n                    return '';\n                }\n                var input_char = '';\n                var content = '';\n                var space = true;\n\n                var delimiterMatcher = tokenMatcher(delimiter);\n\n                do {\n\n                    if (this.pos >= this.input.length) {\n                        return content;\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (!space) {\n                            this.line_char_count--;\n                            continue;\n                        }\n                        if (input_char === '\\n' || input_char === '\\r') {\n                            content += '\\n';\n                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n                for (var i=0; i<this.indent_level; i++) {\n                  content += this.indent_string;\n                }\n                space = false; //...and make sure other indentation is erased\n                */\n                            this.line_char_count = 0;\n                            continue;\n                        }\n                    }\n                    content += input_char;\n                    delimiterMatcher.add(input_char);\n                    this.line_char_count++;\n                    space = true;\n\n                    if (indent_handlebars && input_char === '{' && content.length && content.charAt(content.length - 2) === '{') {\n                        // Handlebars expressions in strings should also be unformatted.\n                        content += this.get_unformatted('}}');\n                        // Don't consider when stopping for delimiters.\n                    }\n                } while (delimiterMatcher.doesNotMatch());\n\n                return content;\n            };\n\n            this.get_token = function() { //initial handler for token-retrieval\n                var token;\n\n                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\n                    var type = this.last_token.substr(7);\n                    token = this.get_contents_to(type);\n                    if (typeof token !== 'string') {\n                        return token;\n                    }\n                    return [token, 'TK_' + type];\n                }\n                if (this.current_mode === 'CONTENT') {\n                    token = this.get_content();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        return [token, 'TK_CONTENT'];\n                    }\n                }\n\n                if (this.current_mode === 'TAG') {\n                    token = this.get_tag();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        var tag_name_type = 'TK_TAG_' + this.tag_type;\n                        return [token, tag_name_type];\n                    }\n                }\n            };\n\n            this.get_full_indent = function(level) {\n                level = this.indent_level + level || 0;\n                if (level < 1) {\n                    return '';\n                }\n\n                return Array(level + 1).join(this.indent_string);\n            };\n\n            this.is_unformatted = function(tag_check, unformatted) {\n                //is this an HTML5 block-level link?\n                if (!this.Utils.in_array(tag_check, unformatted)) {\n                    return false;\n                }\n\n                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {\n                    return true;\n                }\n\n                //at this point we have an  tag; is its first child something we want to remain\n                //unformatted?\n                var next_tag = this.get_tag(true /* peek. */ );\n\n                // test next_tag to see if it is just html tag (no external content)\n                var tag = (next_tag || \"\").match(/^\\s*<\\s*\\/?([a-z]*)\\s*[^>]*>\\s*$/);\n\n                // if next_tag comes back but is not an isolated tag, then\n                // let's treat the 'a' tag as having content\n                // and respect the unformatted option\n                if (!tag || this.Utils.in_array(tag, unformatted)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n\n            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions\n\n                this.input = js_source || ''; //gets the input for the Parser\n\n                // HACK: newline parsing inconsistent. This brute force normalizes the input.\n                this.input = this.input.replace(/\\r\\n|[\\r\\u2028\\u2029]/g, '\\n')\n\n                this.output = [];\n                this.indent_character = indent_character;\n                this.indent_string = '';\n                this.indent_size = indent_size;\n                this.brace_style = brace_style;\n                this.indent_level = 0;\n                this.wrap_line_length = wrap_line_length;\n                this.line_char_count = 0; //count to see if wrap_line_length was exceeded\n\n                for (var i = 0; i < this.indent_size; i++) {\n                    this.indent_string += this.indent_character;\n                }\n\n                this.print_newline = function(force, arr) {\n                    this.line_char_count = 0;\n                    if (!arr || !arr.length) {\n                        return;\n                    }\n                    if (force || (arr[arr.length - 1] !== '\\n')) { //we might want the extra line\n                        if ((arr[arr.length - 1] !== '\\n')) {\n                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);\n                        }\n                        arr.push('\\n');\n                    }\n                };\n\n                this.print_indentation = function(arr) {\n                    for (var i = 0; i < this.indent_level; i++) {\n                        arr.push(this.indent_string);\n                        this.line_char_count += this.indent_string.length;\n                    }\n                };\n\n                this.print_token = function(text) {\n                    // Avoid printing initial whitespace.\n                    if (this.is_whitespace(text) && !this.output.length) {\n                        return;\n                    }\n                    if (text || text !== '') {\n                        if (this.output.length && this.output[this.output.length - 1] === '\\n') {\n                            this.print_indentation(this.output);\n                            text = ltrim(text);\n                        }\n                    }\n                    this.print_token_raw(text);\n                };\n\n                this.print_token_raw = function(text) {\n                    // If we are going to print newlines, truncate trailing\n                    // whitespace, as the newlines will represent the space.\n                    if (this.newlines > 0) {\n                        text = rtrim(text);\n                    }\n\n                    if (text && text !== '') {\n                        if (text.length > 1 && text.charAt(text.length - 1) === '\\n') {\n                            // unformatted tags can grab newlines as their last character\n                            this.output.push(text.slice(0, -1));\n                            this.print_newline(false, this.output);\n                        } else {\n                            this.output.push(text);\n                        }\n                    }\n\n                    for (var n = 0; n < this.newlines; n++) {\n                        this.print_newline(n > 0, this.output);\n                    }\n                    this.newlines = 0;\n                };\n\n                this.indent = function() {\n                    this.indent_level++;\n                };\n\n                this.unindent = function() {\n                    if (this.indent_level > 0) {\n                        this.indent_level--;\n                    }\n                };\n            };\n            return this;\n        }\n\n        /*_____________________--------------------_____________________*/\n\n        multi_parser = new Parser(); //wrapping functions Parser\n        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values\n\n        while (true) {\n            var t = multi_parser.get_token();\n            multi_parser.token_text = t[0];\n            multi_parser.token_type = t[1];\n\n            if (multi_parser.token_type === 'TK_EOF') {\n                break;\n            }\n\n            switch (multi_parser.token_type) {\n                case 'TK_TAG_START':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        multi_parser.indent();\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_STYLE':\n                case 'TK_TAG_SCRIPT':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_END':\n                    //Print new line only if the tag has no content and has child\n                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n                        var tag_name = multi_parser.token_text.match(/\\w+/)[0];\n                        var tag_extracted_from_last_output = null;\n                        if (multi_parser.output.length) {\n                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\\s*(\\w+)/);\n                        }\n                        if (tag_extracted_from_last_output === null ||\n                            (tag_extracted_from_last_output[1] !== tag_name && !multi_parser.Utils.in_array(tag_extracted_from_last_output[1], unformatted))) {\n                            multi_parser.print_newline(false, multi_parser.output);\n                        }\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_SINGLE':\n                    // Don't add a newline before elements that should remain unformatted.\n                    var tag_check = multi_parser.token_text.match(/^\\s*<([a-z-]+)/i);\n                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {\n                        multi_parser.print_newline(false, multi_parser.output);\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_HANDLEBARS_ELSE':\n                    // Don't add a newline if opening {{#if}} tag is on the current line\n                    var foundIfOnCurrentLine = false;\n                    for (var lastCheckedOutput=multi_parser.output.length-1; lastCheckedOutput>=0; lastCheckedOutput--) {\n\t\t        if (multi_parser.output[lastCheckedOutput] === '\\n') {\n\t\t            break;\n                        } else {\n                            if (multi_parser.output[lastCheckedOutput].match(/{{#if/)) {\n                                foundIfOnCurrentLine = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (!foundIfOnCurrentLine) {\n                        multi_parser.print_newline(false, multi_parser.output);\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        multi_parser.indent();\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_HANDLEBARS_COMMENT':\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                case 'TK_CONTENT':\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                case 'TK_STYLE':\n                case 'TK_SCRIPT':\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_newline(false, multi_parser.output);\n                        var text = multi_parser.token_text,\n                            _beautifier,\n                            script_indent_level = 1;\n                        if (multi_parser.token_type === 'TK_SCRIPT') {\n                            _beautifier = typeof js_beautify === 'function' && js_beautify;\n                        } else if (multi_parser.token_type === 'TK_STYLE') {\n                            _beautifier = typeof css_beautify === 'function' && css_beautify;\n                        }\n\n                        if (options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (options.indent_scripts === \"separate\") {\n                            script_indent_level = -multi_parser.indent_level;\n                        }\n\n                        var indentation = multi_parser.get_full_indent(script_indent_level);\n                        if (_beautifier) {\n\n                            // call the Beautifier if avaliable\n                            var Child_options = function() {\n                                this.eol = '\\n';\n                            };\n                            Child_options.prototype = options;\n                            var child_options = new Child_options();\n                            text = _beautifier(text.replace(/^\\s*/, indentation), child_options);\n                        } else {\n                            // simply indent the string otherwise\n                            var white = text.match(/^\\s*/)[0];\n                            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);\n                            text = text.replace(/^\\s*/, indentation)\n                                .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\n                                .replace(/\\s+$/, '');\n                        }\n                        if (text) {\n                            multi_parser.print_token_raw(text);\n                            multi_parser.print_newline(true, multi_parser.output);\n                        }\n                    }\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                default:\n                    // We should not be getting here but we don't want to drop input on the floor\n                    // Just output the text and move on\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_token(multi_parser.token_text);\n                    }\n                    break;\n            }\n            multi_parser.last_token = multi_parser.token_type;\n            multi_parser.last_text = multi_parser.token_text;\n        }\n        var sweet_code = multi_parser.output.join('').replace(/[\\r\\n\\t ]+$/, '');\n\n        // establish end_with_newline\n        if (end_with_newline) {\n            sweet_code += '\\n';\n        }\n\n        if (eol != '\\n') {\n            sweet_code = sweet_code.replace(/[\\n]/g, eol);\n        }\n\n        return sweet_code;\n    }\n\n    if (typeof define === \"function\" && define.amd) {\n        // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )\n        define([\"require\", \"./beautify\", \"./beautify-css\"], function(requireamd) {\n            var js_beautify =  requireamd(\"./beautify\");\n            var css_beautify =  requireamd(\"./beautify-css\");\n\n            return {\n              html_beautify: function(html_source, options) {\n                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n              }\n            };\n        });\n    } else if (typeof exports !== \"undefined\") {\n        // Add support for CommonJS. Just put this file somewhere on your require.paths\n        // and you will be able to `var html_beautify = require(\"beautify\").html_beautify`.\n        var js_beautify = require('./beautify.js');\n        var css_beautify = require('./beautify-css.js');\n\n        exports.html_beautify = function(html_source, options) {\n            return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);\n        };\n    } else if (typeof window !== \"undefined\") {\n        // If we're running a web page and don't have either of the above, add our one global\n        window.html_beautify = function(html_source, options) {\n            return style_html(html_source, options, window.js_beautify, window.css_beautify);\n        };\n    } else if (typeof global !== \"undefined\") {\n        // If we don't even have window, try global.\n        global.html_beautify = function(html_source, options) {\n            return style_html(html_source, options, global.js_beautify, global.css_beautify);\n        };\n    }\n\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-beautify/js/lib/beautify-html.js\n ** module id = 44\n ** module chunks = 1\n **/","module.exports = {\n\t\"/\": \"setContext\",\n\t\"/:screen\": \"setContext\",\n\t\"/:screen/:tab\": \"setContext\",\n\t\"/:screen/:tab/:context\": \"setContext\",\n\t\"/:screen/:tab/:context/:action\": \"setContext\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/routes.json\n ** module id = 45\n ** module chunks = 1\n **/","/*\n\tRactive.js v0.7.3\n\tSat Apr 25 2015 13:52:38 GMT-0400 (EDT) - commit da40f81c660ba2f09c45a09a9c20fdd34ee36d80\n\n\thttp://ractivejs.org\n\thttp://twitter.com/RactiveJS\n\n\tReleased under the MIT License.\n*/\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ractive = factory()\n}(this, function () { 'use strict';\n\n  var TEMPLATE_VERSION = 3;\n\n  var defaultOptions = {\n\n  \t// render placement:\n  \tel: void 0,\n  \tappend: false,\n\n  \t// template:\n  \ttemplate: { v: TEMPLATE_VERSION, t: [] },\n\n  \t// parse:     // TODO static delimiters?\n  \tpreserveWhitespace: false,\n  \tsanitize: false,\n  \tstripComments: true,\n  \tdelimiters: [\"{{\", \"}}\"],\n  \ttripleDelimiters: [\"{{{\", \"}}}\"],\n  \tinterpolate: false,\n\n  \t// data & binding:\n  \tdata: {},\n  \tcomputed: {},\n  \tmagic: false,\n  \tmodifyArrays: true,\n  \tadapt: [],\n  \tisolated: false,\n  \ttwoway: true,\n  \tlazy: false,\n\n  \t// transitions:\n  \tnoIntro: false,\n  \ttransitionsEnabled: true,\n  \tcomplete: void 0,\n\n  \t// css:\n  \tcss: null,\n  \tnoCssTransform: false\n  };\n\n  var config_defaults = defaultOptions;\n\n  // These are a subset of the easing equations found at\n  // https://raw.github.com/danro/easing-js - license info\n  // follows:\n\n  // --------------------------------------------------\n  // easing.js v0.5.4\n  // Generic set of easing functions with AMD support\n  // https://github.com/danro/easing-js\n  // This code may be freely distributed under the MIT license\n  // http://danro.mit-license.org/\n  // --------------------------------------------------\n  // All functions adapted from Thomas Fuchs & Jeremy Kahn\n  // Easing Equations (c) 2003 Robert Penner, BSD license\n  // https://raw.github.com/danro/easing-js/master/LICENSE\n  // --------------------------------------------------\n\n  // In that library, the functions named easeIn, easeOut, and\n  // easeInOut below are named easeInCubic, easeOutCubic, and\n  // (you guessed it) easeInOutCubic.\n  //\n  // You can add additional easing functions to this list, and they\n  // will be globally available.\n\n  var static_easing = {\n  \tlinear: function (pos) {\n  \t\treturn pos;\n  \t},\n  \teaseIn: function (pos) {\n  \t\treturn Math.pow(pos, 3);\n  \t},\n  \teaseOut: function (pos) {\n  \t\treturn Math.pow(pos - 1, 3) + 1;\n  \t},\n  \teaseInOut: function (pos) {\n  \t\tif ((pos /= 0.5) < 1) {\n  \t\t\treturn 0.5 * Math.pow(pos, 3);\n  \t\t}\n  \t\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\n  \t}\n  };\n\n  /*global console, navigator */\n  var isClient, isJsdom, hasConsole, environment__magic, namespaces, svg, vendors;\n\n  isClient = typeof document === \"object\";\n\n  isJsdom = typeof navigator !== \"undefined\" && /jsDom/.test(navigator.appName);\n\n  hasConsole = typeof console !== \"undefined\" && typeof console.warn === \"function\" && typeof console.warn.apply === \"function\";\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n  \tenvironment__magic = true;\n  } catch (e) {\n  \tenvironment__magic = false;\n  }\n\n  namespaces = {\n  \thtml: \"http://www.w3.org/1999/xhtml\",\n  \tmathml: \"http://www.w3.org/1998/Math/MathML\",\n  \tsvg: \"http://www.w3.org/2000/svg\",\n  \txlink: \"http://www.w3.org/1999/xlink\",\n  \txml: \"http://www.w3.org/XML/1998/namespace\",\n  \txmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n\n  if (typeof document === \"undefined\") {\n  \tsvg = false;\n  } else {\n  \tsvg = document && document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\");\n  }\n\n  vendors = [\"o\", \"ms\", \"moz\", \"webkit\"];\n\n  var createElement, matches, dom__div, methodNames, unprefixed, prefixed, dom__i, j, makeFunction;\n\n  // Test for SVG support\n  if (!svg) {\n  \tcreateElement = function (type, ns) {\n  \t\tif (ns && ns !== namespaces.html) {\n  \t\t\tthrow \"This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you're trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information\";\n  \t\t}\n\n  \t\treturn document.createElement(type);\n  \t};\n  } else {\n  \tcreateElement = function (type, ns) {\n  \t\tif (!ns || ns === namespaces.html) {\n  \t\t\treturn document.createElement(type);\n  \t\t}\n\n  \t\treturn document.createElementNS(ns, type);\n  \t};\n  }\n\n  function getElement(input) {\n  \tvar output;\n\n  \tif (!input || typeof input === \"boolean\") {\n  \t\treturn;\n  \t}\n\n  \tif (typeof window === \"undefined\" || !document || !input) {\n  \t\treturn null;\n  \t}\n\n  \t// We already have a DOM node - no work to do. (Duck typing alert!)\n  \tif (input.nodeType) {\n  \t\treturn input;\n  \t}\n\n  \t// Get node from string\n  \tif (typeof input === \"string\") {\n  \t\t// try ID first\n  \t\toutput = document.getElementById(input);\n\n  \t\t// then as selector, if possible\n  \t\tif (!output && document.querySelector) {\n  \t\t\toutput = document.querySelector(input);\n  \t\t}\n\n  \t\t// did it work?\n  \t\tif (output && output.nodeType) {\n  \t\t\treturn output;\n  \t\t}\n  \t}\n\n  \t// If we've been given a collection (jQuery, Zepto etc), extract the first item\n  \tif (input[0] && input[0].nodeType) {\n  \t\treturn input[0];\n  \t}\n\n  \treturn null;\n  }\n\n  if (!isClient) {\n  \tmatches = null;\n  } else {\n  \tdom__div = createElement(\"div\");\n  \tmethodNames = [\"matches\", \"matchesSelector\"];\n\n  \tmakeFunction = function (methodName) {\n  \t\treturn function (node, selector) {\n  \t\t\treturn node[methodName](selector);\n  \t\t};\n  \t};\n\n  \tdom__i = methodNames.length;\n\n  \twhile (dom__i-- && !matches) {\n  \t\tunprefixed = methodNames[dom__i];\n\n  \t\tif (dom__div[unprefixed]) {\n  \t\t\tmatches = makeFunction(unprefixed);\n  \t\t} else {\n  \t\t\tj = vendors.length;\n  \t\t\twhile (j--) {\n  \t\t\t\tprefixed = vendors[dom__i] + unprefixed.substr(0, 1).toUpperCase() + unprefixed.substring(1);\n\n  \t\t\t\tif (dom__div[prefixed]) {\n  \t\t\t\t\tmatches = makeFunction(prefixed);\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// IE8...\n  \tif (!matches) {\n  \t\tmatches = function (node, selector) {\n  \t\t\tvar nodes, parentNode, i;\n\n  \t\t\tparentNode = node.parentNode;\n\n  \t\t\tif (!parentNode) {\n  \t\t\t\t// empty dummy <div>\n  \t\t\t\tdom__div.innerHTML = \"\";\n\n  \t\t\t\tparentNode = dom__div;\n  \t\t\t\tnode = node.cloneNode();\n\n  \t\t\t\tdom__div.appendChild(node);\n  \t\t\t}\n\n  \t\t\tnodes = parentNode.querySelectorAll(selector);\n\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] === node) {\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t};\n  \t}\n  }\n\n  function detachNode(node) {\n  \tif (node && typeof node.parentNode !== \"unknown\" && node.parentNode) {\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \treturn node;\n  }\n\n  function safeToStringValue(value) {\n  \treturn value == null || !value.toString ? \"\" : value;\n  }\n\n  var legacy = null;\n\n  var create, defineProperty, defineProperties;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tif (isClient) {\n  \t\tObject.defineProperty(document.createElement(\"div\"), \"test\", { value: 0 });\n  \t}\n\n  \tdefineProperty = Object.defineProperty;\n  } catch (err) {\n  \t// Object.defineProperty doesn't exist, or we're in IE8 where you can\n  \t// only use it with DOM objects (what were you smoking, MSFT?)\n  \tdefineProperty = function (obj, prop, desc) {\n  \t\tobj[prop] = desc.value;\n  \t};\n  }\n\n  try {\n  \ttry {\n  \t\tObject.defineProperties({}, { test: { value: 0 } });\n  \t} catch (err) {\n  \t\t// TODO how do we account for this? noMagic = true;\n  \t\tthrow err;\n  \t}\n\n  \tif (isClient) {\n  \t\tObject.defineProperties(createElement(\"div\"), { test: { value: 0 } });\n  \t}\n\n  \tdefineProperties = Object.defineProperties;\n  } catch (err) {\n  \tdefineProperties = function (obj, props) {\n  \t\tvar prop;\n\n  \t\tfor (prop in props) {\n  \t\t\tif (props.hasOwnProperty(prop)) {\n  \t\t\t\tdefineProperty(obj, prop, props[prop]);\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  try {\n  \tObject.create(null);\n\n  \tcreate = Object.create;\n  } catch (err) {\n  \t// sigh\n  \tcreate = (function () {\n  \t\tvar F = function () {};\n\n  \t\treturn function (proto, props) {\n  \t\t\tvar obj;\n\n  \t\t\tif (proto === null) {\n  \t\t\t\treturn {};\n  \t\t\t}\n\n  \t\t\tF.prototype = proto;\n  \t\t\tobj = new F();\n\n  \t\t\tif (props) {\n  \t\t\t\tObject.defineProperties(obj, props);\n  \t\t\t}\n\n  \t\t\treturn obj;\n  \t\t};\n  \t})();\n  }\n\n  function utils_object__extend(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tvar prop, source;\n\n  \twhile (source = sources.shift()) {\n  \t\tfor (prop in source) {\n  \t\t\tif (hasOwn.call(source, prop)) {\n  \t\t\t\ttarget[prop] = source[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn target;\n  }\n\n  function fillGaps(target) {\n  \tfor (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\tsources[_key - 1] = arguments[_key];\n  \t}\n\n  \tsources.forEach(function (s) {\n  \t\tfor (var key in s) {\n  \t\t\tif (s.hasOwnProperty(key) && !(key in target)) {\n  \t\t\t\ttarget[key] = s[key];\n  \t\t\t}\n  \t\t}\n  \t});\n\n  \treturn target;\n  }\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  // thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  var is__toString = Object.prototype.toString,\n      arrayLikePattern = /^\\[object (?:Array|FileList)\\]$/;\n  function isArray(thing) {\n  \treturn is__toString.call(thing) === \"[object Array]\";\n  }\n\n  function isArrayLike(obj) {\n  \treturn arrayLikePattern.test(is__toString.call(obj));\n  }\n\n  function isEqual(a, b) {\n  \tif (a === null && b === null) {\n  \t\treturn true;\n  \t}\n\n  \tif (typeof a === \"object\" || typeof b === \"object\") {\n  \t\treturn false;\n  \t}\n\n  \treturn a === b;\n  }\n\n  function is__isNumeric(thing) {\n  \treturn !isNaN(parseFloat(thing)) && isFinite(thing);\n  }\n\n  function isObject(thing) {\n  \treturn thing && is__toString.call(thing) === \"[object Object]\";\n  }\n\n  var noop = function () {};\n\n  /* global console */\n  var alreadyWarned = {},\n      log,\n      printWarning,\n      welcome;\n\n  if (hasConsole) {\n  \t(function () {\n  \t\tvar welcomeIntro = [\"%cRactive.js %c0.7.3 %cin debug mode, %cmore...\", \"color: rgb(114, 157, 52); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(85, 85, 85); font-weight: normal;\", \"color: rgb(82, 140, 224); font-weight: normal; text-decoration: underline;\"];\n  \t\tvar welcomeMessage = \"You're running Ractive 0.7.3 in debug mode - messages will be printed to the console to help you fix problems and optimise your application.\\n\\nTo disable debug mode, add this line at the start of your app:\\n  Ractive.DEBUG = false;\\n\\nTo disable debug mode when your app is minified, add this snippet:\\n  Ractive.DEBUG = /unminified/.test(function(){/*unminified*/});\\n\\nGet help and support:\\n  http://docs.ractivejs.org\\n  http://stackoverflow.com/questions/tagged/ractivejs\\n  http://groups.google.com/forum/#!forum/ractive-js\\n  http://twitter.com/ractivejs\\n\\nFound a bug? Raise an issue:\\n  https://github.com/ractivejs/ractive/issues\\n\\n\";\n\n  \t\twelcome = function () {\n  \t\t\tvar hasGroup = !!console.groupCollapsed;\n  \t\t\tconsole[hasGroup ? \"groupCollapsed\" : \"log\"].apply(console, welcomeIntro);\n  \t\t\tconsole.log(welcomeMessage);\n  \t\t\tif (hasGroup) {\n  \t\t\t\tconsole.groupEnd(welcomeIntro);\n  \t\t\t}\n\n  \t\t\twelcome = noop;\n  \t\t};\n\n  \t\tprintWarning = function (message, args) {\n  \t\t\twelcome();\n\n  \t\t\t// extract information about the instance this message pertains to, if applicable\n  \t\t\tif (typeof args[args.length - 1] === \"object\") {\n  \t\t\t\tvar options = args.pop();\n  \t\t\t\tvar ractive = options ? options.ractive : null;\n\n  \t\t\t\tif (ractive) {\n  \t\t\t\t\t// if this is an instance of a component that we know the name of, add\n  \t\t\t\t\t// it to the message\n  \t\t\t\t\tvar _name = undefined;\n  \t\t\t\t\tif (ractive.component && (_name = ractive.component.name)) {\n  \t\t\t\t\t\tmessage = \"<\" + _name + \"> \" + message;\n  \t\t\t\t\t}\n\n  \t\t\t\t\tvar node = undefined;\n  \t\t\t\t\tif (node = options.node || ractive.fragment && ractive.fragment.rendered && ractive.find(\"*\")) {\n  \t\t\t\t\t\targs.push(node);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tconsole.warn.apply(console, [\"%cRactive.js: %c\" + message, \"color: rgb(114, 157, 52);\", \"color: rgb(85, 85, 85);\"].concat(args));\n  \t\t};\n\n  \t\tlog = function () {\n  \t\t\tconsole.log.apply(console, arguments);\n  \t\t};\n  \t})();\n  } else {\n  \tprintWarning = log = welcome = noop;\n  }\n\n  function format(message, args) {\n  \treturn message.replace(/%s/g, function () {\n  \t\treturn args.shift();\n  \t});\n  }\n\n  function fatal(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tthrow new Error(message);\n  }\n\n  function logIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\tlog.apply(null, arguments);\n  \t}\n  }\n\n  function warn(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n  \tprintWarning(message, args);\n  }\n\n  function warnOnce(message) {\n  \tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\targs[_key - 1] = arguments[_key];\n  \t}\n\n  \tmessage = format(message, args);\n\n  \tif (alreadyWarned[message]) {\n  \t\treturn;\n  \t}\n\n  \talreadyWarned[message] = true;\n  \tprintWarning(message, args);\n  }\n\n  function warnIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarn.apply(null, arguments);\n  \t}\n  }\n\n  function warnOnceIfDebug() {\n  \tif (_Ractive.DEBUG) {\n  \t\twarnOnce.apply(null, arguments);\n  \t}\n  }\n\n  // Error messages that are used (or could be) in multiple places\n  var badArguments = \"Bad arguments\";\n  var noRegistryFunctionReturn = \"A function was specified for \\\"%s\\\" %s, but no %s was returned\";\n  var missingPlugin = function (name, type) {\n    return \"Missing \\\"\" + name + \"\\\" \" + type + \" plugin. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#\" + type + \"s\";\n  };\n\n  function findInViewHierarchy(registryName, ractive, name) {\n  \tvar instance = findInstance(registryName, ractive, name);\n  \treturn instance ? instance[registryName][name] : null;\n  }\n\n  function findInstance(registryName, ractive, name) {\n  \twhile (ractive) {\n  \t\tif (name in ractive[registryName]) {\n  \t\t\treturn ractive;\n  \t\t}\n\n  \t\tif (ractive.isolated) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tractive = ractive.parent;\n  \t}\n  }\n\n  var interpolate = function (from, to, ractive, type) {\n  \tif (from === to) {\n  \t\treturn snap(to);\n  \t}\n\n  \tif (type) {\n\n  \t\tvar interpol = findInViewHierarchy(\"interpolators\", ractive, type);\n  \t\tif (interpol) {\n  \t\t\treturn interpol(from, to) || snap(to);\n  \t\t}\n\n  \t\tfatal(missingPlugin(type, \"interpolator\"));\n  \t}\n\n  \treturn static_interpolators.number(from, to) || static_interpolators.array(from, to) || static_interpolators.object(from, to) || snap(to);\n  };\n\n  var shared_interpolate = interpolate;\n\n  function snap(to) {\n  \treturn function () {\n  \t\treturn to;\n  \t};\n  }\n\n  var interpolators = {\n  \tnumber: function (from, to) {\n  \t\tvar delta;\n\n  \t\tif (!is__isNumeric(from) || !is__isNumeric(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tfrom = +from;\n  \t\tto = +to;\n\n  \t\tdelta = to - from;\n\n  \t\tif (!delta) {\n  \t\t\treturn function () {\n  \t\t\t\treturn from;\n  \t\t\t};\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\treturn from + t * delta;\n  \t\t};\n  \t},\n\n  \tarray: function (from, to) {\n  \t\tvar intermediate, interpolators, len, i;\n\n  \t\tif (!isArray(from) || !isArray(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tintermediate = [];\n  \t\tinterpolators = [];\n\n  \t\ti = len = Math.min(from.length, to.length);\n  \t\twhile (i--) {\n  \t\t\tinterpolators[i] = shared_interpolate(from[i], to[i]);\n  \t\t}\n\n  \t\t// surplus values - don't interpolate, but don't exclude them either\n  \t\tfor (i = len; i < from.length; i += 1) {\n  \t\t\tintermediate[i] = from[i];\n  \t\t}\n\n  \t\tfor (i = len; i < to.length; i += 1) {\n  \t\t\tintermediate[i] = to[i];\n  \t\t}\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tintermediate[i] = interpolators[i](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t},\n\n  \tobject: function (from, to) {\n  \t\tvar properties, len, interpolators, intermediate, prop;\n\n  \t\tif (!isObject(from) || !isObject(to)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tproperties = [];\n  \t\tintermediate = {};\n  \t\tinterpolators = {};\n\n  \t\tfor (prop in from) {\n  \t\t\tif (hasOwn.call(from, prop)) {\n  \t\t\t\tif (hasOwn.call(to, prop)) {\n  \t\t\t\t\tproperties.push(prop);\n  \t\t\t\t\tinterpolators[prop] = shared_interpolate(from[prop], to[prop]);\n  \t\t\t\t} else {\n  \t\t\t\t\tintermediate[prop] = from[prop];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tfor (prop in to) {\n  \t\t\tif (hasOwn.call(to, prop) && !hasOwn.call(from, prop)) {\n  \t\t\t\tintermediate[prop] = to[prop];\n  \t\t\t}\n  \t\t}\n\n  \t\tlen = properties.length;\n\n  \t\treturn function (t) {\n  \t\t\tvar i = len,\n  \t\t\t    prop;\n\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = properties[i];\n\n  \t\t\t\tintermediate[prop] = interpolators[prop](t);\n  \t\t\t}\n\n  \t\t\treturn intermediate;\n  \t\t};\n  \t}\n  };\n\n  var static_interpolators = interpolators;\n\n  // This function takes a keypath such as 'foo.bar.baz', and returns\n  // all the variants of that keypath that include a wildcard in place\n  // of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.\n  // These are then checked against the dependants map (ractive.viewmodel.depsMap)\n  // to see if any pattern observers are downstream of one or more of\n  // these wildcard keypaths (e.g. 'foo.bar.*.status')\n  var utils_getPotentialWildcardMatches = getPotentialWildcardMatches;\n\n  var starMaps = {};\n  function getPotentialWildcardMatches(keypath) {\n  \tvar keys, starMap, mapper, i, result, wildcardKeypath;\n\n  \tkeys = keypath.split(\".\");\n  \tif (!(starMap = starMaps[keys.length])) {\n  \t\tstarMap = getStarMap(keys.length);\n  \t}\n\n  \tresult = [];\n\n  \tmapper = function (star, i) {\n  \t\treturn star ? \"*\" : keys[i];\n  \t};\n\n  \ti = starMap.length;\n  \twhile (i--) {\n  \t\twildcardKeypath = starMap[i].map(mapper).join(\".\");\n\n  \t\tif (!result.hasOwnProperty(wildcardKeypath)) {\n  \t\t\tresult.push(wildcardKeypath);\n  \t\t\tresult[wildcardKeypath] = true;\n  \t\t}\n  \t}\n\n  \treturn result;\n  }\n\n  // This function returns all the possible true/false combinations for\n  // a given number - e.g. for two, the possible combinations are\n  // [ true, true ], [ true, false ], [ false, true ], [ false, false ].\n  // It does so by getting all the binary values between 0 and e.g. 11\n  function getStarMap(num) {\n  \tvar ones = \"\",\n  \t    max,\n  \t    binary,\n  \t    starMap,\n  \t    mapper,\n  \t    i,\n  \t    j,\n  \t    l,\n  \t    map;\n\n  \tif (!starMaps[num]) {\n  \t\tstarMap = [];\n\n  \t\twhile (ones.length < num) {\n  \t\t\tones += 1;\n  \t\t}\n\n  \t\tmax = parseInt(ones, 2);\n\n  \t\tmapper = function (digit) {\n  \t\t\treturn digit === \"1\";\n  \t\t};\n\n  \t\tfor (i = 0; i <= max; i += 1) {\n  \t\t\tbinary = i.toString(2);\n  \t\t\twhile (binary.length < num) {\n  \t\t\t\tbinary = \"0\" + binary;\n  \t\t\t}\n\n  \t\t\tmap = [];\n  \t\t\tl = binary.length;\n  \t\t\tfor (j = 0; j < l; j++) {\n  \t\t\t\tmap.push(mapper(binary[j]));\n  \t\t\t}\n  \t\t\tstarMap[i] = map;\n  \t\t}\n\n  \t\tstarMaps[num] = starMap;\n  \t}\n\n  \treturn starMaps[num];\n  }\n\n  var refPattern = /\\[\\s*(\\*|[0-9]|[1-9][0-9]+)\\s*\\]/g;\n  var patternPattern = /\\*/;\n  var keypathCache = {};\n\n  var Keypath = function (str) {\n  \tvar keys = str.split(\".\");\n\n  \tthis.str = str;\n\n  \tif (str[0] === \"@\") {\n  \t\tthis.isSpecial = true;\n  \t\tthis.value = decodeKeypath(str);\n  \t}\n\n  \tthis.firstKey = keys[0];\n  \tthis.lastKey = keys.pop();\n\n  \tthis.isPattern = patternPattern.test(str);\n\n  \tthis.parent = str === \"\" ? null : getKeypath(keys.join(\".\"));\n  \tthis.isRoot = !str;\n  };\n\n  Keypath.prototype = {\n  \tequalsOrStartsWith: function (keypath) {\n  \t\treturn keypath === this || this.startsWith(keypath);\n  \t},\n\n  \tjoin: function (str) {\n  \t\treturn getKeypath(this.isRoot ? String(str) : this.str + \".\" + str);\n  \t},\n\n  \treplace: function (oldKeypath, newKeypath) {\n  \t\tif (this === oldKeypath) {\n  \t\t\treturn newKeypath;\n  \t\t}\n\n  \t\tif (this.startsWith(oldKeypath)) {\n  \t\t\treturn newKeypath === null ? newKeypath : getKeypath(this.str.replace(oldKeypath.str + \".\", newKeypath.str + \".\"));\n  \t\t}\n  \t},\n\n  \tstartsWith: function (keypath) {\n  \t\tif (!keypath) {\n  \t\t\t// TODO under what circumstances does this happen?\n  \t\t\treturn false;\n  \t\t}\n\n  \t\treturn keypath && this.str.substr(0, keypath.str.length + 1) === keypath.str + \".\";\n  \t},\n\n  \ttoString: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \tvalueOf: function () {\n  \t\tthrow new Error(\"Bad coercion\");\n  \t},\n\n  \twildcardMatches: function () {\n  \t\treturn this._wildcardMatches || (this._wildcardMatches = utils_getPotentialWildcardMatches(this.str));\n  \t}\n  };\n  function assignNewKeypath(target, property, oldKeypath, newKeypath) {\n  \tvar existingKeypath = target[property];\n\n  \tif (existingKeypath && (existingKeypath.equalsOrStartsWith(newKeypath) || !existingKeypath.equalsOrStartsWith(oldKeypath))) {\n  \t\treturn;\n  \t}\n\n  \ttarget[property] = existingKeypath ? existingKeypath.replace(oldKeypath, newKeypath) : newKeypath;\n  \treturn true;\n  }\n\n  function decodeKeypath(keypath) {\n  \tvar value = keypath.slice(2);\n\n  \tif (keypath[1] === \"i\") {\n  \t\treturn is__isNumeric(value) ? +value : value;\n  \t} else {\n  \t\treturn value;\n  \t}\n  }\n\n  function getKeypath(str) {\n  \tif (str == null) {\n  \t\treturn str;\n  \t}\n\n  \t// TODO it *may* be worth having two versions of this function - one where\n  \t// keypathCache inherits from null, and one for IE8. Depends on how\n  \t// much of an overhead hasOwnProperty is - probably negligible\n  \tif (!keypathCache.hasOwnProperty(str)) {\n  \t\tkeypathCache[str] = new Keypath(str);\n  \t}\n\n  \treturn keypathCache[str];\n  }\n\n  function getMatchingKeypaths(ractive, keypath) {\n  \tvar keys, key, matchingKeypaths;\n\n  \tkeys = keypath.str.split(\".\");\n  \tmatchingKeypaths = [rootKeypath];\n\n  \twhile (key = keys.shift()) {\n  \t\tif (key === \"*\") {\n  \t\t\t// expand to find all valid child keypaths\n  \t\t\tmatchingKeypaths = matchingKeypaths.reduce(expand, []);\n  \t\t} else {\n  \t\t\tif (matchingKeypaths[0] === rootKeypath) {\n  \t\t\t\t// first key\n  \t\t\t\tmatchingKeypaths[0] = getKeypath(key);\n  \t\t\t} else {\n  \t\t\t\tmatchingKeypaths = matchingKeypaths.map(concatenate(key));\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn matchingKeypaths;\n\n  \tfunction expand(matchingKeypaths, keypath) {\n  \t\tvar wrapper, value, keys;\n\n  \t\tif (keypath.isRoot) {\n  \t\t\tkeys = [].concat(Object.keys(ractive.viewmodel.data), Object.keys(ractive.viewmodel.mappings), Object.keys(ractive.viewmodel.computations));\n  \t\t} else {\n  \t\t\twrapper = ractive.viewmodel.wrapped[keypath.str];\n  \t\t\tvalue = wrapper ? wrapper.get() : ractive.viewmodel.get(keypath);\n\n  \t\t\tkeys = value ? Object.keys(value) : null;\n  \t\t}\n\n  \t\tif (keys) {\n  \t\t\tkeys.forEach(function (key) {\n  \t\t\t\tif (key !== \"_ractive\" || !isArray(value)) {\n  \t\t\t\t\tmatchingKeypaths.push(keypath.join(key));\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n\n  \t\treturn matchingKeypaths;\n  \t}\n  }\n\n  function concatenate(key) {\n  \treturn function (keypath) {\n  \t\treturn keypath.join(key);\n  \t};\n  }\n  function normalise(ref) {\n  \treturn ref ? ref.replace(refPattern, \".$1\") : \"\";\n  }\n\n  var rootKeypath = getKeypath(\"\");\n\n  var shared_add = add;\n  var shared_add__errorMessage = \"Cannot add to a non-numeric value\";\n  function add(root, keypath, d) {\n  \tif (typeof keypath !== \"string\" || !is__isNumeric(d)) {\n  \t\tthrow new Error(\"Bad arguments\");\n  \t}\n\n  \tvar value = undefined,\n  \t    changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(root, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tvar value = root.viewmodel.get(keypath);\n\n  \t\t\tif (!is__isNumeric(value)) {\n  \t\t\t\tthrow new Error(shared_add__errorMessage);\n  \t\t\t}\n\n  \t\t\tchanges[keypath.str] = value + d;\n  \t\t});\n\n  \t\treturn root.set(changes);\n  \t}\n\n  \tvalue = root.get(keypath);\n\n  \tif (!is__isNumeric(value)) {\n  \t\tthrow new Error(shared_add__errorMessage);\n  \t}\n\n  \treturn root.set(keypath, +value + d);\n  }\n\n  var prototype_add = Ractive$add;\n  function Ractive$add(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? 1 : +d);\n  }\n\n  var requestAnimationFrame;\n\n  // If window doesn't exist, we don't need requestAnimationFrame\n  if (typeof window === \"undefined\") {\n  \trequestAnimationFrame = null;\n  } else {\n  \t// https://gist.github.com/paulirish/1579671\n  \t(function (vendors, lastTime, window) {\n\n  \t\tvar x, setTimeout;\n\n  \t\tif (window.requestAnimationFrame) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfor (x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n  \t\t\twindow.requestAnimationFrame = window[vendors[x] + \"RequestAnimationFrame\"];\n  \t\t}\n\n  \t\tif (!window.requestAnimationFrame) {\n  \t\t\tsetTimeout = window.setTimeout;\n\n  \t\t\twindow.requestAnimationFrame = function (callback) {\n  \t\t\t\tvar currTime, timeToCall, id;\n\n  \t\t\t\tcurrTime = Date.now();\n  \t\t\t\ttimeToCall = Math.max(0, 16 - (currTime - lastTime));\n  \t\t\t\tid = setTimeout(function () {\n  \t\t\t\t\tcallback(currTime + timeToCall);\n  \t\t\t\t}, timeToCall);\n\n  \t\t\t\tlastTime = currTime + timeToCall;\n  \t\t\t\treturn id;\n  \t\t\t};\n  \t\t}\n  \t})(vendors, 0, window);\n\n  \trequestAnimationFrame = window.requestAnimationFrame;\n  }\n\n  var rAF = requestAnimationFrame;\n\n  var getTime;\n\n  if (typeof window !== \"undefined\" && window.performance && typeof window.performance.now === \"function\") {\n  \tgetTime = function () {\n  \t\treturn window.performance.now();\n  \t};\n  } else {\n  \tgetTime = function () {\n  \t\treturn Date.now();\n  \t};\n  }\n\n  var utils_getTime = getTime;\n\n  var deprecations = {\n  \tconstruct: {\n  \t\tdeprecated: \"beforeInit\",\n  \t\treplacement: \"onconstruct\"\n  \t},\n  \trender: {\n  \t\tdeprecated: \"init\",\n  \t\tmessage: \"The \\\"init\\\" method has been deprecated \" + \"and will likely be removed in a future release. \" + \"You can either use the \\\"oninit\\\" method which will fire \" + \"only once prior to, and regardless of, any eventual ractive \" + \"instance being rendered, or if you need to access the \" + \"rendered DOM, use \\\"onrender\\\" instead. \" + \"See http://docs.ractivejs.org/latest/migrating for more information.\"\n  \t},\n  \tcomplete: {\n  \t\tdeprecated: \"complete\",\n  \t\treplacement: \"oncomplete\"\n  \t}\n  };\n\n  function Hook(event) {\n  \tthis.event = event;\n  \tthis.method = \"on\" + event;\n  \tthis.deprecate = deprecations[event];\n  }\n\n  Hook.prototype.fire = function (ractive, arg) {\n  \tfunction call(method) {\n  \t\tif (ractive[method]) {\n  \t\t\targ ? ractive[method](arg) : ractive[method]();\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \tcall(this.method);\n\n  \tif (!ractive[this.method] && this.deprecate && call(this.deprecate.deprecated)) {\n  \t\tif (this.deprecate.message) {\n  \t\t\twarnIfDebug(this.deprecate.message);\n  \t\t} else {\n  \t\t\twarnIfDebug(\"The method \\\"%s\\\" has been deprecated in favor of \\\"%s\\\" and will likely be removed in a future release. See http://docs.ractivejs.org/latest/migrating for more information.\", this.deprecate.deprecated, this.deprecate.replacement);\n  \t\t}\n  \t}\n\n  \targ ? ractive.fire(this.event, arg) : ractive.fire(this.event);\n  };\n\n  var hooks_Hook = Hook;\n\n  function addToArray(array, value) {\n  \tvar index = array.indexOf(value);\n\n  \tif (index === -1) {\n  \t\tarray.push(value);\n  \t}\n  }\n\n  function arrayContains(array, value) {\n  \tfor (var i = 0, c = array.length; i < c; i++) {\n  \t\tif (array[i] == value) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n\n  \treturn false;\n  }\n\n  function arrayContentsMatch(a, b) {\n  \tvar i;\n\n  \tif (!isArray(a) || !isArray(b)) {\n  \t\treturn false;\n  \t}\n\n  \tif (a.length !== b.length) {\n  \t\treturn false;\n  \t}\n\n  \ti = a.length;\n  \twhile (i--) {\n  \t\tif (a[i] !== b[i]) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  function ensureArray(x) {\n  \tif (typeof x === \"string\") {\n  \t\treturn [x];\n  \t}\n\n  \tif (x === undefined) {\n  \t\treturn [];\n  \t}\n\n  \treturn x;\n  }\n\n  function lastItem(array) {\n  \treturn array[array.length - 1];\n  }\n\n  function removeFromArray(array, member) {\n  \tvar index = array.indexOf(member);\n\n  \tif (index !== -1) {\n  \t\tarray.splice(index, 1);\n  \t}\n  }\n\n  function toArray(arrayLike) {\n  \tvar array = [],\n  \t    i = arrayLike.length;\n  \twhile (i--) {\n  \t\tarray[i] = arrayLike[i];\n  \t}\n\n  \treturn array;\n  }\n\n  var _Promise,\n      PENDING = {},\n      FULFILLED = {},\n      REJECTED = {};\n\n  if (typeof Promise === \"function\") {\n  \t// use native Promise\n  \t_Promise = Promise;\n  } else {\n  \t_Promise = function (callback) {\n  \t\tvar fulfilledHandlers = [],\n  \t\t    rejectedHandlers = [],\n  \t\t    state = PENDING,\n  \t\t    result,\n  \t\t    dispatchHandlers,\n  \t\t    makeResolver,\n  \t\t    fulfil,\n  \t\t    reject,\n  \t\t    promise;\n\n  \t\tmakeResolver = function (newState) {\n  \t\t\treturn function (value) {\n  \t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tresult = value;\n  \t\t\t\tstate = newState;\n\n  \t\t\t\tdispatchHandlers = makeDispatcher(state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result);\n\n  \t\t\t\t// dispatch onFulfilled and onRejected handlers asynchronously\n  \t\t\t\twait(dispatchHandlers);\n  \t\t\t};\n  \t\t};\n\n  \t\tfulfil = makeResolver(FULFILLED);\n  \t\treject = makeResolver(REJECTED);\n\n  \t\ttry {\n  \t\t\tcallback(fulfil, reject);\n  \t\t} catch (err) {\n  \t\t\treject(err);\n  \t\t}\n\n  \t\tpromise = {\n  \t\t\t// `then()` returns a Promise - 2.2.7\n  \t\t\tthen: function (onFulfilled, onRejected) {\n  \t\t\t\tvar promise2 = new _Promise(function (fulfil, reject) {\n\n  \t\t\t\t\tvar processResolutionHandler = function (handler, handlers, forward) {\n\n  \t\t\t\t\t\t// 2.2.1.1\n  \t\t\t\t\t\tif (typeof handler === \"function\") {\n  \t\t\t\t\t\t\thandlers.push(function (p1result) {\n  \t\t\t\t\t\t\t\tvar x;\n\n  \t\t\t\t\t\t\t\ttry {\n  \t\t\t\t\t\t\t\t\tx = handler(p1result);\n  \t\t\t\t\t\t\t\t\tutils_Promise__resolve(promise2, x, fulfil, reject);\n  \t\t\t\t\t\t\t\t} catch (err) {\n  \t\t\t\t\t\t\t\t\treject(err);\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t});\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t// Forward the result of promise1 to promise2, if resolution handlers\n  \t\t\t\t\t\t\t// are not given\n  \t\t\t\t\t\t\thandlers.push(forward);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t};\n\n  \t\t\t\t\t// 2.2\n  \t\t\t\t\tprocessResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);\n  \t\t\t\t\tprocessResolutionHandler(onRejected, rejectedHandlers, reject);\n\n  \t\t\t\t\tif (state !== PENDING) {\n  \t\t\t\t\t\t// If the promise has resolved already, dispatch the appropriate handlers asynchronously\n  \t\t\t\t\t\twait(dispatchHandlers);\n  \t\t\t\t\t}\n  \t\t\t\t});\n\n  \t\t\t\treturn promise2;\n  \t\t\t}\n  \t\t};\n\n  \t\tpromise[\"catch\"] = function (onRejected) {\n  \t\t\treturn this.then(null, onRejected);\n  \t\t};\n\n  \t\treturn promise;\n  \t};\n\n  \t_Promise.all = function (promises) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\tvar result = [],\n  \t\t\t    pending,\n  \t\t\t    i,\n  \t\t\t    processPromise;\n\n  \t\t\tif (!promises.length) {\n  \t\t\t\tfulfil(result);\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tprocessPromise = function (promise, i) {\n  \t\t\t\tif (promise && typeof promise.then === \"function\") {\n  \t\t\t\t\tpromise.then(function (value) {\n  \t\t\t\t\t\tresult[i] = value;\n  \t\t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t\t}, reject);\n  \t\t\t\t} else {\n  \t\t\t\t\tresult[i] = promise;\n  \t\t\t\t\t--pending || fulfil(result);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tpending = i = promises.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprocessPromise(promises[i], i);\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \t_Promise.resolve = function (value) {\n  \t\treturn new _Promise(function (fulfil) {\n  \t\t\tfulfil(value);\n  \t\t});\n  \t};\n\n  \t_Promise.reject = function (reason) {\n  \t\treturn new _Promise(function (fulfil, reject) {\n  \t\t\treject(reason);\n  \t\t});\n  \t};\n  }\n\n  var utils_Promise = _Promise;\n\n  // TODO use MutationObservers or something to simulate setImmediate\n  function wait(callback) {\n  \tsetTimeout(callback, 0);\n  }\n\n  function makeDispatcher(handlers, result) {\n  \treturn function () {\n  \t\tvar handler;\n\n  \t\twhile (handler = handlers.shift()) {\n  \t\t\thandler(result);\n  \t\t}\n  \t};\n  }\n\n  function utils_Promise__resolve(promise, x, fulfil, reject) {\n  \t// Promise Resolution Procedure\n  \tvar then;\n\n  \t// 2.3.1\n  \tif (x === promise) {\n  \t\tthrow new TypeError(\"A promise's fulfillment handler cannot return the same promise\");\n  \t}\n\n  \t// 2.3.2\n  \tif (x instanceof _Promise) {\n  \t\tx.then(fulfil, reject);\n  \t}\n\n  \t// 2.3.3\n  \telse if (x && (typeof x === \"object\" || typeof x === \"function\")) {\n  \t\ttry {\n  \t\t\tthen = x.then; // 2.3.3.1\n  \t\t} catch (e) {\n  \t\t\treject(e); // 2.3.3.2\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// 2.3.3.3\n  \t\tif (typeof then === \"function\") {\n  \t\t\tvar called, resolvePromise, rejectPromise;\n\n  \t\t\tresolvePromise = function (y) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\tutils_Promise__resolve(promise, y, fulfil, reject);\n  \t\t\t};\n\n  \t\t\trejectPromise = function (r) {\n  \t\t\t\tif (called) {\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t\tcalled = true;\n  \t\t\t\treject(r);\n  \t\t\t};\n\n  \t\t\ttry {\n  \t\t\t\tthen.call(x, resolvePromise, rejectPromise);\n  \t\t\t} catch (e) {\n  \t\t\t\tif (!called) {\n  \t\t\t\t\t// 2.3.3.3.4.1\n  \t\t\t\t\treject(e); // 2.3.3.3.4.2\n  \t\t\t\t\tcalled = true;\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tfulfil(x);\n  \t\t}\n  \t} else {\n  \t\tfulfil(x);\n  \t}\n  }\n\n  var getInnerContext = function (fragment) {\n  \tdo {\n  \t\tif (fragment.context !== undefined) {\n  \t\t\treturn fragment.context;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn rootKeypath;\n  };\n\n  var shared_resolveRef = resolveRef;\n\n  function resolveRef(ractive, ref, fragment) {\n  \tvar keypath;\n\n  \tref = normalise(ref);\n\n  \t// If a reference begins '~/', it's a top-level reference\n  \tif (ref.substr(0, 2) === \"~/\") {\n  \t\tkeypath = getKeypath(ref.substring(2));\n  \t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t}\n\n  \t// If a reference begins with '.', it's either a restricted reference or\n  \t// an ancestor reference...\n  \telse if (ref[0] === \".\") {\n  \t\tkeypath = resolveAncestorRef(getInnerContext(fragment), ref);\n\n  \t\tif (keypath) {\n  \t\t\tcreateMappingIfNecessary(ractive, keypath.firstKey, fragment);\n  \t\t}\n  \t}\n\n  \t// ...otherwise we need to figure out the keypath based on context\n  \telse {\n  \t\tkeypath = resolveAmbiguousReference(ractive, getKeypath(ref), fragment);\n  \t}\n\n  \treturn keypath;\n  }\n\n  function resolveAncestorRef(baseContext, ref) {\n  \tvar contextKeys;\n\n  \t// TODO...\n  \tif (baseContext != undefined && typeof baseContext !== \"string\") {\n  \t\tbaseContext = baseContext.str;\n  \t}\n\n  \t// {{.}} means 'current context'\n  \tif (ref === \".\") return getKeypath(baseContext);\n\n  \tcontextKeys = baseContext ? baseContext.split(\".\") : [];\n\n  \t// ancestor references (starting \"../\") go up the tree\n  \tif (ref.substr(0, 3) === \"../\") {\n  \t\twhile (ref.substr(0, 3) === \"../\") {\n  \t\t\tif (!contextKeys.length) {\n  \t\t\t\tthrow new Error(\"Could not resolve reference - too many \\\"../\\\" prefixes\");\n  \t\t\t}\n\n  \t\t\tcontextKeys.pop();\n  \t\t\tref = ref.substring(3);\n  \t\t}\n\n  \t\tcontextKeys.push(ref);\n  \t\treturn getKeypath(contextKeys.join(\".\"));\n  \t}\n\n  \t// not an ancestor reference - must be a restricted reference (prepended with \".\" or \"./\")\n  \tif (!baseContext) {\n  \t\treturn getKeypath(ref.replace(/^\\.\\/?/, \"\"));\n  \t}\n\n  \treturn getKeypath(baseContext + ref.replace(/^\\.\\//, \".\"));\n  }\n\n  function resolveAmbiguousReference(ractive, ref, fragment, isParentLookup) {\n  \tvar context, key, parentValue, hasContextChain, parentKeypath;\n\n  \tif (ref.isRoot) {\n  \t\treturn ref;\n  \t}\n\n  \tkey = ref.firstKey;\n\n  \twhile (fragment) {\n  \t\tcontext = fragment.context;\n  \t\tfragment = fragment.parent;\n\n  \t\tif (!context) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\thasContextChain = true;\n  \t\tparentValue = ractive.viewmodel.get(context);\n\n  \t\tif (parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\") && key in parentValue) {\n  \t\t\treturn context.join(ref.str);\n  \t\t}\n  \t}\n\n  \t// Root/computed/mapped property?\n  \tif (isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn ref;\n  \t}\n\n  \t// If this is an inline component, and it's not isolated, we\n  \t// can try going up the scope chain\n  \tif (ractive.parent && !ractive.isolated) {\n  \t\thasContextChain = true;\n  \t\tfragment = ractive.component.parentFragment;\n\n  \t\tkey = getKeypath(key);\n\n  \t\tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, fragment, true)) {\n  \t\t\t// We need to create an inter-component binding\n  \t\t\tractive.viewmodel.map(key, {\n  \t\t\t\torigin: ractive.parent.viewmodel,\n  \t\t\t\tkeypath: parentKeypath\n  \t\t\t});\n\n  \t\t\treturn ref;\n  \t\t}\n  \t}\n\n  \t// If there's no context chain, and the instance is either a) isolated or\n  \t// b) an orphan, then we know that the keypath is identical to the reference\n  \tif (!isParentLookup && !hasContextChain) {\n  \t\t// the data object needs to have a property by this name,\n  \t\t// to prevent future failed lookups\n  \t\tractive.viewmodel.set(ref, undefined);\n  \t\treturn ref;\n  \t}\n  }\n\n  function createMappingIfNecessary(ractive, key) {\n  \tvar parentKeypath;\n\n  \tif (!ractive.parent || ractive.isolated || isRootProperty(ractive.viewmodel, key)) {\n  \t\treturn;\n  \t}\n\n  \tkey = getKeypath(key);\n\n  \tif (parentKeypath = resolveAmbiguousReference(ractive.parent, key, ractive.component.parentFragment, true)) {\n  \t\tractive.viewmodel.map(key, {\n  \t\t\torigin: ractive.parent.viewmodel,\n  \t\t\tkeypath: parentKeypath\n  \t\t});\n  \t}\n  }\n\n  function isRootProperty(viewmodel, key) {\n  \t// special case for reference to root\n  \treturn key === \"\" || key in viewmodel.data || key in viewmodel.computations || key in viewmodel.mappings;\n  }\n\n  function teardown(x) {\n    x.teardown();\n  }\n\n  function methodCallers__unbind(x) {\n    x.unbind();\n  }\n\n  function methodCallers__unrender(x) {\n    x.unrender();\n  }\n\n  function cancel(x) {\n    x.cancel();\n  }\n\n  var TransitionManager = function (callback, parent) {\n  \tthis.callback = callback;\n  \tthis.parent = parent;\n\n  \tthis.intros = [];\n  \tthis.outros = [];\n\n  \tthis.children = [];\n  \tthis.totalChildren = this.outroChildren = 0;\n\n  \tthis.detachQueue = [];\n  \tthis.decoratorQueue = [];\n  \tthis.outrosComplete = false;\n\n  \tif (parent) {\n  \t\tparent.addChild(this);\n  \t}\n  };\n\n  TransitionManager.prototype = {\n  \taddChild: function (child) {\n  \t\tthis.children.push(child);\n\n  \t\tthis.totalChildren += 1;\n  \t\tthis.outroChildren += 1;\n  \t},\n\n  \tdecrementOutros: function () {\n  \t\tthis.outroChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tdecrementTotal: function () {\n  \t\tthis.totalChildren -= 1;\n  \t\tcheck(this);\n  \t},\n\n  \tadd: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tlist.push(transition);\n  \t},\n\n  \taddDecorator: function (decorator) {\n  \t\tthis.decoratorQueue.push(decorator);\n  \t},\n\n  \tremove: function (transition) {\n  \t\tvar list = transition.isIntro ? this.intros : this.outros;\n  \t\tremoveFromArray(list, transition);\n  \t\tcheck(this);\n  \t},\n\n  \tinit: function () {\n  \t\tthis.ready = true;\n  \t\tcheck(this);\n  \t},\n\n  \tdetachNodes: function () {\n  \t\tthis.decoratorQueue.forEach(teardown);\n  \t\tthis.detachQueue.forEach(detach);\n  \t\tthis.children.forEach(detachNodes);\n  \t}\n  };\n\n  function detach(element) {\n  \telement.detach();\n  }\n\n  function detachNodes(tm) {\n  \ttm.detachNodes();\n  }\n\n  function check(tm) {\n  \tif (!tm.ready || tm.outros.length || tm.outroChildren) return;\n\n  \t// If all outros are complete, and we haven't already done this,\n  \t// we notify the parent if there is one, otherwise\n  \t// start detaching nodes\n  \tif (!tm.outrosComplete) {\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementOutros(tm);\n  \t\t} else {\n  \t\t\ttm.detachNodes();\n  \t\t}\n\n  \t\ttm.outrosComplete = true;\n  \t}\n\n  \t// Once everything is done, we can notify parent transition\n  \t// manager and call the callback\n  \tif (!tm.intros.length && !tm.totalChildren) {\n  \t\tif (typeof tm.callback === \"function\") {\n  \t\t\ttm.callback();\n  \t\t}\n\n  \t\tif (tm.parent) {\n  \t\t\ttm.parent.decrementTotal();\n  \t\t}\n  \t}\n  }\n\n  var global_TransitionManager = TransitionManager;\n\n  var batch,\n      runloop,\n      unresolved = [],\n      changeHook = new hooks_Hook(\"change\");\n\n  runloop = {\n  \tstart: function (instance, returnPromise) {\n  \t\tvar promise, fulfilPromise;\n\n  \t\tif (returnPromise) {\n  \t\t\tpromise = new utils_Promise(function (f) {\n  \t\t\t\treturn fulfilPromise = f;\n  \t\t\t});\n  \t\t}\n\n  \t\tbatch = {\n  \t\t\tpreviousBatch: batch,\n  \t\t\ttransitionManager: new global_TransitionManager(fulfilPromise, batch && batch.transitionManager),\n  \t\t\tviews: [],\n  \t\t\ttasks: [],\n  \t\t\tractives: [],\n  \t\t\tinstance: instance\n  \t\t};\n\n  \t\tif (instance) {\n  \t\t\tbatch.ractives.push(instance);\n  \t\t}\n\n  \t\treturn promise;\n  \t},\n\n  \tend: function () {\n  \t\tflushChanges();\n\n  \t\tbatch.transitionManager.init();\n  \t\tif (!batch.previousBatch && !!batch.instance) batch.instance.viewmodel.changes = [];\n  \t\tbatch = batch.previousBatch;\n  \t},\n\n  \taddRactive: function (ractive) {\n  \t\tif (batch) {\n  \t\t\taddToArray(batch.ractives, ractive);\n  \t\t}\n  \t},\n\n  \tregisterTransition: function (transition) {\n  \t\ttransition._manager = batch.transitionManager;\n  \t\tbatch.transitionManager.add(transition);\n  \t},\n\n  \tregisterDecorator: function (decorator) {\n  \t\tbatch.transitionManager.addDecorator(decorator);\n  \t},\n\n  \taddView: function (view) {\n  \t\tbatch.views.push(view);\n  \t},\n\n  \taddUnresolved: function (thing) {\n  \t\tunresolved.push(thing);\n  \t},\n\n  \tremoveUnresolved: function (thing) {\n  \t\tremoveFromArray(unresolved, thing);\n  \t},\n\n  \t// synchronise node detachments with transition ends\n  \tdetachWhenReady: function (thing) {\n  \t\tbatch.transitionManager.detachQueue.push(thing);\n  \t},\n\n  \tscheduleTask: function (task, postRender) {\n  \t\tvar _batch;\n\n  \t\tif (!batch) {\n  \t\t\ttask();\n  \t\t} else {\n  \t\t\t_batch = batch;\n  \t\t\twhile (postRender && _batch.previousBatch) {\n  \t\t\t\t// this can't happen until the DOM has been fully updated\n  \t\t\t\t// otherwise in some situations (with components inside elements)\n  \t\t\t\t// transitions and decorators will initialise prematurely\n  \t\t\t\t_batch = _batch.previousBatch;\n  \t\t\t}\n\n  \t\t\t_batch.tasks.push(task);\n  \t\t}\n  \t}\n  };\n\n  var global_runloop = runloop;\n\n  function flushChanges() {\n  \tvar i, thing, changeHash;\n\n  \twhile (batch.ractives.length) {\n  \t\tthing = batch.ractives.pop();\n  \t\tchangeHash = thing.viewmodel.applyChanges();\n\n  \t\tif (changeHash) {\n  \t\t\tchangeHook.fire(thing, changeHash);\n  \t\t}\n  \t}\n\n  \tattemptKeypathResolution();\n\n  \t// Now that changes have been fully propagated, we can update the DOM\n  \t// and complete other tasks\n  \tfor (i = 0; i < batch.views.length; i += 1) {\n  \t\tbatch.views[i].update();\n  \t}\n  \tbatch.views.length = 0;\n\n  \tfor (i = 0; i < batch.tasks.length; i += 1) {\n  \t\tbatch.tasks[i]();\n  \t}\n  \tbatch.tasks.length = 0;\n\n  \t// If updating the view caused some model blowback - e.g. a triple\n  \t// containing <option> elements caused the binding on the <select>\n  \t// to update - then we start over\n  \tif (batch.ractives.length) return flushChanges();\n  }\n\n  function attemptKeypathResolution() {\n  \tvar i, item, keypath, resolved;\n\n  \ti = unresolved.length;\n\n  \t// see if we can resolve any unresolved references\n  \twhile (i--) {\n  \t\titem = unresolved[i];\n\n  \t\tif (item.keypath) {\n  \t\t\t// it resolved some other way. TODO how? two-way binding? Seems\n  \t\t\t// weird that we'd still end up here\n  \t\t\tunresolved.splice(i, 1);\n  \t\t\tcontinue; // avoid removing the wrong thing should the next condition be true\n  \t\t}\n\n  \t\tif (keypath = shared_resolveRef(item.root, item.ref, item.parentFragment)) {\n  \t\t\t(resolved || (resolved = [])).push({\n  \t\t\t\titem: item,\n  \t\t\t\tkeypath: keypath\n  \t\t\t});\n\n  \t\t\tunresolved.splice(i, 1);\n  \t\t}\n  \t}\n\n  \tif (resolved) {\n  \t\tresolved.forEach(global_runloop__resolve);\n  \t}\n  }\n\n  function global_runloop__resolve(resolved) {\n  \tresolved.item.resolve(resolved.keypath);\n  }\n\n  var queue = [];\n\n  var animations = {\n  \ttick: function () {\n  \t\tvar i, animation, now;\n\n  \t\tnow = utils_getTime();\n\n  \t\tglobal_runloop.start();\n\n  \t\tfor (i = 0; i < queue.length; i += 1) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (!animation.tick(now)) {\n  \t\t\t\t// animation is complete, remove it from the stack, and decrement i so we don't miss one\n  \t\t\t\tqueue.splice(i--, 1);\n  \t\t\t}\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tif (queue.length) {\n  \t\t\trAF(animations.tick);\n  \t\t} else {\n  \t\t\tanimations.running = false;\n  \t\t}\n  \t},\n\n  \tadd: function (animation) {\n  \t\tqueue.push(animation);\n\n  \t\tif (!animations.running) {\n  \t\t\tanimations.running = true;\n  \t\t\trAF(animations.tick);\n  \t\t}\n  \t},\n\n  \t// TODO optimise this\n  \tabort: function (keypath, root) {\n  \t\tvar i = queue.length,\n  \t\t    animation;\n\n  \t\twhile (i--) {\n  \t\t\tanimation = queue[i];\n\n  \t\t\tif (animation.root === root && animation.keypath === keypath) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var shared_animations = animations;\n\n  var Animation = function (options) {\n  \tvar key;\n\n  \tthis.startTime = Date.now();\n\n  \t// from and to\n  \tfor (key in options) {\n  \t\tif (options.hasOwnProperty(key)) {\n  \t\t\tthis[key] = options[key];\n  \t\t}\n  \t}\n\n  \tthis.interpolator = shared_interpolate(this.from, this.to, this.root, this.interpolator);\n  \tthis.running = true;\n\n  \tthis.tick();\n  };\n\n  Animation.prototype = {\n  \ttick: function () {\n  \t\tvar elapsed, t, value, timeNow, index, keypath;\n\n  \t\tkeypath = this.keypath;\n\n  \t\tif (this.running) {\n  \t\t\ttimeNow = Date.now();\n  \t\t\telapsed = timeNow - this.startTime;\n\n  \t\t\tif (elapsed >= this.duration) {\n  \t\t\t\tif (keypath !== null) {\n  \t\t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\t\tthis.root.viewmodel.set(keypath, this.to);\n  \t\t\t\t\tglobal_runloop.end();\n  \t\t\t\t}\n\n  \t\t\t\tif (this.step) {\n  \t\t\t\t\tthis.step(1, this.to);\n  \t\t\t\t}\n\n  \t\t\t\tthis.complete(this.to);\n\n  \t\t\t\tindex = this.root._animations.indexOf(this);\n\n  \t\t\t\t// TODO investigate why this happens\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t\t\t}\n\n  \t\t\t\tthis.root._animations.splice(index, 1);\n\n  \t\t\t\tthis.running = false;\n  \t\t\t\treturn false; // remove from the stack\n  \t\t\t}\n\n  \t\t\tt = this.easing ? this.easing(elapsed / this.duration) : elapsed / this.duration;\n\n  \t\t\tif (keypath !== null) {\n  \t\t\t\tvalue = this.interpolator(t);\n  \t\t\t\tglobal_runloop.start(this.root);\n  \t\t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t\t\tglobal_runloop.end();\n  \t\t\t}\n\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(t, value);\n  \t\t\t}\n\n  \t\t\treturn true; // keep in the stack\n  \t\t}\n\n  \t\treturn false; // remove from the stack\n  \t},\n\n  \tstop: function () {\n  \t\tvar index;\n\n  \t\tthis.running = false;\n\n  \t\tindex = this.root._animations.indexOf(this);\n\n  \t\t// TODO investigate why this happens\n  \t\tif (index === -1) {\n  \t\t\twarnIfDebug(\"Animation was not found\");\n  \t\t}\n\n  \t\tthis.root._animations.splice(index, 1);\n  \t}\n  };\n\n  var animate_Animation = Animation;\n\n  var prototype_animate = Ractive$animate;\n\n  var noAnimation = { stop: noop };\n  function Ractive$animate(keypath, to, options) {\n  \tvar promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;\n\n  \tpromise = new utils_Promise(function (fulfil) {\n  \t\treturn fulfilPromise = fulfil;\n  \t});\n\n  \t// animate multiple keypaths\n  \tif (typeof keypath === \"object\") {\n  \t\toptions = to || {};\n  \t\teasing = options.easing;\n  \t\tduration = options.duration;\n\n  \t\tanimations = [];\n\n  \t\t// we don't want to pass the `step` and `complete` handlers, as they will\n  \t\t// run for each animation! So instead we'll store the handlers and create\n  \t\t// our own...\n  \t\tstep = options.step;\n  \t\tcomplete = options.complete;\n\n  \t\tif (step || complete) {\n  \t\t\tcurrentValues = {};\n\n  \t\t\toptions.step = null;\n  \t\t\toptions.complete = null;\n\n  \t\t\tmakeValueCollector = function (keypath) {\n  \t\t\t\treturn function (t, value) {\n  \t\t\t\t\tcurrentValues[keypath] = value;\n  \t\t\t\t};\n  \t\t\t};\n  \t\t}\n\n  \t\tfor (k in keypath) {\n  \t\t\tif (keypath.hasOwnProperty(k)) {\n  \t\t\t\tif (step || complete) {\n  \t\t\t\t\tcollectValue = makeValueCollector(k);\n  \t\t\t\t\toptions = { easing: easing, duration: duration };\n\n  \t\t\t\t\tif (step) {\n  \t\t\t\t\t\toptions.step = collectValue;\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\toptions.complete = complete ? collectValue : noop;\n  \t\t\t\tanimations.push(animate(this, k, keypath[k], options));\n  \t\t\t}\n  \t\t}\n\n  \t\t// Create a dummy animation, to facilitate step/complete\n  \t\t// callbacks, and Promise fulfilment\n  \t\tdummyOptions = { easing: easing, duration: duration };\n\n  \t\tif (step) {\n  \t\t\tdummyOptions.step = function (t) {\n  \t\t\t\treturn step(t, currentValues);\n  \t\t\t};\n  \t\t}\n\n  \t\tif (complete) {\n  \t\t\tpromise.then(function (t) {\n  \t\t\t\treturn complete(t, currentValues);\n  \t\t\t});\n  \t\t}\n\n  \t\tdummyOptions.complete = fulfilPromise;\n\n  \t\tdummy = animate(this, null, null, dummyOptions);\n  \t\tanimations.push(dummy);\n\n  \t\tpromise.stop = function () {\n  \t\t\tvar animation;\n\n  \t\t\twhile (animation = animations.pop()) {\n  \t\t\t\tanimation.stop();\n  \t\t\t}\n\n  \t\t\tif (dummy) {\n  \t\t\t\tdummy.stop();\n  \t\t\t}\n  \t\t};\n\n  \t\treturn promise;\n  \t}\n\n  \t// animate a single keypath\n  \toptions = options || {};\n\n  \tif (options.complete) {\n  \t\tpromise.then(options.complete);\n  \t}\n\n  \toptions.complete = fulfilPromise;\n  \tanimation = animate(this, keypath, to, options);\n\n  \tpromise.stop = function () {\n  \t\treturn animation.stop();\n  \t};\n  \treturn promise;\n  }\n\n  function animate(root, keypath, to, options) {\n  \tvar easing, duration, animation, from;\n\n  \tif (keypath) {\n  \t\tkeypath = getKeypath(normalise(keypath));\n  \t}\n\n  \tif (keypath !== null) {\n  \t\tfrom = root.viewmodel.get(keypath);\n  \t}\n\n  \t// cancel any existing animation\n  \t// TODO what about upstream/downstream keypaths?\n  \tshared_animations.abort(keypath, root);\n\n  \t// don't bother animating values that stay the same\n  \tif (isEqual(from, to)) {\n  \t\tif (options.complete) {\n  \t\t\toptions.complete(options.to);\n  \t\t}\n\n  \t\treturn noAnimation;\n  \t}\n\n  \t// easing function\n  \tif (options.easing) {\n  \t\tif (typeof options.easing === \"function\") {\n  \t\t\teasing = options.easing;\n  \t\t} else {\n  \t\t\teasing = root.easing[options.easing];\n  \t\t}\n\n  \t\tif (typeof easing !== \"function\") {\n  \t\t\teasing = null;\n  \t\t}\n  \t}\n\n  \t// duration\n  \tduration = options.duration === undefined ? 400 : options.duration;\n\n  \t// TODO store keys, use an internal set method\n  \tanimation = new animate_Animation({\n  \t\tkeypath: keypath,\n  \t\tfrom: from,\n  \t\tto: to,\n  \t\troot: root,\n  \t\tduration: duration,\n  \t\teasing: easing,\n  \t\tinterpolator: options.interpolator,\n\n  \t\t// TODO wrap callbacks if necessary, to use instance as context\n  \t\tstep: options.step,\n  \t\tcomplete: options.complete\n  \t});\n\n  \tshared_animations.add(animation);\n  \troot._animations.push(animation);\n\n  \treturn animation;\n  }\n\n  var prototype_detach = Ractive$detach;\n  var prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Ractive$detach() {\n  \tif (this.detached) {\n  \t\treturn this.detached;\n  \t}\n\n  \tif (this.el) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n  \tthis.detached = this.fragment.detach();\n  \tprototype_detach__detachHook.fire(this);\n  \treturn this.detached;\n  }\n\n  var prototype_find = Ractive$find;\n\n  function Ractive$find(selector) {\n  \tif (!this.el) {\n  \t\treturn null;\n  \t}\n\n  \treturn this.fragment.find(selector);\n  }\n\n  var test = Query$test;\n  function Query$test(item, noDirty) {\n  \tvar itemMatches;\n\n  \tif (this._isComponentQuery) {\n  \t\titemMatches = !this.selector || item.name === this.selector;\n  \t} else {\n  \t\titemMatches = item.node ? matches(item.node, this.selector) : null;\n  \t}\n\n  \tif (itemMatches) {\n  \t\tthis.push(item.node || item.instance);\n\n  \t\tif (!noDirty) {\n  \t\t\tthis._makeDirty();\n  \t\t}\n\n  \t\treturn true;\n  \t}\n  }\n\n  var makeQuery_cancel = function () {\n  \tvar liveQueries, selector, index;\n\n  \tliveQueries = this._root[this._isComponentQuery ? \"liveComponentQueries\" : \"liveQueries\"];\n  \tselector = this.selector;\n\n  \tindex = liveQueries.indexOf(selector);\n\n  \tif (index !== -1) {\n  \t\tliveQueries.splice(index, 1);\n  \t\tliveQueries[selector] = null;\n  \t}\n  };\n\n  var sortByItemPosition = function (a, b) {\n  \tvar ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;\n\n  \tancestryA = getAncestry(a.component || a._ractive.proxy);\n  \tancestryB = getAncestry(b.component || b._ractive.proxy);\n\n  \toldestA = lastItem(ancestryA);\n  \toldestB = lastItem(ancestryB);\n\n  \t// remove items from the end of both ancestries as long as they are identical\n  \t// - the final one removed is the closest mutual ancestor\n  \twhile (oldestA && oldestA === oldestB) {\n  \t\tancestryA.pop();\n  \t\tancestryB.pop();\n\n  \t\tmutualAncestor = oldestA;\n\n  \t\toldestA = lastItem(ancestryA);\n  \t\toldestB = lastItem(ancestryB);\n  \t}\n\n  \t// now that we have the mutual ancestor, we can find which is earliest\n  \toldestA = oldestA.component || oldestA;\n  \toldestB = oldestB.component || oldestB;\n\n  \tfragmentA = oldestA.parentFragment;\n  \tfragmentB = oldestB.parentFragment;\n\n  \t// if both items share a parent fragment, our job is easy\n  \tif (fragmentA === fragmentB) {\n  \t\tindexA = fragmentA.items.indexOf(oldestA);\n  \t\tindexB = fragmentB.items.indexOf(oldestB);\n\n  \t\t// if it's the same index, it means one contains the other,\n  \t\t// so we see which has the longest ancestry\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \t// if mutual ancestor is a section, we first test to see which section\n  \t// fragment comes first\n  \tif (fragments = mutualAncestor.fragments) {\n  \t\tindexA = fragments.indexOf(fragmentA);\n  \t\tindexB = fragments.indexOf(fragmentB);\n\n  \t\treturn indexA - indexB || ancestryA.length - ancestryB.length;\n  \t}\n\n  \tthrow new Error(\"An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!\");\n  };\n\n  function getParent(item) {\n  \tvar parentFragment;\n\n  \tif (parentFragment = item.parentFragment) {\n  \t\treturn parentFragment.owner;\n  \t}\n\n  \tif (item.component && (parentFragment = item.component.parentFragment)) {\n  \t\treturn parentFragment.owner;\n  \t}\n  }\n\n  function getAncestry(item) {\n  \tvar ancestry, ancestor;\n\n  \tancestry = [item];\n\n  \tancestor = getParent(item);\n\n  \twhile (ancestor) {\n  \t\tancestry.push(ancestor);\n  \t\tancestor = getParent(ancestor);\n  \t}\n\n  \treturn ancestry;\n  }\n\n  var sortByDocumentPosition = function (node, otherNode) {\n  \tvar bitmask;\n\n  \tif (node.compareDocumentPosition) {\n  \t\tbitmask = node.compareDocumentPosition(otherNode);\n  \t\treturn bitmask & 2 ? 1 : -1;\n  \t}\n\n  \t// In old IE, we can piggy back on the mechanism for\n  \t// comparing component positions\n  \treturn sortByItemPosition(node, otherNode);\n  };\n\n  var sort = function () {\n  \tthis.sort(this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition);\n  \tthis._dirty = false;\n  };\n\n  var makeQuery_dirty = function () {\n  \tvar _this = this;\n\n  \tif (!this._dirty) {\n  \t\tthis._dirty = true;\n\n  \t\t// Once the DOM has been updated, ensure the query\n  \t\t// is correctly ordered\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t_this._sort();\n  \t\t});\n  \t}\n  };\n\n  var remove = function (nodeOrComponent) {\n  \tvar index = this.indexOf(this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent);\n\n  \tif (index !== -1) {\n  \t\tthis.splice(index, 1);\n  \t}\n  };\n\n  var _makeQuery = makeQuery;\n  function makeQuery(ractive, selector, live, isComponentQuery) {\n  \tvar query = [];\n\n  \tdefineProperties(query, {\n  \t\tselector: { value: selector },\n  \t\tlive: { value: live },\n\n  \t\t_isComponentQuery: { value: isComponentQuery },\n  \t\t_test: { value: test }\n  \t});\n\n  \tif (!live) {\n  \t\treturn query;\n  \t}\n\n  \tdefineProperties(query, {\n  \t\tcancel: { value: makeQuery_cancel },\n\n  \t\t_root: { value: ractive },\n  \t\t_sort: { value: sort },\n  \t\t_makeDirty: { value: makeQuery_dirty },\n  \t\t_remove: { value: remove },\n\n  \t\t_dirty: { value: false, writable: true }\n  \t});\n\n  \treturn query;\n  }\n\n  var prototype_findAll = Ractive$findAll;\n  function Ractive$findAll(selector, options) {\n  \tvar liveQueries, query;\n\n  \tif (!this.el) {\n  \t\treturn [];\n  \t}\n\n  \toptions = options || {};\n  \tliveQueries = this._liveQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, false);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAll(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findAllComponents = Ractive$findAllComponents;\n  function Ractive$findAllComponents(selector, options) {\n  \tvar liveQueries, query;\n\n  \toptions = options || {};\n  \tliveQueries = this._liveComponentQueries;\n\n  \t// Shortcut: if we're maintaining a live query with this\n  \t// selector, we don't need to traverse the parallel DOM\n  \tif (query = liveQueries[selector]) {\n\n  \t\t// Either return the exact same query, or (if not live) a snapshot\n  \t\treturn options && options.live ? query : query.slice();\n  \t}\n\n  \tquery = _makeQuery(this, selector, !!options.live, true);\n\n  \t// Add this to the list of live queries Ractive needs to maintain,\n  \t// if applicable\n  \tif (query.live) {\n  \t\tliveQueries.push(selector);\n  \t\tliveQueries[\"_\" + selector] = query;\n  \t}\n\n  \tthis.fragment.findAllComponents(selector, query);\n  \treturn query;\n  }\n\n  var prototype_findComponent = Ractive$findComponent;\n\n  function Ractive$findComponent(selector) {\n  \treturn this.fragment.findComponent(selector);\n  }\n\n  var findContainer = Ractive$findContainer;\n\n  function Ractive$findContainer(selector) {\n  \tif (this.container) {\n  \t\tif (this.container.component && this.container.component.name === selector) {\n  \t\t\treturn this.container;\n  \t\t} else {\n  \t\t\treturn this.container.findContainer(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findParent = Ractive$findParent;\n\n  function Ractive$findParent(selector) {\n\n  \tif (this.parent) {\n  \t\tif (this.parent.component && this.parent.component.name === selector) {\n  \t\t\treturn this.parent;\n  \t\t} else {\n  \t\t\treturn this.parent.findParent(selector);\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var eventStack = {\n  \tenqueue: function (ractive, event) {\n  \t\tif (ractive.event) {\n  \t\t\tractive._eventQueue = ractive._eventQueue || [];\n  \t\t\tractive._eventQueue.push(ractive.event);\n  \t\t}\n  \t\tractive.event = event;\n  \t},\n  \tdequeue: function (ractive) {\n  \t\tif (ractive._eventQueue && ractive._eventQueue.length) {\n  \t\t\tractive.event = ractive._eventQueue.pop();\n  \t\t} else {\n  \t\t\tdelete ractive.event;\n  \t\t}\n  \t}\n  };\n\n  var shared_eventStack = eventStack;\n\n  var shared_fireEvent = fireEvent;\n\n  function fireEvent(ractive, eventName) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tif (!eventName) {\n  \t\treturn;\n  \t}\n\n  \tif (!options.event) {\n  \t\toptions.event = {\n  \t\t\tname: eventName,\n  \t\t\t// until event not included as argument default\n  \t\t\t_noArg: true\n  \t\t};\n  \t} else {\n  \t\toptions.event.name = eventName;\n  \t}\n\n  \tvar eventNames = getKeypath(eventName).wildcardMatches();\n  \tfireEventAs(ractive, eventNames, options.event, options.args, true);\n  }\n\n  function fireEventAs(ractive, eventNames, event, args) {\n  \tvar initialFire = arguments[4] === undefined ? false : arguments[4];\n\n  \tvar subscribers,\n  \t    i,\n  \t    bubble = true;\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \tfor (i = eventNames.length; i >= 0; i--) {\n  \t\tsubscribers = ractive._subs[eventNames[i]];\n\n  \t\tif (subscribers) {\n  \t\t\tbubble = notifySubscribers(ractive, subscribers, event, args) && bubble;\n  \t\t}\n  \t}\n\n  \tshared_eventStack.dequeue(ractive);\n\n  \tif (ractive.parent && bubble) {\n\n  \t\tif (initialFire && ractive.component) {\n  \t\t\tvar fullName = ractive.component.name + \".\" + eventNames[eventNames.length - 1];\n  \t\t\teventNames = getKeypath(fullName).wildcardMatches();\n\n  \t\t\tif (event) {\n  \t\t\t\tevent.component = ractive;\n  \t\t\t}\n  \t\t}\n\n  \t\tfireEventAs(ractive.parent, eventNames, event, args);\n  \t}\n  }\n\n  function notifySubscribers(ractive, subscribers, event, args) {\n  \tvar originalEvent = null,\n  \t    stopEvent = false;\n\n  \tif (event && !event._noArg) {\n  \t\targs = [event].concat(args);\n  \t}\n\n  \t// subscribers can be modified inflight, e.g. \"once\" functionality\n  \t// so we need to copy to make sure everyone gets called\n  \tsubscribers = subscribers.slice();\n\n  \tfor (var i = 0, len = subscribers.length; i < len; i += 1) {\n  \t\tif (subscribers[i].apply(ractive, args) === false) {\n  \t\t\tstopEvent = true;\n  \t\t}\n  \t}\n\n  \tif (event && !event._noArg && stopEvent && (originalEvent = event.original)) {\n  \t\toriginalEvent.preventDefault && originalEvent.preventDefault();\n  \t\toriginalEvent.stopPropagation && originalEvent.stopPropagation();\n  \t}\n\n  \treturn !stopEvent;\n  }\n\n  var prototype_fire = Ractive$fire;\n  function Ractive$fire(eventName) {\n\n  \tvar options = {\n  \t\targs: Array.prototype.slice.call(arguments, 1)\n  \t};\n\n  \tshared_fireEvent(this, eventName, options);\n  }\n\n  var prototype_get = Ractive$get;\n  var options = {\n  \tcapture: true, // top-level calls should be intercepted\n  \tnoUnwrap: true, // wrapped values should NOT be unwrapped\n  \tfullRootGet: true // root get should return mappings\n  };\n  function Ractive$get(keypath) {\n  \tvar value;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tvalue = this.viewmodel.get(keypath, options);\n\n  \t// Create inter-component binding, if necessary\n  \tif (value === undefined && this.parent && !this.isolated) {\n  \t\tif (shared_resolveRef(this, keypath.str, this.component.parentFragment)) {\n  \t\t\t// creates binding as side-effect, if appropriate\n  \t\t\tvalue = this.viewmodel.get(keypath);\n  \t\t}\n  \t}\n\n  \treturn value;\n  }\n\n  var insert = Ractive$insert;\n\n  var insertHook = new hooks_Hook(\"insert\");\n  function Ractive$insert(target, anchor) {\n  \tif (!this.fragment.rendered) {\n  \t\t// TODO create, and link to, documentation explaining this\n  \t\tthrow new Error(\"The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.\");\n  \t}\n\n  \ttarget = getElement(target);\n  \tanchor = getElement(anchor) || null;\n\n  \tif (!target) {\n  \t\tthrow new Error(\"You must specify a valid target to insert into\");\n  \t}\n\n  \ttarget.insertBefore(this.detach(), anchor);\n  \tthis.el = target;\n\n  \t(target.__ractive_instances__ || (target.__ractive_instances__ = [])).push(this);\n  \tthis.detached = null;\n\n  \tfireInsertHook(this);\n  }\n\n  function fireInsertHook(ractive) {\n  \tinsertHook.fire(ractive);\n\n  \tractive.findAllComponents(\"*\").forEach(function (child) {\n  \t\tfireInsertHook(child.instance);\n  \t});\n  }\n\n  var prototype_merge = Ractive$merge;\n  function Ractive$merge(keypath, array, options) {\n  \tvar currentArray, promise;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \tcurrentArray = this.viewmodel.get(keypath);\n\n  \t// If either the existing value or the new value isn't an\n  \t// array, just do a regular set\n  \tif (!isArray(currentArray) || !isArray(array)) {\n  \t\treturn this.set(keypath, array, options && options.complete);\n  \t}\n\n  \t// Manage transitions\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.merge(keypath, currentArray, array, options);\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  var Observer = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n  \tthis.keypath = keypath;\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  Observer.prototype = {\n  \tinit: function (immediate) {\n  \t\tthis.value = this.root.get(this.keypath.str);\n\n  \t\tif (immediate !== false) {\n  \t\t\tthis.update();\n  \t\t} else {\n  \t\t\tthis.oldValue = this.value;\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tvar _this = this;\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n\n  \t\t\tif (this.defer && this.ready) {\n  \t\t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\t\treturn _this.update();\n  \t\t\t\t});\n  \t\t\t} else {\n  \t\t\t\tthis.update();\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tthis.callback.call(this.context, this.value, this.oldValue, this.keypath.str);\n  \t\tthis.oldValue = this.value;\n\n  \t\tthis.updating = false;\n  \t}\n  };\n\n  var observe_Observer = Observer;\n\n  var observe_getPattern = getPattern;\n  function getPattern(ractive, pattern) {\n  \tvar matchingKeypaths, values;\n\n  \tmatchingKeypaths = getMatchingKeypaths(ractive, pattern);\n\n  \tvalues = {};\n  \tmatchingKeypaths.forEach(function (keypath) {\n  \t\tvalues[keypath.str] = ractive.get(keypath.str);\n  \t});\n\n  \treturn values;\n  }\n\n  var PatternObserver,\n      slice = Array.prototype.slice;\n\n  PatternObserver = function (ractive, keypath, callback, options) {\n  \tthis.root = ractive;\n\n  \tthis.callback = callback;\n  \tthis.defer = options.defer;\n\n  \tthis.keypath = keypath;\n  \tthis.regex = new RegExp(\"^\" + keypath.str.replace(/\\./g, \"\\\\.\").replace(/\\*/g, \"([^\\\\.]+)\") + \"$\");\n  \tthis.values = {};\n\n  \tif (this.defer) {\n  \t\tthis.proxies = [];\n  \t}\n\n  \t// default to root as context, but allow it to be overridden\n  \tthis.context = options && options.context ? options.context : ractive;\n  };\n\n  PatternObserver.prototype = {\n  \tinit: function (immediate) {\n  \t\tvar values, keypath;\n\n  \t\tvalues = observe_getPattern(this.root, this.keypath);\n\n  \t\tif (immediate !== false) {\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tthis.values = values;\n  \t\t}\n  \t},\n\n  \tupdate: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tvar values;\n\n  \t\tif (keypath.isPattern) {\n  \t\t\tvalues = observe_getPattern(this.root, keypath);\n\n  \t\t\tfor (keypath in values) {\n  \t\t\t\tif (values.hasOwnProperty(keypath)) {\n  \t\t\t\t\tthis.update(getKeypath(keypath));\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - array mutation should not trigger `array.*`\n  \t\t// pattern observer with `array.length`\n  \t\tif (this.root.viewmodel.implicitChanges[keypath.str]) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (this.defer && this.ready) {\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.getProxy(keypath).update();\n  \t\t\t});\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.reallyUpdate(keypath);\n  \t},\n\n  \treallyUpdate: function (keypath) {\n  \t\tvar keypathStr, value, keys, args;\n\n  \t\tkeypathStr = keypath.str;\n  \t\tvalue = this.root.viewmodel.get(keypath);\n\n  \t\t// Prevent infinite loops\n  \t\tif (this.updating) {\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.updating = true;\n\n  \t\tif (!isEqual(value, this.values[keypathStr]) || !this.ready) {\n  \t\t\tkeys = slice.call(this.regex.exec(keypathStr), 1);\n  \t\t\targs = [value, this.values[keypathStr], keypathStr].concat(keys);\n\n  \t\t\tthis.values[keypathStr] = value;\n  \t\t\tthis.callback.apply(this.context, args);\n  \t\t}\n\n  \t\tthis.updating = false;\n  \t},\n\n  \tgetProxy: function (keypath) {\n  \t\tvar _this = this;\n\n  \t\tif (!this.proxies[keypath.str]) {\n  \t\t\tthis.proxies[keypath.str] = {\n  \t\t\t\tupdate: function () {\n  \t\t\t\t\treturn _this.reallyUpdate(keypath);\n  \t\t\t\t}\n  \t\t\t};\n  \t\t}\n\n  \t\treturn this.proxies[keypath.str];\n  \t}\n  };\n\n  var observe_PatternObserver = PatternObserver;\n\n  var observe_getObserverFacade = getObserverFacade;\n  var emptyObject = {};\n  function getObserverFacade(ractive, keypath, callback, options) {\n  \tvar observer, isPatternObserver, cancelled;\n\n  \tkeypath = getKeypath(normalise(keypath));\n  \toptions = options || emptyObject;\n\n  \t// pattern observers are treated differently\n  \tif (keypath.isPattern) {\n  \t\tobserver = new observe_PatternObserver(ractive, keypath, callback, options);\n  \t\tractive.viewmodel.patternObservers.push(observer);\n  \t\tisPatternObserver = true;\n  \t} else {\n  \t\tobserver = new observe_Observer(ractive, keypath, callback, options);\n  \t}\n\n  \tobserver.init(options.init);\n  \tractive.viewmodel.register(keypath, observer, isPatternObserver ? \"patternObservers\" : \"observers\");\n\n  \t// This flag allows observers to initialise even with undefined values\n  \tobserver.ready = true;\n\n  \tvar facade = {\n  \t\tcancel: function () {\n  \t\t\tvar index;\n\n  \t\t\tif (cancelled) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (isPatternObserver) {\n  \t\t\t\tindex = ractive.viewmodel.patternObservers.indexOf(observer);\n\n  \t\t\t\tractive.viewmodel.patternObservers.splice(index, 1);\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"patternObservers\");\n  \t\t\t} else {\n  \t\t\t\tractive.viewmodel.unregister(keypath, observer, \"observers\");\n  \t\t\t}\n  \t\t\tcancelled = true;\n  \t\t}\n  \t};\n\n  \tractive._observers.push(facade);\n  \treturn facade;\n  }\n\n  var observe = Ractive$observe;\n  function Ractive$observe(keypath, callback, options) {\n\n  \tvar observers, map, keypaths, i;\n\n  \t// Allow a map of keypaths to handlers\n  \tif (isObject(keypath)) {\n  \t\toptions = callback;\n  \t\tmap = keypath;\n\n  \t\tobservers = [];\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tcallback = map[keypath];\n  \t\t\t\tobservers.push(this.observe(keypath, callback, options));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\twhile (observers.length) {\n  \t\t\t\t\tobservers.pop().cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Allow `ractive.observe( callback )` - i.e. observe entire model\n  \tif (typeof keypath === \"function\") {\n  \t\toptions = callback;\n  \t\tcallback = keypath;\n  \t\tkeypath = \"\";\n\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \tkeypaths = keypath.split(\" \");\n\n  \t// Single keypath\n  \tif (keypaths.length === 1) {\n  \t\treturn observe_getObserverFacade(this, keypath, callback, options);\n  \t}\n\n  \t// Multiple space-separated keypaths\n  \tobservers = [];\n\n  \ti = keypaths.length;\n  \twhile (i--) {\n  \t\tkeypath = keypaths[i];\n\n  \t\tif (keypath) {\n  \t\t\tobservers.push(observe_getObserverFacade(this, keypath, callback, options));\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\twhile (observers.length) {\n  \t\t\t\tobservers.pop().cancel();\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var observeOnce = Ractive$observeOnce;\n\n  function Ractive$observeOnce(property, callback, options) {\n\n  \tvar observer = this.observe(property, function () {\n  \t\tcallback.apply(this, arguments);\n  \t\tobserver.cancel();\n  \t}, { init: false, defer: options && options.defer });\n\n  \treturn observer;\n  }\n\n  var shared_trim = function (str) {\n    return str.trim();\n  };\n\n  var notEmptyString = function (str) {\n    return str !== \"\";\n  };\n\n  var off = Ractive$off;\n  function Ractive$off(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar eventNames;\n\n  \t// if no arguments specified, remove all callbacks\n  \tif (!eventName) {\n  \t\t// TODO use this code instead, once the following issue has been resolved\n  \t\t// in PhantomJS (tests are unpassable otherwise!)\n  \t\t// https://github.com/ariya/phantomjs/issues/11856\n  \t\t// defineProperty( this, '_subs', { value: create( null ), configurable: true });\n  \t\tfor (eventName in this._subs) {\n  \t\t\tdelete this._subs[eventName];\n  \t\t}\n  \t} else {\n  \t\t// Handle multiple space-separated event names\n  \t\teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \t\teventNames.forEach(function (eventName) {\n  \t\t\tvar subscribers, index;\n\n  \t\t\t// If we have subscribers for this event...\n  \t\t\tif (subscribers = _this._subs[eventName]) {\n  \t\t\t\t// ...if a callback was specified, only remove that\n  \t\t\t\tif (callback) {\n  \t\t\t\t\tindex = subscribers.indexOf(callback);\n  \t\t\t\t\tif (index !== -1) {\n  \t\t\t\t\t\tsubscribers.splice(index, 1);\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// ...otherwise remove all callbacks\n  \t\t\t\telse {\n  \t\t\t\t\t_this._subs[eventName] = [];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn this;\n  }\n\n  var on = Ractive$on;\n  function Ractive$on(eventName, callback) {\n  \tvar _this = this;\n\n  \tvar listeners, n, eventNames;\n\n  \t// allow mutliple listeners to be bound in one go\n  \tif (typeof eventName === \"object\") {\n  \t\tlisteners = [];\n\n  \t\tfor (n in eventName) {\n  \t\t\tif (eventName.hasOwnProperty(n)) {\n  \t\t\t\tlisteners.push(this.on(n, eventName[n]));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn {\n  \t\t\tcancel: function () {\n  \t\t\t\tvar listener;\n\n  \t\t\t\twhile (listener = listeners.pop()) {\n  \t\t\t\t\tlistener.cancel();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \t// Handle multiple space-separated event names\n  \teventNames = eventName.split(\" \").map(shared_trim).filter(notEmptyString);\n\n  \teventNames.forEach(function (eventName) {\n  \t\t(_this._subs[eventName] || (_this._subs[eventName] = [])).push(callback);\n  \t});\n\n  \treturn {\n  \t\tcancel: function () {\n  \t\t\treturn _this.off(eventName, callback);\n  \t\t}\n  \t};\n  }\n\n  var once = Ractive$once;\n\n  function Ractive$once(eventName, handler) {\n\n  \tvar listener = this.on(eventName, function () {\n  \t\thandler.apply(this, arguments);\n  \t\tlistener.cancel();\n  \t});\n\n  \t// so we can still do listener.cancel() manually\n  \treturn listener;\n  }\n\n  // This function takes an array, the name of a mutator method, and the\n  // arguments to call that mutator method with, and returns an array that\n  // maps the old indices to their new indices.\n\n  // So if you had something like this...\n  //\n  //     array = [ 'a', 'b', 'c', 'd' ];\n  //     array.push( 'e' );\n  //\n  // ...you'd get `[ 0, 1, 2, 3 ]` - in other words, none of the old indices\n  // have changed. If you then did this...\n  //\n  //     array.unshift( 'z' );\n  //\n  // ...the indices would be `[ 1, 2, 3, 4, 5 ]` - every item has been moved\n  // one higher to make room for the 'z'. If you removed an item, the new index\n  // would be -1...\n  //\n  //     array.splice( 2, 2 );\n  //\n  // ...this would result in [ 0, 1, -1, -1, 2, 3 ].\n  //\n  // This information is used to enable fast, non-destructive shuffling of list\n  // sections when you do e.g. `ractive.splice( 'items', 2, 2 );\n\n  var shared_getNewIndices = getNewIndices;\n\n  function getNewIndices(array, methodName, args) {\n  \tvar spliceArguments,\n  \t    len,\n  \t    newIndices = [],\n  \t    removeStart,\n  \t    removeEnd,\n  \t    balance,\n  \t    i;\n\n  \tspliceArguments = getSpliceEquivalent(array, methodName, args);\n\n  \tif (!spliceArguments) {\n  \t\treturn null; // TODO support reverse and sort?\n  \t}\n\n  \tlen = array.length;\n  \tbalance = spliceArguments.length - 2 - spliceArguments[1];\n\n  \tremoveStart = Math.min(len, spliceArguments[0]);\n  \tremoveEnd = removeStart + spliceArguments[1];\n\n  \tfor (i = 0; i < removeStart; i += 1) {\n  \t\tnewIndices.push(i);\n  \t}\n\n  \tfor (; i < removeEnd; i += 1) {\n  \t\tnewIndices.push(-1);\n  \t}\n\n  \tfor (; i < len; i += 1) {\n  \t\tnewIndices.push(i + balance);\n  \t}\n\n  \t// there is a net shift for the rest of the array starting with index + balance\n  \tif (balance !== 0) {\n  \t\tnewIndices.touchedFrom = spliceArguments[0];\n  \t} else {\n  \t\tnewIndices.touchedFrom = array.length;\n  \t}\n\n  \treturn newIndices;\n  }\n\n  // The pop, push, shift an unshift methods can all be represented\n  // as an equivalent splice\n  function getSpliceEquivalent(array, methodName, args) {\n  \tswitch (methodName) {\n  \t\tcase \"splice\":\n  \t\t\tif (args[0] !== undefined && args[0] < 0) {\n  \t\t\t\targs[0] = array.length + Math.max(args[0], -array.length);\n  \t\t\t}\n\n  \t\t\twhile (args.length < 2) {\n  \t\t\t\targs.push(0);\n  \t\t\t}\n\n  \t\t\t// ensure we only remove elements that exist\n  \t\t\targs[1] = Math.min(args[1], array.length - args[0]);\n\n  \t\t\treturn args;\n\n  \t\tcase \"sort\":\n  \t\tcase \"reverse\":\n  \t\t\treturn null;\n\n  \t\tcase \"pop\":\n  \t\t\tif (array.length) {\n  \t\t\t\treturn [array.length - 1, 1];\n  \t\t\t}\n  \t\t\treturn [0, 0];\n\n  \t\tcase \"push\":\n  \t\t\treturn [array.length, 0].concat(args);\n\n  \t\tcase \"shift\":\n  \t\t\treturn [0, array.length ? 1 : 0];\n\n  \t\tcase \"unshift\":\n  \t\t\treturn [0, 0].concat(args);\n  \t}\n  }\n\n  var arrayProto = Array.prototype;\n\n  var makeArrayMethod = function (methodName) {\n  \treturn function (keypath) {\n  \t\tfor (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n  \t\t\targs[_key - 1] = arguments[_key];\n  \t\t}\n\n  \t\tvar array,\n  \t\t    newIndices = [],\n  \t\t    len,\n  \t\t    promise,\n  \t\t    result;\n\n  \t\tkeypath = getKeypath(normalise(keypath));\n\n  \t\tarray = this.viewmodel.get(keypath);\n  \t\tlen = array.length;\n\n  \t\tif (!isArray(array)) {\n  \t\t\tthrow new Error(\"Called ractive.\" + methodName + \"('\" + keypath.str + \"'), but '\" + keypath.str + \"' does not refer to an array\");\n  \t\t}\n\n  \t\tnewIndices = shared_getNewIndices(array, methodName, args);\n\n  \t\tresult = arrayProto[methodName].apply(array, args);\n  \t\tpromise = global_runloop.start(this, true).then(function () {\n  \t\t\treturn result;\n  \t\t});\n\n  \t\tif (!!newIndices) {\n  \t\t\tthis.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t\t} else {\n  \t\t\tthis.viewmodel.mark(keypath);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\treturn promise;\n  \t};\n  };\n\n  var pop = makeArrayMethod(\"pop\");\n\n  var push = makeArrayMethod(\"push\");\n\n  var css,\n      update,\n      styleElement,\n      head,\n      styleSheet,\n      inDom,\n      global_css__prefix = \"/* Ractive.js component styles */\\n\",\n      styles = [],\n      dirty = false;\n\n  if (!isClient) {\n  \t// TODO handle encapsulated CSS in server-rendered HTML!\n  \tcss = {\n  \t\tadd: noop,\n  \t\tapply: noop\n  \t};\n  } else {\n  \tstyleElement = document.createElement(\"style\");\n  \tstyleElement.type = \"text/css\";\n\n  \thead = document.getElementsByTagName(\"head\")[0];\n\n  \tinDom = false;\n\n  \t// Internet Exploder won't let you use styleSheet.innerHTML - we have to\n  \t// use styleSheet.cssText instead\n  \tstyleSheet = styleElement.styleSheet;\n\n  \tupdate = function () {\n  \t\tvar css = global_css__prefix + styles.map(function (s) {\n  \t\t\treturn \"\\n/* {\" + s.id + \"} */\\n\" + s.styles;\n  \t\t}).join(\"\\n\");\n\n  \t\tif (styleSheet) {\n  \t\t\tstyleSheet.cssText = css;\n  \t\t} else {\n  \t\t\tstyleElement.innerHTML = css;\n  \t\t}\n\n  \t\tif (!inDom) {\n  \t\t\thead.appendChild(styleElement);\n  \t\t\tinDom = true;\n  \t\t}\n  \t};\n\n  \tcss = {\n  \t\tadd: function (s) {\n  \t\t\tstyles.push(s);\n  \t\t\tdirty = true;\n  \t\t},\n\n  \t\tapply: function () {\n  \t\t\tif (dirty) {\n  \t\t\t\tupdate();\n  \t\t\t\tdirty = false;\n  \t\t\t}\n  \t\t}\n  \t};\n  }\n\n  var global_css = css;\n\n  var prototype_render = Ractive$render;\n\n  var renderHook = new hooks_Hook(\"render\"),\n      completeHook = new hooks_Hook(\"complete\");\n  function Ractive$render(target, anchor) {\n  \tvar _this = this;\n\n  \tvar promise, instances, transitionsEnabled;\n\n  \t// if `noIntro` is `true`, temporarily disable transitions\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tif (this.noIntro) {\n  \t\tthis.transitionsEnabled = false;\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn renderHook.fire(_this);\n  \t}, true);\n\n  \tif (this.fragment.rendered) {\n  \t\tthrow new Error(\"You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first\");\n  \t}\n\n  \ttarget = getElement(target) || this.el;\n  \tanchor = getElement(anchor) || this.anchor;\n\n  \tthis.el = target;\n  \tthis.anchor = anchor;\n\n  \tif (!this.append && target) {\n  \t\t// Teardown any existing instances *before* trying to set up the new one -\n  \t\t// avoids certain weird bugs\n  \t\tvar others = target.__ractive_instances__;\n  \t\tif (others && others.length) {\n  \t\t\tremoveOtherInstances(others);\n  \t\t}\n\n  \t\t// make sure we are the only occupants\n  \t\ttarget.innerHTML = \"\"; // TODO is this quicker than removeChild? Initial research inconclusive\n  \t}\n\n  \tif (this.cssId) {\n  \t\t// ensure encapsulated CSS is up-to-date\n  \t\tglobal_css.apply();\n  \t}\n\n  \tif (target) {\n  \t\tif (!(instances = target.__ractive_instances__)) {\n  \t\t\ttarget.__ractive_instances__ = [this];\n  \t\t} else {\n  \t\t\tinstances.push(this);\n  \t\t}\n\n  \t\tif (anchor) {\n  \t\t\ttarget.insertBefore(this.fragment.render(), anchor);\n  \t\t} else {\n  \t\t\ttarget.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \tglobal_runloop.end();\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n\n  \treturn promise.then(function () {\n  \t\treturn completeHook.fire(_this);\n  \t});\n  }\n\n  function removeOtherInstances(others) {\n  \tothers.splice(0, others.length).forEach(teardown);\n  }\n\n  var adaptConfigurator = {\n  \textend: function (Parent, proto, options) {\n  \t\tproto.adapt = custom_adapt__combine(proto.adapt, ensureArray(options.adapt));\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var custom_adapt = adaptConfigurator;\n\n  function custom_adapt__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  var transform = transformCss;\n\n  var selectorsPattern = /(?:^|\\})?\\s*([^\\{\\}]+)\\s*\\{/g,\n      commentsPattern = /\\/\\*.*?\\*\\//g,\n      selectorUnitPattern = /((?:(?:\\[[^\\]+]\\])|(?:[^\\s\\+\\>\\~:]))+)((?::[^\\s\\+\\>\\~\\(]+(?:\\([^\\)]+\\))?)?\\s*[\\s\\+\\>\\~]?)\\s*/g,\n      mediaQueryPattern = /^@media/,\n      dataRvcGuidPattern = /\\[data-ractive-css~=\"\\{[a-z0-9-]+\\}\"]/g;\n  function transformCss(css, id) {\n  \tvar transformed, dataAttr, addGuid;\n\n  \tdataAttr = \"[data-ractive-css~=\\\"{\" + id + \"}\\\"]\";\n\n  \taddGuid = function (selector) {\n  \t\tvar selectorUnits,\n  \t\t    match,\n  \t\t    unit,\n  \t\t    base,\n  \t\t    prepended,\n  \t\t    appended,\n  \t\t    i,\n  \t\t    transformed = [];\n\n  \t\tselectorUnits = [];\n\n  \t\twhile (match = selectorUnitPattern.exec(selector)) {\n  \t\t\tselectorUnits.push({\n  \t\t\t\tstr: match[0],\n  \t\t\t\tbase: match[1],\n  \t\t\t\tmodifiers: match[2]\n  \t\t\t});\n  \t\t}\n\n  \t\t// For each simple selector within the selector, we need to create a version\n  \t\t// that a) combines with the id, and b) is inside the id\n  \t\tbase = selectorUnits.map(extractString);\n\n  \t\ti = selectorUnits.length;\n  \t\twhile (i--) {\n  \t\t\tappended = base.slice();\n\n  \t\t\t// Pseudo-selectors should go after the attribute selector\n  \t\t\tunit = selectorUnits[i];\n  \t\t\tappended[i] = unit.base + dataAttr + unit.modifiers || \"\";\n\n  \t\t\tprepended = base.slice();\n  \t\t\tprepended[i] = dataAttr + \" \" + prepended[i];\n\n  \t\t\ttransformed.push(appended.join(\" \"), prepended.join(\" \"));\n  \t\t}\n\n  \t\treturn transformed.join(\", \");\n  \t};\n\n  \tif (dataRvcGuidPattern.test(css)) {\n  \t\ttransformed = css.replace(dataRvcGuidPattern, dataAttr);\n  \t} else {\n  \t\ttransformed = css.replace(commentsPattern, \"\").replace(selectorsPattern, function (match, $1) {\n  \t\t\tvar selectors, transformed;\n\n  \t\t\t// don't transform media queries!\n  \t\t\tif (mediaQueryPattern.test($1)) return match;\n\n  \t\t\tselectors = $1.split(\",\").map(trim);\n  \t\t\ttransformed = selectors.map(addGuid).join(\", \") + \" \";\n\n  \t\t\treturn match.replace($1, transformed);\n  \t\t});\n  \t}\n\n  \treturn transformed;\n  }\n\n  function trim(str) {\n  \tif (str.trim) {\n  \t\treturn str.trim();\n  \t}\n\n  \treturn str.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");\n  }\n\n  function extractString(unit) {\n  \treturn unit.str;\n  }\n\n  var css_css__uid = 1;\n\n  var cssConfigurator = {\n  \tname: \"css\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tif (options.css) {\n  \t\t\tvar id = css_css__uid++;\n  \t\t\tvar styles = options.noCssTransform ? options.css : transform(options.css, id);\n\n  \t\t\tproto.cssId = id;\n  \t\t\tglobal_css.add({ id: id, styles: styles });\n  \t\t}\n  \t},\n\n  \tinit: function () {}\n  };\n\n  var css_css = cssConfigurator;\n\n  function validate(data) {\n  \t// Warn if userOptions.data is a non-POJO\n  \tif (data && data.constructor !== Object) {\n  \t\tif (typeof data === \"function\") {} else if (typeof data !== \"object\") {\n  \t\t\tfatal(\"data option must be an object or a function, `\" + data + \"` is not valid\");\n  \t\t} else {\n  \t\t\twarnIfDebug(\"If supplied, options.data should be a plain JavaScript object - using a non-POJO as the root object may work, but is discouraged\");\n  \t\t}\n  \t}\n  }\n\n  var dataConfigurator = {\n  \tname: \"data\",\n\n  \textend: function (Parent, proto, options) {\n  \t\tvar key = undefined,\n  \t\t    value = undefined;\n\n  \t\t// check for non-primitives, which could cause mutation-related bugs\n  \t\tif (options.data && isObject(options.data)) {\n  \t\t\tfor (key in options.data) {\n  \t\t\t\tvalue = options.data[key];\n\n  \t\t\t\tif (value && typeof value === \"object\") {\n  \t\t\t\t\tif (isObject(value) || isArray(value)) {\n  \t\t\t\t\t\twarnIfDebug(\"Passing a `data` option with object and array properties to Ractive.extend() is discouraged, as mutating them is likely to cause bugs. Consider using a data function instead:\\n\\n  // this...\\n  data: function () {\\n    return {\\n      myObject: {}\\n    };\\n  })\\n\\n  // instead of this:\\n  data: {\\n    myObject: {}\\n  }\");\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tproto.data = custom_data__combine(proto.data, options.data);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\tvar result = custom_data__combine(Parent.prototype.data, options.data);\n\n  \t\tif (typeof result === \"function\") {\n  \t\t\tresult = result.call(ractive);\n  \t\t}\n\n  \t\treturn result || {};\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = this.init(ractive.constructor, ractive, ractive.viewmodel);\n\n  \t\tractive.viewmodel.reset(result);\n  \t\treturn true;\n  \t}\n  };\n\n  var custom_data = dataConfigurator;\n\n  function custom_data__combine(parentValue, childValue) {\n  \tvalidate(childValue);\n\n  \tvar parentIsFn = typeof parentValue === \"function\";\n  \tvar childIsFn = typeof childValue === \"function\";\n\n  \t// Very important, otherwise child instance can become\n  \t// the default data object on Ractive or a component.\n  \t// then ractive.set() ends up setting on the prototype!\n  \tif (!childValue && !parentIsFn) {\n  \t\tchildValue = {};\n  \t}\n\n  \t// Fast path, where we just need to copy properties from\n  \t// parent to child\n  \tif (!parentIsFn && !childIsFn) {\n  \t\treturn fromProperties(childValue, parentValue);\n  \t}\n\n  \treturn function () {\n  \t\tvar child = childIsFn ? callDataFunction(childValue, this) : childValue;\n  \t\tvar parent = parentIsFn ? callDataFunction(parentValue, this) : parentValue;\n\n  \t\treturn fromProperties(child, parent);\n  \t};\n  }\n\n  function callDataFunction(fn, context) {\n  \tvar data = fn.call(context);\n\n  \tif (!data) return;\n\n  \tif (typeof data !== \"object\") {\n  \t\tfatal(\"Data function must return an object\");\n  \t}\n\n  \tif (data.constructor !== Object) {\n  \t\twarnOnceIfDebug(\"Data function returned something other than a plain JavaScript object. This might work, but is strongly discouraged\");\n  \t}\n\n  \treturn data;\n  }\n\n  function fromProperties(primary, secondary) {\n  \tif (primary && secondary) {\n  \t\tfor (var key in secondary) {\n  \t\t\tif (!(key in primary)) {\n  \t\t\t\tprimary[key] = secondary[key];\n  \t\t\t}\n  \t\t}\n\n  \t\treturn primary;\n  \t}\n\n  \treturn primary || secondary;\n  }\n\n  // TODO do we need to support this in the new Ractive() case?\n\n  var Parser,\n      ParseError,\n      parse_Parser__leadingWhitespace = /^\\s+/;\n\n  ParseError = function (message) {\n  \tthis.name = \"ParseError\";\n  \tthis.message = message;\n  \ttry {\n  \t\tthrow new Error(message);\n  \t} catch (e) {\n  \t\tthis.stack = e.stack;\n  \t}\n  };\n\n  ParseError.prototype = Error.prototype;\n\n  Parser = function (str, options) {\n  \tvar items,\n  \t    item,\n  \t    lineStart = 0;\n\n  \tthis.str = str;\n  \tthis.options = options || {};\n  \tthis.pos = 0;\n\n  \tthis.lines = this.str.split(\"\\n\");\n  \tthis.lineEnds = this.lines.map(function (line) {\n  \t\tvar lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n  \t\tlineStart = lineEnd;\n  \t\treturn lineEnd;\n  \t}, 0);\n\n  \t// Custom init logic\n  \tif (this.init) this.init(str, options);\n\n  \titems = [];\n\n  \twhile (this.pos < this.str.length && (item = this.read())) {\n  \t\titems.push(item);\n  \t}\n\n  \tthis.leftover = this.remaining();\n  \tthis.result = this.postProcess ? this.postProcess(items, options) : items;\n  };\n\n  Parser.prototype = {\n  \tread: function (converters) {\n  \t\tvar pos, i, len, item;\n\n  \t\tif (!converters) converters = this.converters;\n\n  \t\tpos = this.pos;\n\n  \t\tlen = converters.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.pos = pos; // reset for each attempt\n\n  \t\t\tif (item = converters[i](this)) {\n  \t\t\t\treturn item;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t},\n\n  \tgetLinePos: function (char) {\n  \t\tvar lineNum = 0,\n  \t\t    lineStart = 0,\n  \t\t    columnNum;\n\n  \t\twhile (char >= this.lineEnds[lineNum]) {\n  \t\t\tlineStart = this.lineEnds[lineNum];\n  \t\t\tlineNum += 1;\n  \t\t}\n\n  \t\tcolumnNum = char - lineStart;\n  \t\treturn [lineNum + 1, columnNum + 1, char]; // line/col should be one-based, not zero-based!\n  \t},\n\n  \terror: function (message) {\n  \t\tvar pos = this.getLinePos(this.pos);\n  \t\tvar lineNum = pos[0];\n  \t\tvar columnNum = pos[1];\n\n  \t\tvar line = this.lines[pos[0] - 1];\n  \t\tvar numTabs = 0;\n  \t\tvar annotation = line.replace(/\\t/g, function (match, char) {\n  \t\t\tif (char < pos[1]) {\n  \t\t\t\tnumTabs += 1;\n  \t\t\t}\n\n  \t\t\treturn \"  \";\n  \t\t}) + \"\\n\" + new Array(pos[1] + numTabs).join(\" \") + \"^----\";\n\n  \t\tvar error = new ParseError(\"\" + message + \" at line \" + lineNum + \" character \" + columnNum + \":\\n\" + annotation);\n\n  \t\terror.line = pos[0];\n  \t\terror.character = pos[1];\n  \t\terror.shortMessage = message;\n\n  \t\tthrow error;\n  \t},\n\n  \tmatchString: function (string) {\n  \t\tif (this.str.substr(this.pos, string.length) === string) {\n  \t\t\tthis.pos += string.length;\n  \t\t\treturn string;\n  \t\t}\n  \t},\n\n  \tmatchPattern: function (pattern) {\n  \t\tvar match;\n\n  \t\tif (match = pattern.exec(this.remaining())) {\n  \t\t\tthis.pos += match[0].length;\n  \t\t\treturn match[1] || match[0];\n  \t\t}\n  \t},\n\n  \tallowWhitespace: function () {\n  \t\tthis.matchPattern(parse_Parser__leadingWhitespace);\n  \t},\n\n  \tremaining: function () {\n  \t\treturn this.str.substring(this.pos);\n  \t},\n\n  \tnextChar: function () {\n  \t\treturn this.str.charAt(this.pos);\n  \t}\n  };\n\n  Parser.extend = function (proto) {\n  \tvar Parent = this,\n  \t    Child,\n  \t    key;\n\n  \tChild = function (str, options) {\n  \t\tParser.call(this, str, options);\n  \t};\n\n  \tChild.prototype = create(Parent.prototype);\n\n  \tfor (key in proto) {\n  \t\tif (hasOwn.call(proto, key)) {\n  \t\t\tChild.prototype[key] = proto[key];\n  \t\t}\n  \t}\n\n  \tChild.extend = Parser.extend;\n  \treturn Child;\n  };\n\n  var parse_Parser = Parser;\n\n  var TEXT = 1;\n  var INTERPOLATOR = 2;\n  var TRIPLE = 3;\n  var SECTION = 4;\n  var INVERTED = 5;\n  var CLOSING = 6;\n  var ELEMENT = 7;\n  var PARTIAL = 8;\n  var COMMENT = 9;\n  var DELIMCHANGE = 10;\n  var ATTRIBUTE = 13;\n  var CLOSING_TAG = 14;\n  var COMPONENT = 15;\n  var YIELDER = 16;\n  var INLINE_PARTIAL = 17;\n  var DOCTYPE = 18;\n\n  var NUMBER_LITERAL = 20;\n  var STRING_LITERAL = 21;\n  var ARRAY_LITERAL = 22;\n  var OBJECT_LITERAL = 23;\n  var BOOLEAN_LITERAL = 24;\n  var REGEXP_LITERAL = 25;\n\n  var GLOBAL = 26;\n  var KEY_VALUE_PAIR = 27;\n\n  var REFERENCE = 30;\n  var REFINEMENT = 31;\n  var MEMBER = 32;\n  var PREFIX_OPERATOR = 33;\n  var BRACKETED = 34;\n  var CONDITIONAL = 35;\n  var INFIX_OPERATOR = 36;\n\n  var INVOCATION = 40;\n\n  var SECTION_IF = 50;\n  var SECTION_UNLESS = 51;\n  var SECTION_EACH = 52;\n  var SECTION_WITH = 53;\n  var SECTION_IF_WITH = 54;\n\n  var ELSE = 60;\n  var ELSEIF = 61;\n\n  var mustache_readDelimiterChange = readDelimiterChange;\n  var delimiterChangePattern = /^[^\\s=]+/,\n      whitespacePattern = /^\\s+/;\n  function readDelimiterChange(parser) {\n  \tvar start, opening, closing;\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before new opening delimiter\n  \tparser.allowWhitespace();\n\n  \topening = parser.matchPattern(delimiterChangePattern);\n  \tif (!opening) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace (in fact, it's necessary...)\n  \tif (!parser.matchPattern(whitespacePattern)) {\n  \t\treturn null;\n  \t}\n\n  \tclosing = parser.matchPattern(delimiterChangePattern);\n  \tif (!closing) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace before closing '='\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn [opening, closing];\n  }\n\n  var readRegexpLiteral = readRegexpLiteral__readNumberLiteral;\n  var regexpPattern = /^(\\/(?:[^\\n\\r\\u2028\\u2029/\\\\[]|\\\\.|\\[(?:[^\\n\\r\\u2028\\u2029\\]\\\\]|\\\\.)*])+\\/(?:([gimuy])(?![a-z]*\\2))*(?![a-zA-Z_$0-9]))/;\n  function readRegexpLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(regexpPattern)) {\n  \t\treturn {\n  \t\t\tt: REGEXP_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var converters_readMustache = readMustache;\n\n  var delimiterChangeToken = { t: DELIMCHANGE, exclude: true };\n  function readMustache(parser) {\n  \tvar mustache, i;\n\n  \t// If we're inside a <script> or <style> tag, and we're not\n  \t// interpolating, bug out\n  \tif (parser.interpolate[parser.inside] === false) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < parser.tags.length; i += 1) {\n  \t\tif (mustache = readMustacheOfType(parser, parser.tags[i])) {\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n  }\n\n  function readMustacheOfType(parser, tag) {\n  \tvar start, mustache, reader, i;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\\\" + tag.open)) {\n  \t\tif (start === 0 || parser.str[start - 1] !== \"\\\\\") {\n  \t\t\treturn tag.open;\n  \t\t}\n  \t} else if (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \t// delimiter change?\n  \tif (mustache = mustache_readDelimiterChange(parser)) {\n  \t\t// find closing delimiter or abort...\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// ...then make the switch\n  \t\ttag.open = mustache[0];\n  \t\ttag.close = mustache[1];\n  \t\tparser.sortMustacheTags();\n\n  \t\treturn delimiterChangeToken;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \t// illegal section closer\n  \tif (parser.matchString(\"/\")) {\n  \t\tparser.pos -= 1;\n  \t\tvar rewind = parser.pos;\n  \t\tif (!readRegexpLiteral(parser)) {\n  \t\t\tparser.pos = rewind - tag.close.length;\n  \t\t\tparser.error(\"Attempted to close a section that wasn't open\");\n  \t\t} else {\n  \t\t\tparser.pos = rewind;\n  \t\t}\n  \t}\n\n  \tfor (i = 0; i < tag.readers.length; i += 1) {\n  \t\treader = tag.readers[i];\n\n  \t\tif (mustache = reader(parser, tag)) {\n  \t\t\tif (tag.isStatic) {\n  \t\t\t\tmustache.s = true; // TODO make this `1` instead - more compact\n  \t\t\t}\n\n  \t\t\tif (parser.includeLinePositions) {\n  \t\t\t\tmustache.p = parser.getLinePos(start);\n  \t\t\t}\n\n  \t\t\treturn mustache;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var expectedExpression = \"Expected a JavaScript expression\";\n  var expectedParen = \"Expected closing paren\";\n\n  var literal_readNumberLiteral = literal_readNumberLiteral__readNumberLiteral;\n  var literal_readNumberLiteral__numberPattern = /^(?:[+-]?)0*(?:(?:(?:[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  function literal_readNumberLiteral__readNumberLiteral(parser) {\n  \tvar result;\n\n  \tif (result = parser.matchPattern(literal_readNumberLiteral__numberPattern)) {\n  \t\treturn {\n  \t\t\tt: NUMBER_LITERAL,\n  \t\t\tv: result\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var literal_readBooleanLiteral = readBooleanLiteral;\n  function readBooleanLiteral(parser) {\n  \tvar remaining = parser.remaining();\n\n  \tif (remaining.substr(0, 4) === \"true\") {\n  \t\tparser.pos += 4;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"true\"\n  \t\t};\n  \t}\n\n  \tif (remaining.substr(0, 5) === \"false\") {\n  \t\tparser.pos += 5;\n  \t\treturn {\n  \t\t\tt: BOOLEAN_LITERAL,\n  \t\t\tv: \"false\"\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;\n\n  // Match one or more characters until: \", ', \\, or EOL/EOF.\n  // EOL/EOF is written as (?!.) (meaning there's no non-newline char next).\n  stringMiddlePattern = /^(?=.)[^\"'\\\\]+?(?:(?!.)|(?=[\"'\\\\]))/;\n\n  // Match one escape sequence, including the backslash.\n  escapeSequencePattern = /^\\\\(?:['\"\\\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;\n\n  // Match one ES5 line continuation (backslash + line terminator).\n  lineContinuationPattern = /^\\\\(?:\\r\\n|[\\u000A\\u000D\\u2028\\u2029])/;\n\n  // Helper for defining getDoubleQuotedString and getSingleQuotedString.\n  var makeQuotedStringMatcher = function (okQuote) {\n  \treturn function (parser) {\n  \t\tvar start, literal, done, next;\n\n  \t\tstart = parser.pos;\n  \t\tliteral = \"\\\"\";\n  \t\tdone = false;\n\n  \t\twhile (!done) {\n  \t\t\tnext = parser.matchPattern(stringMiddlePattern) || parser.matchPattern(escapeSequencePattern) || parser.matchString(okQuote);\n  \t\t\tif (next) {\n  \t\t\t\tif (next === \"\\\"\") {\n  \t\t\t\t\tliteral += \"\\\\\\\"\";\n  \t\t\t\t} else if (next === \"\\\\'\") {\n  \t\t\t\t\tliteral += \"'\";\n  \t\t\t\t} else {\n  \t\t\t\t\tliteral += next;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tnext = parser.matchPattern(lineContinuationPattern);\n  \t\t\t\tif (next) {\n  \t\t\t\t\t// convert \\(newline-like) into a \\u escape, which is allowed in JSON\n  \t\t\t\t\tliteral += \"\\\\u\" + (\"000\" + next.charCodeAt(1).toString(16)).slice(-4);\n  \t\t\t\t} else {\n  \t\t\t\t\tdone = true;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tliteral += \"\\\"\";\n\n  \t\t// use JSON.parse to interpret escapes\n  \t\treturn JSON.parse(literal);\n  \t};\n  };\n\n  var getSingleQuotedString = makeQuotedStringMatcher(\"\\\"\");\n  var getDoubleQuotedString = makeQuotedStringMatcher(\"'\");\n\n  var readStringLiteral = function (parser) {\n  \tvar start, string;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"\\\"\")) {\n  \t\tstring = getDoubleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"\\\"\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \tif (parser.matchString(\"'\")) {\n  \t\tstring = getSingleQuotedString(parser);\n\n  \t\tif (!parser.matchString(\"'\")) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: STRING_LITERAL,\n  \t\t\tv: string\n  \t\t};\n  \t}\n\n  \treturn null;\n  };\n\n  var patterns__name = /^[a-zA-Z_$][a-zA-Z_$0-9]*/;\n\n  // http://mathiasbynens.be/notes/javascript-properties\n  // can be any name, string literal, or number literal\n  var shared_readKey = readKey;\n  var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n  function readKey(parser) {\n  \tvar token;\n\n  \tif (token = readStringLiteral(parser)) {\n  \t\treturn identifier.test(token.v) ? token.v : \"\\\"\" + token.v.replace(/\"/g, \"\\\\\\\"\") + \"\\\"\";\n  \t}\n\n  \tif (token = literal_readNumberLiteral(parser)) {\n  \t\treturn token.v;\n  \t}\n\n  \tif (token = parser.matchPattern(patterns__name)) {\n  \t\treturn token;\n  \t}\n  }\n\n  var keyValuePair = readKeyValuePair;\n  function readKeyValuePair(parser) {\n  \tvar start, key, value;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace between '{' and key\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n  \tif (key === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between key and ':'\n  \tparser.allowWhitespace();\n\n  \t// next character must be ':'\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \t// allow whitespace between ':' and value\n  \tparser.allowWhitespace();\n\n  \t// next expression must be a, well... expression\n  \tvalue = converters_readExpression(parser);\n  \tif (value === null) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: KEY_VALUE_PAIR,\n  \t\tk: key,\n  \t\tv: value\n  \t};\n  }\n\n  var objectLiteral_keyValuePairs = readKeyValuePairs;\n  function readKeyValuePairs(parser) {\n  \tvar start, pairs, pair, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \tpair = keyValuePair(parser);\n  \tif (pair === null) {\n  \t\treturn null;\n  \t}\n\n  \tpairs = [pair];\n\n  \tif (parser.matchString(\",\")) {\n  \t\tkeyValuePairs = readKeyValuePairs(parser);\n\n  \t\tif (!keyValuePairs) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn pairs.concat(keyValuePairs);\n  \t}\n\n  \treturn pairs;\n  }\n\n  var readObjectLiteral = function (parser) {\n  \tvar start, keyValuePairs;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"{\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tkeyValuePairs = objectLiteral_keyValuePairs(parser);\n\n  \t// allow whitespace between final value and '}'\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"}\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: OBJECT_LITERAL,\n  \t\tm: keyValuePairs\n  \t};\n  };\n\n  var shared_readExpressionList = readExpressionList;\n  function readExpressionList(parser) {\n  \tvar start, expressions, expr, next;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n\n  \tif (expr === null) {\n  \t\treturn null;\n  \t}\n\n  \texpressions = [expr];\n\n  \t// allow whitespace between expression and ','\n  \tparser.allowWhitespace();\n\n  \tif (parser.matchString(\",\")) {\n  \t\tnext = readExpressionList(parser);\n  \t\tif (next === null) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tnext.forEach(append);\n  \t}\n\n  \tfunction append(expression) {\n  \t\texpressions.push(expression);\n  \t}\n\n  \treturn expressions;\n  }\n\n  var readArrayLiteral = function (parser) {\n  \tvar start, expressionList;\n\n  \tstart = parser.pos;\n\n  \t// allow whitespace before '['\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"[\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpressionList = shared_readExpressionList(parser);\n\n  \tif (!parser.matchString(\"]\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tt: ARRAY_LITERAL,\n  \t\tm: expressionList\n  \t};\n  };\n\n  var primary_readLiteral = readLiteral;\n  function readLiteral(parser) {\n  \treturn literal_readNumberLiteral(parser) || literal_readBooleanLiteral(parser) || readStringLiteral(parser) || readObjectLiteral(parser) || readArrayLiteral(parser) || readRegexpLiteral(parser);\n  }\n\n  var primary_readReference = readReference;\n  var prefixPattern = /^(?:~\\/|(?:\\.\\.\\/)+|\\.\\/(?:\\.\\.\\/)*|\\.)/,\n      globals,\n      keywords;\n\n  // if a reference is a browser global, we don't deference it later, so it needs special treatment\n  globals = /^(?:Array|console|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)\\b/;\n\n  // keywords are not valid references, with the exception of `this`\n  keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;\n\n  var legalReference = /^[a-zA-Z$_0-9]+(?:(?:\\.[a-zA-Z$_0-9]+)|(?:\\[[0-9]+\\]))*/;\n  var relaxedName = /^[a-zA-Z_$][-a-zA-Z_$0-9]*/;\n  function readReference(parser) {\n  \tvar startPos, prefix, name, global, reference, lastDotIndex;\n\n  \tstartPos = parser.pos;\n\n  \tname = parser.matchPattern(/^@(?:keypath|index|key)/);\n\n  \tif (!name) {\n  \t\tprefix = parser.matchPattern(prefixPattern) || \"\";\n  \t\tname = !prefix && parser.relaxedNames && parser.matchPattern(relaxedName) || parser.matchPattern(legalReference);\n\n  \t\tif (!name && prefix === \".\") {\n  \t\t\tprefix = \"\";\n  \t\t\tname = \".\";\n  \t\t}\n  \t}\n\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \t// bug out if it's a keyword (exception for ancestor/restricted refs - see https://github.com/ractivejs/ractive/issues/1497)\n  \tif (!prefix && !parser.relaxedNames && keywords.test(name)) {\n  \t\tparser.pos = startPos;\n  \t\treturn null;\n  \t}\n\n  \t// if this is a browser global, stop here\n  \tif (!prefix && globals.test(name)) {\n  \t\tglobal = globals.exec(name)[0];\n  \t\tparser.pos = startPos + global.length;\n\n  \t\treturn {\n  \t\t\tt: GLOBAL,\n  \t\t\tv: global\n  \t\t};\n  \t}\n\n  \treference = (prefix || \"\") + normalise(name);\n\n  \tif (parser.matchString(\"(\")) {\n  \t\t// if this is a method invocation (as opposed to a function) we need\n  \t\t// to strip the method name from the reference combo, else the context\n  \t\t// will be wrong\n  \t\tlastDotIndex = reference.lastIndexOf(\".\");\n  \t\tif (lastDotIndex !== -1) {\n  \t\t\treference = reference.substr(0, lastDotIndex);\n  \t\t\tparser.pos = startPos + reference.length;\n  \t\t} else {\n  \t\t\tparser.pos -= 1;\n  \t\t}\n  \t}\n\n  \treturn {\n  \t\tt: REFERENCE,\n  \t\tn: reference.replace(/^this\\./, \"./\").replace(/^this$/, \".\")\n  \t};\n  }\n\n  var primary_readBracketedExpression = readBracketedExpression;\n  function readBracketedExpression(parser) {\n  \tvar start, expr;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\"(\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpr = converters_readExpression(parser);\n  \tif (!expr) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\")\")) {\n  \t\tparser.error(expectedParen);\n  \t}\n\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expr\n  \t};\n  }\n\n  var readPrimary = function (parser) {\n  \treturn primary_readLiteral(parser) || primary_readReference(parser) || primary_readBracketedExpression(parser);\n  };\n\n  var shared_readRefinement = readRefinement;\n  function readRefinement(parser) {\n  \tvar start, name, expr;\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \t// \".\" name\n  \tif (parser.matchString(\".\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\tif (name = parser.matchPattern(patterns__name)) {\n  \t\t\treturn {\n  \t\t\t\tt: REFINEMENT,\n  \t\t\t\tn: name\n  \t\t\t};\n  \t\t}\n\n  \t\tparser.error(\"Expected a property name\");\n  \t}\n\n  \t// \"[\" expression \"]\"\n  \tif (parser.matchString(\"[\")) {\n  \t\tparser.allowWhitespace();\n\n  \t\texpr = converters_readExpression(parser);\n  \t\tif (!expr) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (!parser.matchString(\"]\")) {\n  \t\t\tparser.error(\"Expected ']'\");\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: REFINEMENT,\n  \t\t\tx: expr\n  \t\t};\n  \t}\n\n  \treturn null;\n  }\n\n  var readMemberOrInvocation = function (parser) {\n  \tvar current, expression, refinement, expressionList;\n\n  \texpression = readPrimary(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \twhile (expression) {\n  \t\tcurrent = parser.pos;\n\n  \t\tif (refinement = shared_readRefinement(parser)) {\n  \t\t\texpression = {\n  \t\t\t\tt: MEMBER,\n  \t\t\t\tx: expression,\n  \t\t\t\tr: refinement\n  \t\t\t};\n  \t\t} else if (parser.matchString(\"(\")) {\n  \t\t\tparser.allowWhitespace();\n  \t\t\texpressionList = shared_readExpressionList(parser);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(\")\")) {\n  \t\t\t\tparser.error(expectedParen);\n  \t\t\t}\n\n  \t\t\texpression = {\n  \t\t\t\tt: INVOCATION,\n  \t\t\t\tx: expression\n  \t\t\t};\n\n  \t\t\tif (expressionList) {\n  \t\t\t\texpression.o = expressionList;\n  \t\t\t}\n  \t\t} else {\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \treturn expression;\n  };\n\n  var readTypeOf, makePrefixSequenceMatcher;\n\n  makePrefixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar expression;\n\n  \t\tif (expression = fallthrough(parser)) {\n  \t\t\treturn expression;\n  \t\t}\n\n  \t\tif (!parser.matchString(symbol)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n\n  \t\texpression = converters_readExpression(parser);\n  \t\tif (!expression) {\n  \t\t\tparser.error(expectedExpression);\n  \t\t}\n\n  \t\treturn {\n  \t\t\ts: symbol,\n  \t\t\to: expression,\n  \t\t\tt: PREFIX_OPERATOR\n  \t\t};\n  \t};\n  };\n\n  // create all prefix sequence matchers, return readTypeOf\n  (function () {\n  \tvar i, len, matcher, prefixOperators, fallthrough;\n\n  \tprefixOperators = \"! ~ + - typeof\".split(\" \");\n\n  \tfallthrough = readMemberOrInvocation;\n  \tfor (i = 0, len = prefixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makePrefixSequenceMatcher(prefixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// typeof operator is higher precedence than multiplication, so provides the\n  \t// fallthrough for the multiplication sequence matcher we're about to create\n  \t// (we're skipping void and delete)\n  \treadTypeOf = fallthrough;\n  })();\n\n  var readTypeof = readTypeOf;\n\n  var readLogicalOr, makeInfixSequenceMatcher;\n\n  makeInfixSequenceMatcher = function (symbol, fallthrough) {\n  \treturn function (parser) {\n  \t\tvar start, left, right;\n\n  \t\tleft = fallthrough(parser);\n  \t\tif (!left) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\t// Loop to handle left-recursion in a case like `a * b * c` and produce\n  \t\t// left association, i.e. `(a * b) * c`.  The matcher can't call itself\n  \t\t// to parse `left` because that would be infinite regress.\n  \t\twhile (true) {\n  \t\t\tstart = parser.pos;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (!parser.matchString(symbol)) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\t// special case - in operator must not be followed by [a-zA-Z_$0-9]\n  \t\t\tif (symbol === \"in\" && /[a-zA-Z_$0-9]/.test(parser.remaining().charAt(0))) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\t// right operand must also consist of only higher-precedence operators\n  \t\t\tright = fallthrough(parser);\n  \t\t\tif (!right) {\n  \t\t\t\tparser.pos = start;\n  \t\t\t\treturn left;\n  \t\t\t}\n\n  \t\t\tleft = {\n  \t\t\t\tt: INFIX_OPERATOR,\n  \t\t\t\ts: symbol,\n  \t\t\t\to: [left, right]\n  \t\t\t};\n\n  \t\t\t// Loop back around.  If we don't see another occurrence of the symbol,\n  \t\t\t// we'll return left.\n  \t\t}\n  \t};\n  };\n\n  // create all infix sequence matchers, and return readLogicalOr\n  (function () {\n  \tvar i, len, matcher, infixOperators, fallthrough;\n\n  \t// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)\n  \t// Each sequence matcher will initially fall through to its higher precedence\n  \t// neighbour, and only attempt to match if one of the higher precedence operators\n  \t// (or, ultimately, a literal, reference, or bracketed expression) already matched\n  \tinfixOperators = \"* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||\".split(\" \");\n\n  \t// A typeof operator is higher precedence than multiplication\n  \tfallthrough = readTypeof;\n  \tfor (i = 0, len = infixOperators.length; i < len; i += 1) {\n  \t\tmatcher = makeInfixSequenceMatcher(infixOperators[i], fallthrough);\n  \t\tfallthrough = matcher;\n  \t}\n\n  \t// Logical OR is the fallthrough for the conditional matcher\n  \treadLogicalOr = fallthrough;\n  })();\n\n  var expressions_readLogicalOr = readLogicalOr;\n\n  // The conditional operator is the lowest precedence operator, so we start here\n  var readConditional = getConditional;\n  function getConditional(parser) {\n  \tvar start, expression, ifTrue, ifFalse;\n\n  \texpression = expressions_readLogicalOr(parser);\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"?\")) {\n  \t\tparser.pos = start;\n  \t\treturn expression;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifTrue = converters_readExpression(parser);\n  \tif (!ifTrue) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\":\")) {\n  \t\tparser.error(\"Expected \\\":\\\"\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tifFalse = converters_readExpression(parser);\n  \tif (!ifFalse) {\n  \t\tparser.error(expectedExpression);\n  \t}\n\n  \treturn {\n  \t\tt: CONDITIONAL,\n  \t\to: [expression, ifTrue, ifFalse]\n  \t};\n  }\n\n  var converters_readExpression = readExpression;\n  function readExpression(parser) {\n  \t// The conditional operator is the lowest precedence operator (except yield,\n  \t// assignment operators, and commas, none of which are supported), so we\n  \t// start there. If it doesn't match, it 'falls through' to progressively\n  \t// higher precedence operators, until it eventually matches (or fails to\n  \t// match) a 'primary' - a literal or a reference. This way, the abstract syntax\n  \t// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.\n  \treturn readConditional(parser);\n  }\n\n  var utils_flattenExpression = flattenExpression;\n\n  function flattenExpression(expression) {\n  \tvar refs;\n\n  \textractRefs(expression, refs = []);\n\n  \treturn {\n  \t\tr: refs,\n  \t\ts: stringify(expression)\n  \t};\n\n  \tfunction stringify(node) {\n  \t\tswitch (node.t) {\n  \t\t\tcase BOOLEAN_LITERAL:\n  \t\t\tcase GLOBAL:\n  \t\t\tcase NUMBER_LITERAL:\n  \t\t\tcase REGEXP_LITERAL:\n  \t\t\t\treturn node.v;\n\n  \t\t\tcase STRING_LITERAL:\n  \t\t\t\treturn JSON.stringify(String(node.v));\n\n  \t\t\tcase ARRAY_LITERAL:\n  \t\t\t\treturn \"[\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"]\";\n\n  \t\t\tcase OBJECT_LITERAL:\n  \t\t\t\treturn \"{\" + (node.m ? node.m.map(stringify).join(\",\") : \"\") + \"}\";\n\n  \t\t\tcase KEY_VALUE_PAIR:\n  \t\t\t\treturn node.k + \":\" + stringify(node.v);\n\n  \t\t\tcase PREFIX_OPERATOR:\n  \t\t\t\treturn (node.s === \"typeof\" ? \"typeof \" : node.s) + stringify(node.o);\n\n  \t\t\tcase INFIX_OPERATOR:\n  \t\t\t\treturn stringify(node.o[0]) + (node.s.substr(0, 2) === \"in\" ? \" \" + node.s + \" \" : node.s) + stringify(node.o[1]);\n\n  \t\t\tcase INVOCATION:\n  \t\t\t\treturn stringify(node.x) + \"(\" + (node.o ? node.o.map(stringify).join(\",\") : \"\") + \")\";\n\n  \t\t\tcase BRACKETED:\n  \t\t\t\treturn \"(\" + stringify(node.x) + \")\";\n\n  \t\t\tcase MEMBER:\n  \t\t\t\treturn stringify(node.x) + stringify(node.r);\n\n  \t\t\tcase REFINEMENT:\n  \t\t\t\treturn node.n ? \".\" + node.n : \"[\" + stringify(node.x) + \"]\";\n\n  \t\t\tcase CONDITIONAL:\n  \t\t\t\treturn stringify(node.o[0]) + \"?\" + stringify(node.o[1]) + \":\" + stringify(node.o[2]);\n\n  \t\t\tcase REFERENCE:\n  \t\t\t\treturn \"_\" + refs.indexOf(node.n);\n\n  \t\t\tdefault:\n  \t\t\t\tthrow new Error(\"Expected legal JavaScript\");\n  \t\t}\n  \t}\n  }\n\n  // TODO maybe refactor this?\n  function extractRefs(node, refs) {\n  \tvar i, list;\n\n  \tif (node.t === REFERENCE) {\n  \t\tif (refs.indexOf(node.n) === -1) {\n  \t\t\trefs.unshift(node.n);\n  \t\t}\n  \t}\n\n  \tlist = node.o || node.m;\n  \tif (list) {\n  \t\tif (isObject(list)) {\n  \t\t\textractRefs(list, refs);\n  \t\t} else {\n  \t\t\ti = list.length;\n  \t\t\twhile (i--) {\n  \t\t\t\textractRefs(list[i], refs);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (node.x) {\n  \t\textractRefs(node.x, refs);\n  \t}\n\n  \tif (node.r) {\n  \t\textractRefs(node.r, refs);\n  \t}\n\n  \tif (node.v) {\n  \t\textractRefs(node.v, refs);\n  \t}\n  }\n\n  var utils_refineExpression = refineExpression;\n\n  var arrayMemberPattern = /^[0-9][1-9]*$/;\n  function refineExpression(expression, mustache) {\n  \tvar referenceExpression;\n\n  \tif (expression) {\n  \t\twhile (expression.t === BRACKETED && expression.x) {\n  \t\t\texpression = expression.x;\n  \t\t}\n\n  \t\t// special case - integers should be treated as array members references,\n  \t\t// rather than as expressions in their own right\n  \t\tif (expression.t === REFERENCE) {\n  \t\t\tmustache.r = expression.n;\n  \t\t} else {\n  \t\t\tif (expression.t === NUMBER_LITERAL && arrayMemberPattern.test(expression.v)) {\n  \t\t\t\tmustache.r = expression.v;\n  \t\t\t} else if (referenceExpression = getReferenceExpression(expression)) {\n  \t\t\t\tmustache.rx = referenceExpression;\n  \t\t\t} else {\n  \t\t\t\tmustache.x = utils_flattenExpression(expression);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn mustache;\n  \t}\n  }\n\n  // TODO refactor this! it's bewildering\n  function getReferenceExpression(expression) {\n  \tvar members = [],\n  \t    refinement;\n\n  \twhile (expression.t === MEMBER && expression.r.t === REFINEMENT) {\n  \t\trefinement = expression.r;\n\n  \t\tif (refinement.x) {\n  \t\t\tif (refinement.x.t === REFERENCE) {\n  \t\t\t\tmembers.unshift(refinement.x);\n  \t\t\t} else {\n  \t\t\t\tmembers.unshift(utils_flattenExpression(refinement.x));\n  \t\t\t}\n  \t\t} else {\n  \t\t\tmembers.unshift(refinement.n);\n  \t\t}\n\n  \t\texpression = expression.x;\n  \t}\n\n  \tif (expression.t !== REFERENCE) {\n  \t\treturn null;\n  \t}\n\n  \treturn {\n  \t\tr: expression.n,\n  \t\tm: members\n  \t};\n  }\n\n  var mustache_readTriple = readTriple;\n  function readTriple(parser, tag) {\n  \tvar expression = converters_readExpression(parser),\n  \t    triple;\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readUnescaped = readUnescaped;\n  function readUnescaped(parser, tag) {\n  \tvar expression, triple;\n\n  \tif (!parser.matchString(\"&\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \ttriple = { t: TRIPLE };\n  \tutils_refineExpression(expression, triple); // TODO handle this differently - it's mysterious\n\n  \treturn triple;\n  }\n\n  var mustache_readPartial = readPartial;\n  function readPartial(parser, tag) {\n  \tvar start, nameStart, expression, context, partial;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n  \tnameStart = parser.pos;\n\n  \t// Partial names can include hyphens, so we can't use readExpression\n  \t// blindly. Instead, we use the `relaxedNames` flag to indicate that\n  \t// `foo-bar` should be read as a single name, rather than 'subtract\n  \t// bar from foo'\n  \tparser.relaxedNames = true;\n  \texpression = converters_readExpression(parser);\n  \tparser.relaxedNames = false;\n\n  \tparser.allowWhitespace();\n  \tcontext = converters_readExpression(parser);\n  \tparser.allowWhitespace();\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tpartial = { t: PARTIAL };\n  \tutils_refineExpression(expression, partial); // TODO...\n\n  \tparser.allowWhitespace();\n\n  \t// if we have another expression - e.g. `{{>foo bar}}` - then\n  \t// we turn it into `{{#with bar}}{{>foo}}{{/with}}`\n  \tif (context) {\n  \t\tpartial = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_WITH,\n  \t\t\tf: [partial]\n  \t\t};\n\n  \t\tutils_refineExpression(context, partial);\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn partial;\n  }\n\n  var readMustacheComment = readComment;\n  function readComment(parser, tag) {\n  \tvar index;\n\n  \tif (!parser.matchString(\"!\")) {\n  \t\treturn null;\n  \t}\n\n  \tindex = parser.remaining().indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tparser.pos += index + tag.close.length;\n  \t\treturn { t: COMMENT };\n  \t}\n  }\n\n  var converters_readExpressionOrReference = readExpressionOrReference;\n  function readExpressionOrReference(parser, expectedFollowers) {\n  \tvar start, expression, i;\n\n  \tstart = parser.pos;\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\treturn null;\n  \t}\n\n  \tfor (i = 0; i < expectedFollowers.length; i += 1) {\n  \t\tif (parser.remaining().substr(0, expectedFollowers[i].length) === expectedFollowers[i]) {\n  \t\t\treturn expression;\n  \t\t}\n  \t}\n\n  \tparser.pos = start;\n  \treturn primary_readReference(parser);\n  }\n\n  var mustache_readInterpolator = readInterpolator;\n  function readInterpolator(parser, tag) {\n  \tvar start, expression, interpolator, err;\n\n  \tstart = parser.pos;\n\n  \t// TODO would be good for perf if we could do away with the try-catch\n  \ttry {\n  \t\texpression = converters_readExpressionOrReference(parser, [tag.close]);\n  \t} catch (e) {\n  \t\terr = e;\n  \t}\n\n  \tif (!expression) {\n  \t\tif (parser.str.charAt(start) === \"!\") {\n  \t\t\t// special case - comment\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tif (err) {\n  \t\t\tthrow err;\n  \t\t}\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"' after reference\");\n\n  \t\tif (!expression) {\n  \t\t\t// special case - comment\n  \t\t\tif (parser.nextChar() === \"!\") {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.error(\"Expected expression or legal reference\");\n  \t\t}\n  \t}\n\n  \tinterpolator = { t: INTERPOLATOR };\n  \tutils_refineExpression(expression, interpolator); // TODO handle this differently - it's mysterious\n\n  \treturn interpolator;\n  }\n\n  var mustache_readYielder = readYielder;\n  var yieldPattern = /^yield\\s*/;\n  function readYielder(parser, tag) {\n  \tvar start, name, yielder;\n\n  \tif (!parser.matchPattern(yieldPattern)) {\n  \t\treturn null;\n  \t}\n\n  \tstart = parser.pos;\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tyielder = { t: YIELDER };\n\n  \tif (name) {\n  \t\tyielder.n = name;\n  \t}\n\n  \treturn yielder;\n  }\n\n  var section_readClosing = readClosing;\n  function readClosing(parser, tag) {\n  \tvar start, remaining, index, closing;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"/\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tremaining = parser.remaining();\n  \tindex = remaining.indexOf(tag.close);\n\n  \tif (index !== -1) {\n  \t\tclosing = {\n  \t\t\tt: CLOSING,\n  \t\t\tr: remaining.substr(0, index).split(\" \")[0]\n  \t\t};\n\n  \t\tparser.pos += index;\n\n  \t\tif (!parser.matchString(tag.close)) {\n  \t\t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t\t}\n\n  \t\treturn closing;\n  \t}\n\n  \tparser.pos = start;\n  \treturn null;\n  }\n\n  var section_readElse = section_readElse__readElse;\n  var section_readElse__elsePattern = /^\\s*else\\s*/;\n  function section_readElse__readElse(parser, tag) {\n  \tvar start = parser.pos;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(section_readElse__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSE\n  \t};\n  }\n\n  var readElseIf = readElseIf__readElse;\n  var readElseIf__elsePattern = /^\\s*elseif\\s+/;\n  function readElseIf__readElse(parser, tag) {\n  \tvar start = parser.pos,\n  \t    expression;\n\n  \tif (!parser.matchString(tag.open)) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(readElseIf__elsePattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \treturn {\n  \t\tt: ELSEIF,\n  \t\tx: expression\n  \t};\n  }\n\n  var handlebarsBlockCodes = {\n  \teach: SECTION_EACH,\n  \t\"if\": SECTION_IF,\n  \t\"if-with\": SECTION_IF_WITH,\n  \t\"with\": SECTION_WITH,\n  \tunless: SECTION_UNLESS\n  };\n\n  var mustache_readSection = readSection;\n\n  var indexRefPattern = /^\\s*:\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      keyIndexRefPattern = /^\\s*,\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,\n      handlebarsBlockPattern = new RegExp(\"^(\" + Object.keys(handlebarsBlockCodes).join(\"|\") + \")\\\\b\");\n  function readSection(parser, tag) {\n  \tvar start, expression, section, child, children, hasElse, block, unlessBlock, conditions, closed, i, expectedClose;\n\n  \tstart = parser.pos;\n\n  \tif (parser.matchString(\"^\")) {\n  \t\tsection = { t: SECTION, f: [], n: SECTION_UNLESS };\n  \t} else if (parser.matchString(\"#\")) {\n  \t\tsection = { t: SECTION, f: [] };\n\n  \t\tif (parser.matchString(\"partial\")) {\n  \t\t\tparser.pos = start - parser.standardDelimiters[0].length;\n  \t\t\tparser.error(\"Partial definitions can only be at the top level of the template, or immediately inside components\");\n  \t\t}\n\n  \t\tif (block = parser.matchPattern(handlebarsBlockPattern)) {\n  \t\t\texpectedClose = block;\n  \t\t\tsection.n = handlebarsBlockCodes[block];\n  \t\t}\n  \t} else {\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \texpression = converters_readExpression(parser);\n\n  \tif (!expression) {\n  \t\tparser.error(\"Expected expression\");\n  \t}\n\n  \t// optional index and key references\n  \tif (i = parser.matchPattern(indexRefPattern)) {\n  \t\tvar extra = undefined;\n\n  \t\tif (extra = parser.matchPattern(keyIndexRefPattern)) {\n  \t\t\tsection.i = i + \",\" + extra;\n  \t\t} else {\n  \t\t\tsection.i = i;\n  \t\t}\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(tag.close)) {\n  \t\tparser.error(\"Expected closing delimiter '\" + tag.close + \"'\");\n  \t}\n\n  \tparser.sectionDepth += 1;\n  \tchildren = section.f;\n\n  \tconditions = [];\n\n  \tdo {\n  \t\tif (child = section_readClosing(parser, tag)) {\n  \t\t\tif (expectedClose && child.r !== expectedClose) {\n  \t\t\t\tparser.error(\"Expected \" + tag.open + \"/\" + expectedClose + \"\" + tag.close);\n  \t\t\t}\n\n  \t\t\tparser.sectionDepth -= 1;\n  \t\t\tclosed = true;\n  \t\t} else if (child = readElseIf(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"illegal {{elseif...}} after {{else}}\");\n  \t\t\t}\n\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t}\n\n  \t\t\tunlessBlock.f.push({\n  \t\t\t\tt: SECTION,\n  \t\t\t\tn: SECTION_IF,\n  \t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions.concat(child.x))),\n  \t\t\t\tf: children = []\n  \t\t\t});\n\n  \t\t\tconditions.push(invert(child.x));\n  \t\t} else if (child = section_readElse(parser, tag)) {\n  \t\t\tif (section.n === SECTION_UNLESS) {\n  \t\t\t\tparser.error(\"{{else}} not allowed in {{#unless}}\");\n  \t\t\t}\n\n  \t\t\tif (hasElse) {\n  \t\t\t\tparser.error(\"there can only be one {{else}} block, at the end of a section\");\n  \t\t\t}\n\n  \t\t\thasElse = true;\n\n  \t\t\t// use an unless block if there's no elseif\n  \t\t\tif (!unlessBlock) {\n  \t\t\t\tunlessBlock = createUnlessBlock(expression, section.n);\n  \t\t\t\tchildren = unlessBlock.f;\n  \t\t\t} else {\n  \t\t\t\tunlessBlock.f.push({\n  \t\t\t\t\tt: SECTION,\n  \t\t\t\t\tn: SECTION_IF,\n  \t\t\t\t\tx: utils_flattenExpression(mustache_readSection__combine(conditions)),\n  \t\t\t\t\tf: children = []\n  \t\t\t\t});\n  \t\t\t}\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tchildren.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \tif (unlessBlock) {\n  \t\t// special case - `with` should become `if-with` (TODO is this right?\n  \t\t// seems to me that `with` ought to behave consistently, regardless\n  \t\t// of the presence/absence of `else`. In other words should always\n  \t\t// be `if-with`\n  \t\tif (section.n === SECTION_WITH) {\n  \t\t\tsection.n = SECTION_IF_WITH;\n  \t\t}\n\n  \t\tsection.l = unlessBlock;\n  \t}\n\n  \tutils_refineExpression(expression, section);\n\n  \t// TODO if a section is empty it should be discarded. Don't do\n  \t// that here though - we need to clean everything up first, as\n  \t// it may contain removeable whitespace. As a temporary measure,\n  \t// to pass the existing tests, remove empty `f` arrays\n  \tif (!section.f.length) {\n  \t\tdelete section.f;\n  \t}\n\n  \treturn section;\n  }\n\n  function createUnlessBlock(expression, sectionType) {\n  \tvar unlessBlock;\n\n  \tif (sectionType === SECTION_WITH) {\n  \t\t// special case - a `{{#with foo}}` section will render if `foo` is\n  \t\t// truthy, so the `{{else}}` section needs to render if `foo` is falsy,\n  \t\t// rather than adhering to the normal `{{#unless foo}}` logic (which\n  \t\t// treats empty arrays/objects as falsy)\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_IF,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(invert(expression), unlessBlock);\n  \t} else {\n  \t\tunlessBlock = {\n  \t\t\tt: SECTION,\n  \t\t\tn: SECTION_UNLESS,\n  \t\t\tf: []\n  \t\t};\n\n  \t\tutils_refineExpression(expression, unlessBlock);\n  \t}\n\n  \treturn unlessBlock;\n  }\n\n  function invert(expression) {\n  \tif (expression.t === PREFIX_OPERATOR && expression.s === \"!\") {\n  \t\treturn expression.o;\n  \t}\n\n  \treturn {\n  \t\tt: PREFIX_OPERATOR,\n  \t\ts: \"!\",\n  \t\to: parensIfNecessary(expression)\n  \t};\n  }\n\n  function mustache_readSection__combine(expressions) {\n  \tif (expressions.length === 1) {\n  \t\treturn expressions[0];\n  \t}\n\n  \treturn {\n  \t\tt: INFIX_OPERATOR,\n  \t\ts: \"&&\",\n  \t\to: [parensIfNecessary(expressions[0]), parensIfNecessary(mustache_readSection__combine(expressions.slice(1)))]\n  \t};\n  }\n\n  function parensIfNecessary(expression) {\n  \t// TODO only wrap if necessary\n  \treturn {\n  \t\tt: BRACKETED,\n  \t\tx: expression\n  \t};\n  }\n\n  var converters_readHtmlComment = readHtmlComment;\n  var OPEN_COMMENT = \"<!--\",\n      CLOSE_COMMENT = \"-->\";\n  function readHtmlComment(parser) {\n  \tvar start, content, remaining, endIndex, comment;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(OPEN_COMMENT)) {\n  \t\treturn null;\n  \t}\n\n  \tremaining = parser.remaining();\n  \tendIndex = remaining.indexOf(CLOSE_COMMENT);\n\n  \tif (endIndex === -1) {\n  \t\tparser.error(\"Illegal HTML - expected closing comment sequence ('-->')\");\n  \t}\n\n  \tcontent = remaining.substr(0, endIndex);\n  \tparser.pos += endIndex + 3;\n\n  \tcomment = {\n  \t\tt: COMMENT,\n  \t\tc: content\n  \t};\n\n  \tif (parser.includeLinePositions) {\n  \t\tcomment.p = parser.getLinePos(start);\n  \t}\n\n  \treturn comment;\n  }\n\n  var booleanAttributes, voidElementNames, htmlEntities, controlCharacters, entityPattern, lessThan, greaterThan, amp;\n\n  // https://github.com/kangax/html-minifier/issues/63#issuecomment-37763316\n  booleanAttributes = /^(allowFullscreen|async|autofocus|autoplay|checked|compact|controls|declare|default|defaultChecked|defaultMuted|defaultSelected|defer|disabled|enabled|formNoValidate|hidden|indeterminate|inert|isMap|itemScope|loop|multiple|muted|noHref|noResize|noShade|noValidate|noWrap|open|pauseOnExit|readOnly|required|reversed|scoped|seamless|selected|sortable|translate|trueSpeed|typeMustMatch|visible)$/i;\n  voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;\n\n  htmlEntities = { quot: 34, amp: 38, apos: 39, lt: 60, gt: 62, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221, THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252, yacute: 253, thorn: 254, yuml: 255, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 };\n  controlCharacters = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376];\n  entityPattern = new RegExp(\"&(#?(?:x[\\\\w\\\\d]+|\\\\d+|\" + Object.keys(htmlEntities).join(\"|\") + \"));?\", \"g\");\n\n  function decodeCharacterReferences(html) {\n  \treturn html.replace(entityPattern, function (match, entity) {\n  \t\tvar code;\n\n  \t\t// Handle named entities\n  \t\tif (entity[0] !== \"#\") {\n  \t\t\tcode = htmlEntities[entity];\n  \t\t} else if (entity[1] === \"x\") {\n  \t\t\tcode = parseInt(entity.substring(2), 16);\n  \t\t} else {\n  \t\t\tcode = parseInt(entity.substring(1), 10);\n  \t\t}\n\n  \t\tif (!code) {\n  \t\t\treturn match;\n  \t\t}\n\n  \t\treturn String.fromCharCode(validateCode(code));\n  \t});\n  }\n\n  // some code points are verboten. If we were inserting HTML, the browser would replace the illegal\n  // code points with alternatives in some cases - since we're bypassing that mechanism, we need\n  // to replace them ourselves\n  //\n  // Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters\n  function validateCode(code) {\n  \tif (!code) {\n  \t\treturn 65533;\n  \t}\n\n  \t// line feed becomes generic whitespace\n  \tif (code === 10) {\n  \t\treturn 32;\n  \t}\n\n  \t// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)\n  \tif (code < 128) {\n  \t\treturn code;\n  \t}\n\n  \t// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need\n  \t// to correct the mistake or we'll end up with missing € signs and so on\n  \tif (code <= 159) {\n  \t\treturn controlCharacters[code - 128];\n  \t}\n\n  \t// basic multilingual plane\n  \tif (code < 55296) {\n  \t\treturn code;\n  \t}\n\n  \t// UTF-16 surrogate halves\n  \tif (code <= 57343) {\n  \t\treturn 65533;\n  \t}\n\n  \t// rest of the basic multilingual plane\n  \tif (code <= 65535) {\n  \t\treturn code;\n  \t}\n\n  \treturn 65533;\n  }\n\n  lessThan = /</g;\n  greaterThan = />/g;\n  amp = /&/g;\n\n  function escapeHtml(str) {\n  \treturn str.replace(amp, \"&amp;\").replace(lessThan, \"&lt;\").replace(greaterThan, \"&gt;\");\n  }\n\n  var leadingLinebreak = /^\\s*\\r?\\n/,\n      trailingLinebreak = /\\r?\\n\\s*$/;\n\n  var stripStandalones = function (items) {\n  \tvar i, current, backOne, backTwo, lastSectionItem;\n\n  \tfor (i = 1; i < items.length; i += 1) {\n  \t\tcurrent = items[i];\n  \t\tbackOne = items[i - 1];\n  \t\tbackTwo = items[i - 2];\n\n  \t\t// if we're at the end of a [text][comment][text] sequence...\n  \t\tif (isString(current) && isComment(backOne) && isString(backTwo)) {\n\n  \t\t\t// ... and the comment is a standalone (i.e. line breaks either side)...\n  \t\t\tif (trailingLinebreak.test(backTwo) && leadingLinebreak.test(current)) {\n\n  \t\t\t\t// ... then we want to remove the whitespace after the first line break\n  \t\t\t\titems[i - 2] = backTwo.replace(trailingLinebreak, \"\\n\");\n\n  \t\t\t\t// and the leading line break of the second text token\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the current item is a section, and it is preceded by a linebreak, and\n  \t\t// its first item is a linebreak...\n  \t\tif (isSection(current) && isString(backOne)) {\n  \t\t\tif (trailingLinebreak.test(backOne) && isString(current.f[0]) && leadingLinebreak.test(current.f[0])) {\n  \t\t\t\titems[i - 1] = backOne.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\tcurrent.f[0] = current.f[0].replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// if the last item was a section, and it is followed by a linebreak, and\n  \t\t// its last item is a linebreak...\n  \t\tif (isString(current) && isSection(backOne)) {\n  \t\t\tlastSectionItem = lastItem(backOne.f);\n\n  \t\t\tif (isString(lastSectionItem) && trailingLinebreak.test(lastSectionItem) && leadingLinebreak.test(current)) {\n  \t\t\t\tbackOne.f[backOne.f.length - 1] = lastSectionItem.replace(trailingLinebreak, \"\\n\");\n  \t\t\t\titems[i] = current.replace(leadingLinebreak, \"\");\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn items;\n  };\n\n  function isString(item) {\n  \treturn typeof item === \"string\";\n  }\n\n  function isComment(item) {\n  \treturn item.t === COMMENT || item.t === DELIMCHANGE;\n  }\n\n  function isSection(item) {\n  \treturn (item.t === SECTION || item.t === INVERTED) && item.f;\n  }\n\n  var trimWhitespace = function (items, leadingPattern, trailingPattern) {\n  \tvar item;\n\n  \tif (leadingPattern) {\n  \t\titem = items[0];\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(leadingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.shift();\n  \t\t\t} else {\n  \t\t\t\titems[0] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (trailingPattern) {\n  \t\titem = lastItem(items);\n  \t\tif (typeof item === \"string\") {\n  \t\t\titem = item.replace(trailingPattern, \"\");\n\n  \t\t\tif (!item) {\n  \t\t\t\titems.pop();\n  \t\t\t} else {\n  \t\t\t\titems[items.length - 1] = item;\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  var utils_cleanup = cleanup;\n  var contiguousWhitespace = /[ \\t\\f\\r\\n]+/g;\n  var preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i;\n  var utils_cleanup__leadingWhitespace = /^[ \\t\\f\\r\\n]+/;\n  var trailingWhitespace = /[ \\t\\f\\r\\n]+$/;\n  var leadingNewLine = /^(?:\\r\\n|\\r|\\n)/;\n  var trailingNewLine = /(?:\\r\\n|\\r|\\n)$/;\n  function cleanup(items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace) {\n  \tvar i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, key;\n\n  \t// First pass - remove standalones and comments etc\n  \tstripStandalones(items);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Remove delimiter changes, unsafe elements etc\n  \t\tif (item.exclude) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n\n  \t\t// Remove comments, unless we want to keep them\n  \t\telse if (stripComments && item.t === COMMENT) {\n  \t\t\titems.splice(i, 1);\n  \t\t}\n  \t}\n\n  \t// If necessary, remove leading and trailing whitespace\n  \ttrimWhitespace(items, removeLeadingWhitespace ? utils_cleanup__leadingWhitespace : null, removeTrailingWhitespace ? trailingWhitespace : null);\n\n  \ti = items.length;\n  \twhile (i--) {\n  \t\titem = items[i];\n\n  \t\t// Recurse\n  \t\tif (item.f) {\n  \t\t\tvar isPreserveWhitespaceElement = item.t === ELEMENT && preserveWhitespaceElements.test(item.e);\n  \t\t\tpreserveWhitespaceInsideFragment = preserveWhitespace || isPreserveWhitespaceElement;\n\n  \t\t\tif (!preserveWhitespace && isPreserveWhitespaceElement) {\n  \t\t\t\ttrimWhitespace(item.f, leadingNewLine, trailingNewLine);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespaceInsideFragment) {\n  \t\t\t\tpreviousItem = items[i - 1];\n  \t\t\t\tnextItem = items[i + 1];\n\n  \t\t\t\t// if the previous item was a text item with trailing whitespace,\n  \t\t\t\t// remove leading whitespace inside the fragment\n  \t\t\t\tif (!previousItem || typeof previousItem === \"string\" && trailingWhitespace.test(previousItem)) {\n  \t\t\t\t\tremoveLeadingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n\n  \t\t\t\t// and vice versa\n  \t\t\t\tif (!nextItem || typeof nextItem === \"string\" && utils_cleanup__leadingWhitespace.test(nextItem)) {\n  \t\t\t\t\tremoveTrailingWhitespaceInsideFragment = true;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tcleanup(item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Split if-else blocks into two (an if, and an unless)\n  \t\tif (item.l) {\n  \t\t\tcleanup(item.l.f, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n\n  \t\t\titems.splice(i + 1, 0, item.l);\n  \t\t\tdelete item.l; // TODO would be nice if there was a way around this\n  \t\t}\n\n  \t\t// Clean up element attributes\n  \t\tif (item.a) {\n  \t\t\tfor (key in item.a) {\n  \t\t\t\tif (item.a.hasOwnProperty(key) && typeof item.a[key] !== \"string\") {\n  \t\t\t\t\tcleanup(item.a[key], stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// Clean up conditional attributes\n  \t\tif (item.m) {\n  \t\t\tcleanup(item.m, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t}\n\n  \t\t// Clean up event handlers\n  \t\tif (item.v) {\n  \t\t\tfor (key in item.v) {\n  \t\t\t\tif (item.v.hasOwnProperty(key)) {\n  \t\t\t\t\t// clean up names\n  \t\t\t\t\tif (isArray(item.v[key].n)) {\n  \t\t\t\t\t\tcleanup(item.v[key].n, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// clean up params\n  \t\t\t\t\tif (isArray(item.v[key].d)) {\n  \t\t\t\t\t\tcleanup(item.v[key].d, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// final pass - fuse text nodes together\n  \ti = items.length;\n  \twhile (i--) {\n  \t\tif (typeof items[i] === \"string\") {\n  \t\t\tif (typeof items[i + 1] === \"string\") {\n  \t\t\t\titems[i] = items[i] + items[i + 1];\n  \t\t\t\titems.splice(i + 1, 1);\n  \t\t\t}\n\n  \t\t\tif (!preserveWhitespace) {\n  \t\t\t\titems[i] = items[i].replace(contiguousWhitespace, \" \");\n  \t\t\t}\n\n  \t\t\tif (items[i] === \"\") {\n  \t\t\t\titems.splice(i, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var element_readClosingTag = readClosingTag;\n  var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*)\\s*\\>/;\n  function readClosingTag(parser) {\n  \tvar start, tag;\n\n  \tstart = parser.pos;\n\n  \t// are we looking at a closing tag?\n  \tif (!parser.matchString(\"</\")) {\n  \t\treturn null;\n  \t}\n\n  \tif (tag = parser.matchPattern(closingTagPattern)) {\n  \t\tif (parser.inside && tag !== parser.inside) {\n  \t\t\tparser.pos = start;\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn {\n  \t\t\tt: CLOSING_TAG,\n  \t\t\te: tag\n  \t\t};\n  \t}\n\n  \t// We have an illegal closing tag, report it\n  \tparser.pos -= 2;\n  \tparser.error(\"Illegal closing tag\");\n  }\n\n  var getLowestIndex = function (haystack, needles) {\n  \tvar i, index, lowest;\n\n  \ti = needles.length;\n  \twhile (i--) {\n  \t\tindex = haystack.indexOf(needles[i]);\n\n  \t\t// short circuit\n  \t\tif (!index) {\n  \t\t\treturn 0;\n  \t\t}\n\n  \t\tif (index === -1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (!lowest || index < lowest) {\n  \t\t\tlowest = index;\n  \t\t}\n  \t}\n\n  \treturn lowest || -1;\n  };\n\n  var element_readAttribute = readAttribute;\n\n  var attributeNamePattern = /^[^\\s\"'>\\/=]+/,\n      unquotedAttributeValueTextPattern = /^[^\\s\"'=<>`]+/;\n  function readAttribute(parser) {\n  \tvar attr, name, value;\n\n  \tparser.allowWhitespace();\n\n  \tname = parser.matchPattern(attributeNamePattern);\n  \tif (!name) {\n  \t\treturn null;\n  \t}\n\n  \tattr = { name: name };\n\n  \tvalue = readAttributeValue(parser);\n  \tif (value != null) {\n  \t\t// not null/undefined\n  \t\tattr.value = value;\n  \t}\n\n  \treturn attr;\n  }\n\n  function readAttributeValue(parser) {\n  \tvar start, valueStart, startDepth, value;\n\n  \tstart = parser.pos;\n\n  \t// next character must be `=`, `/`, `>` or whitespace\n  \tif (!/[=\\/>\\s]/.test(parser.nextChar())) {\n  \t\tparser.error(\"Expected `=`, `/`, `>` or whitespace\");\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tif (!parser.matchString(\"=\")) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.allowWhitespace();\n\n  \tvalueStart = parser.pos;\n  \tstartDepth = parser.sectionDepth;\n\n  \tvalue = readQuotedAttributeValue(parser, \"'\") || readQuotedAttributeValue(parser, \"\\\"\") || readUnquotedAttributeValue(parser);\n\n  \tif (value === null) {\n  \t\tparser.error(\"Expected valid attribute value\");\n  \t}\n\n  \tif (parser.sectionDepth !== startDepth) {\n  \t\tparser.pos = valueStart;\n  \t\tparser.error(\"An attribute value must contain as many opening section tags as closing section tags\");\n  \t}\n\n  \tif (!value.length) {\n  \t\treturn \"\";\n  \t}\n\n  \tif (value.length === 1 && typeof value[0] === \"string\") {\n  \t\treturn decodeCharacterReferences(value[0]);\n  \t}\n\n  \treturn value;\n  }\n\n  function readUnquotedAttributeValueToken(parser) {\n  \tvar start, text, haystack, needles, index;\n\n  \tstart = parser.pos;\n\n  \ttext = parser.matchPattern(unquotedAttributeValueTextPattern);\n\n  \tif (!text) {\n  \t\treturn null;\n  \t}\n\n  \thaystack = text;\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n\n  \tif ((index = getLowestIndex(haystack, needles)) !== -1) {\n  \t\ttext = text.substr(0, index);\n  \t\tparser.pos = start + text.length;\n  \t}\n\n  \treturn text;\n  }\n\n  function readUnquotedAttributeValue(parser) {\n  \tvar tokens, token;\n\n  \tparser.inAttribute = true;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readUnquotedAttributeValueToken(parser);\n  \t}\n\n  \tif (!tokens.length) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n  \treturn tokens;\n  }\n\n  function readQuotedAttributeValue(parser, quoteMark) {\n  \tvar start, tokens, token;\n\n  \tstart = parser.pos;\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = quoteMark;\n\n  \ttokens = [];\n\n  \ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \twhile (token !== null) {\n  \t\ttokens.push(token);\n  \t\ttoken = converters_readMustache(parser) || readQuotedStringToken(parser, quoteMark);\n  \t}\n\n  \tif (!parser.matchString(quoteMark)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tparser.inAttribute = false;\n\n  \treturn tokens;\n  }\n\n  function readQuotedStringToken(parser, quoteMark) {\n  \tvar start, index, haystack, needles;\n\n  \tstart = parser.pos;\n  \thaystack = parser.remaining();\n\n  \tneedles = parser.tags.map(function (t) {\n  \t\treturn t.open;\n  \t}); // TODO refactor... we do this in readText.js as well\n  \tneedles.push(quoteMark);\n\n  \tindex = getLowestIndex(haystack, needles);\n\n  \tif (index === -1) {\n  \t\tparser.error(\"Quoted attribute value must have a closing quote\");\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tparser.pos += index;\n  \treturn haystack.substr(0, index);\n  }\n\n  var JsonParser, specials, specialsPattern, parseJSON__numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;\n\n  specials = {\n  \t\"true\": true,\n  \t\"false\": false,\n  \tundefined: undefined,\n  \t\"null\": null\n  };\n\n  specialsPattern = new RegExp(\"^(?:\" + Object.keys(specials).join(\"|\") + \")\");\n  parseJSON__numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\\d*)?\\.\\d+)|(?:(?:0|[1-9]\\d*)\\.)|(?:0|[1-9]\\d*))(?:[eE][+-]?\\d+)?/;\n  placeholderPattern = /\\$\\{([^\\}]+)\\}/g;\n  placeholderAtStartPattern = /^\\$\\{([^\\}]+)\\}/;\n  onlyWhitespace = /^\\s*$/;\n\n  JsonParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tthis.values = options.values;\n  \t\tthis.allowWhitespace();\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\tif (result.length !== 1 || !onlyWhitespace.test(this.leftover)) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn { value: result[0].v };\n  \t},\n\n  \tconverters: [function getPlaceholder(parser) {\n  \t\tvar placeholder;\n\n  \t\tif (!parser.values) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tplaceholder = parser.matchPattern(placeholderAtStartPattern);\n\n  \t\tif (placeholder && parser.values.hasOwnProperty(placeholder)) {\n  \t\t\treturn { v: parser.values[placeholder] };\n  \t\t}\n  \t}, function getSpecial(parser) {\n  \t\tvar special;\n\n  \t\tif (special = parser.matchPattern(specialsPattern)) {\n  \t\t\treturn { v: specials[special] };\n  \t\t}\n  \t}, function getNumber(parser) {\n  \t\tvar number;\n\n  \t\tif (number = parser.matchPattern(parseJSON__numberPattern)) {\n  \t\t\treturn { v: +number };\n  \t\t}\n  \t}, function getString(parser) {\n  \t\tvar stringLiteral = readStringLiteral(parser),\n  \t\t    values;\n\n  \t\tif (stringLiteral && (values = parser.values)) {\n  \t\t\treturn {\n  \t\t\t\tv: stringLiteral.v.replace(placeholderPattern, function (match, $1) {\n  \t\t\t\t\treturn $1 in values ? values[$1] : $1;\n  \t\t\t\t})\n  \t\t\t};\n  \t\t}\n\n  \t\treturn stringLiteral;\n  \t}, function getObject(parser) {\n  \t\tvar result, pair;\n\n  \t\tif (!parser.matchString(\"{\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = {};\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"}\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (pair = getKeyValuePair(parser)) {\n  \t\t\tresult[pair.key] = pair.value;\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"}\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}, function getArray(parser) {\n  \t\tvar result, valueToken;\n\n  \t\tif (!parser.matchString(\"[\")) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\tresult = [];\n\n  \t\tparser.allowWhitespace();\n\n  \t\tif (parser.matchString(\"]\")) {\n  \t\t\treturn { v: result };\n  \t\t}\n\n  \t\twhile (valueToken = parser.read()) {\n  \t\t\tresult.push(valueToken.v);\n\n  \t\t\tparser.allowWhitespace();\n\n  \t\t\tif (parser.matchString(\"]\")) {\n  \t\t\t\treturn { v: result };\n  \t\t\t}\n\n  \t\t\tif (!parser.matchString(\",\")) {\n  \t\t\t\treturn null;\n  \t\t\t}\n\n  \t\t\tparser.allowWhitespace();\n  \t\t}\n\n  \t\treturn null;\n  \t}]\n  });\n\n  function getKeyValuePair(parser) {\n  \tvar key, valueToken, pair;\n\n  \tparser.allowWhitespace();\n\n  \tkey = shared_readKey(parser);\n\n  \tif (!key) {\n  \t\treturn null;\n  \t}\n\n  \tpair = { key: key };\n\n  \tparser.allowWhitespace();\n  \tif (!parser.matchString(\":\")) {\n  \t\treturn null;\n  \t}\n  \tparser.allowWhitespace();\n\n  \tvalueToken = parser.read();\n  \tif (!valueToken) {\n  \t\treturn null;\n  \t}\n\n  \tpair.value = valueToken.v;\n\n  \treturn pair;\n  }\n\n  var parseJSON = function (str, values) {\n  \tvar parser = new JsonParser(str, {\n  \t\tvalues: values\n  \t});\n\n  \treturn parser.result;\n  };\n\n  // TODO clean this up, it's shocking\n  var element_processDirective = processDirective;\n  var methodCallPattern = /^([a-zA-Z_$][a-zA-Z_$0-9]*)\\(/,\n      methodCallExcessPattern = /\\)\\s*$/,\n      ExpressionParser;\n\n  ExpressionParser = parse_Parser.extend({\n  \tconverters: [converters_readExpression]\n  });\n  function processDirective(tokens, parentParser) {\n  \tvar result, match, parser, args, token, colonIndex, directiveName, directiveArgs, parsed;\n\n  \tif (typeof tokens === \"string\") {\n  \t\tif (match = methodCallPattern.exec(tokens)) {\n  \t\t\tvar end = tokens.lastIndexOf(\")\");\n\n  \t\t\t// check for invalid method calls\n  \t\t\tif (!methodCallExcessPattern.test(tokens)) {\n  \t\t\t\tparentParser.error(\"Invalid input after method call expression '\" + tokens.slice(end + 1) + \"'\");\n  \t\t\t}\n\n  \t\t\tresult = { m: match[1] };\n  \t\t\targs = \"[\" + tokens.slice(result.m.length + 1, end) + \"]\";\n\n  \t\t\tparser = new ExpressionParser(args);\n  \t\t\tresult.a = utils_flattenExpression(parser.result[0]);\n\n  \t\t\treturn result;\n  \t\t}\n\n  \t\tif (tokens.indexOf(\":\") === -1) {\n  \t\t\treturn tokens.trim();\n  \t\t}\n\n  \t\ttokens = [tokens];\n  \t}\n\n  \tresult = {};\n\n  \tdirectiveName = [];\n  \tdirectiveArgs = [];\n\n  \tif (tokens) {\n  \t\twhile (tokens.length) {\n  \t\t\ttoken = tokens.shift();\n\n  \t\t\tif (typeof token === \"string\") {\n  \t\t\t\tcolonIndex = token.indexOf(\":\");\n\n  \t\t\t\tif (colonIndex === -1) {\n  \t\t\t\t\tdirectiveName.push(token);\n  \t\t\t\t} else {\n\n  \t\t\t\t\t// is the colon the first character?\n  \t\t\t\t\tif (colonIndex) {\n  \t\t\t\t\t\t// no\n  \t\t\t\t\t\tdirectiveName.push(token.substr(0, colonIndex));\n  \t\t\t\t\t}\n\n  \t\t\t\t\t// if there is anything after the colon in this token, treat\n  \t\t\t\t\t// it as the first token of the directiveArgs fragment\n  \t\t\t\t\tif (token.length > colonIndex + 1) {\n  \t\t\t\t\t\tdirectiveArgs[0] = token.substring(colonIndex + 1);\n  \t\t\t\t\t}\n\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tdirectiveName.push(token);\n  \t\t\t}\n  \t\t}\n\n  \t\tdirectiveArgs = directiveArgs.concat(tokens);\n  \t}\n\n  \tif (!directiveName.length) {\n  \t\tresult = \"\";\n  \t} else if (directiveArgs.length || typeof directiveName !== \"string\") {\n  \t\tresult = {\n  \t\t\t// TODO is this really necessary? just use the array\n  \t\t\tn: directiveName.length === 1 && typeof directiveName[0] === \"string\" ? directiveName[0] : directiveName\n  \t\t};\n\n  \t\tif (directiveArgs.length === 1 && typeof directiveArgs[0] === \"string\") {\n  \t\t\tparsed = parseJSON(\"[\" + directiveArgs[0] + \"]\");\n  \t\t\tresult.a = parsed ? parsed.value : directiveArgs[0].trim();\n  \t\t} else {\n  \t\t\tresult.d = directiveArgs;\n  \t\t}\n  \t} else {\n  \t\tresult = directiveName;\n  \t}\n\n  \treturn result;\n  }\n\n  var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\\-]*/,\n      validTagNameFollower = /^[\\s\\n\\/>]/,\n      onPattern = /^on/,\n      proxyEventPattern = /^on-([a-zA-Z\\\\*\\\\.$_][a-zA-Z\\\\*\\\\.$_0-9\\-]+)$/,\n      reservedEventNames = /^(?:change|reset|teardown|update|construct|config|init|render|unrender|detach|insert)$/,\n      directives = { \"intro-outro\": \"t0\", intro: \"t1\", outro: \"t2\", decorator: \"o\" },\n      exclude = { exclude: true },\n      disallowedContents;\n\n  // based on http://developers.whatwg.org/syntax.html#syntax-tag-omission\n  disallowedContents = {\n  \tli: [\"li\"],\n  \tdt: [\"dt\", \"dd\"],\n  \tdd: [\"dt\", \"dd\"],\n  \tp: \"address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul\".split(\" \"),\n  \trt: [\"rt\", \"rp\"],\n  \trp: [\"rt\", \"rp\"],\n  \toptgroup: [\"optgroup\"],\n  \toption: [\"option\", \"optgroup\"],\n  \tthead: [\"tbody\", \"tfoot\"],\n  \ttbody: [\"tbody\", \"tfoot\"],\n  \ttfoot: [\"tbody\"],\n  \ttr: [\"tr\", \"tbody\"],\n  \ttd: [\"td\", \"th\", \"tr\"],\n  \tth: [\"td\", \"th\", \"tr\"]\n  };\n\n  var converters_readElement = readElement;\n\n  function readElement(parser) {\n  \tvar start, element, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, partials, hasPartials, child, closed, pos, remaining, closingTag;\n\n  \tstart = parser.pos;\n\n  \tif (parser.inside || parser.inAttribute) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchString(\"<\")) {\n  \t\treturn null;\n  \t}\n\n  \t// if this is a closing tag, abort straight away\n  \tif (parser.nextChar() === \"/\") {\n  \t\treturn null;\n  \t}\n\n  \telement = {};\n  \tif (parser.includeLinePositions) {\n  \t\telement.p = parser.getLinePos(start);\n  \t}\n\n  \tif (parser.matchString(\"!\")) {\n  \t\telement.t = DOCTYPE;\n  \t\tif (!parser.matchPattern(/^doctype/i)) {\n  \t\t\tparser.error(\"Expected DOCTYPE declaration\");\n  \t\t}\n\n  \t\telement.a = parser.matchPattern(/^(.+?)>/);\n  \t\treturn element;\n  \t}\n\n  \telement.t = ELEMENT;\n\n  \t// element name\n  \telement.e = parser.matchPattern(tagNamePattern);\n  \tif (!element.e) {\n  \t\treturn null;\n  \t}\n\n  \t// next character must be whitespace, closing solidus or '>'\n  \tif (!validTagNameFollower.test(parser.nextChar())) {\n  \t\tparser.error(\"Illegal tag name\");\n  \t}\n\n  \taddProxyEvent = function (name, directive) {\n  \t\tvar directiveName = directive.n || directive;\n\n  \t\tif (reservedEventNames.test(directiveName)) {\n  \t\t\tparser.pos -= directiveName.length;\n  \t\t\tparser.error(\"Cannot use reserved event names (change, reset, teardown, update, construct, config, init, render, unrender, detach, insert)\");\n  \t\t}\n\n  \t\telement.v[name] = directive;\n  \t};\n\n  \tparser.allowWhitespace();\n\n  \t// directives and attributes\n  \twhile (attribute = converters_readMustache(parser) || element_readAttribute(parser)) {\n  \t\t// regular attributes\n  \t\tif (attribute.name) {\n  \t\t\t// intro, outro, decorator\n  \t\t\tif (directiveName = directives[attribute.name]) {\n  \t\t\t\telement[directiveName] = element_processDirective(attribute.value, parser);\n  \t\t\t}\n\n  \t\t\t// on-click etc\n  \t\t\telse if (match = proxyEventPattern.exec(attribute.name)) {\n  \t\t\t\tif (!element.v) element.v = {};\n  \t\t\t\tdirective = element_processDirective(attribute.value, parser);\n  \t\t\t\taddProxyEvent(match[1], directive);\n  \t\t\t} else {\n  \t\t\t\tif (!parser.sanitizeEventAttributes || !onPattern.test(attribute.name)) {\n  \t\t\t\t\tif (!element.a) element.a = {};\n  \t\t\t\t\telement.a[attribute.name] = attribute.value || (attribute.value === \"\" ? \"\" : 0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// {{#if foo}}class='foo'{{/if}}\n  \t\telse {\n  \t\t\tif (!element.m) element.m = [];\n  \t\t\telement.m.push(attribute);\n  \t\t}\n\n  \t\tparser.allowWhitespace();\n  \t}\n\n  \t// allow whitespace before closing solidus\n  \tparser.allowWhitespace();\n\n  \t// self-closing solidus?\n  \tif (parser.matchString(\"/\")) {\n  \t\tselfClosing = true;\n  \t}\n\n  \t// closing angle bracket\n  \tif (!parser.matchString(\">\")) {\n  \t\treturn null;\n  \t}\n\n  \tvar lowerCaseName = element.e.toLowerCase();\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \tif (!selfClosing && !voidElementNames.test(element.e)) {\n  \t\tparser.elementStack.push(lowerCaseName);\n\n  \t\t// Special case - if we open a script element, further tags should\n  \t\t// be ignored unless they're a closing script element\n  \t\tif (lowerCaseName === \"script\" || lowerCaseName === \"style\") {\n  \t\t\tparser.inside = lowerCaseName;\n  \t\t}\n\n  \t\tchildren = [];\n  \t\tpartials = create(null);\n\n  \t\tdo {\n  \t\t\tpos = parser.pos;\n  \t\t\tremaining = parser.remaining();\n\n  \t\t\t// if for example we're in an <li> element, and we see another\n  \t\t\t// <li> tag, close the first so they become siblings\n  \t\t\tif (!canContain(lowerCaseName, remaining)) {\n  \t\t\t\tclosed = true;\n  \t\t\t}\n\n  \t\t\t// closing tag\n  \t\t\telse if (closingTag = element_readClosingTag(parser)) {\n  \t\t\t\tclosed = true;\n\n  \t\t\t\tvar closingTagName = closingTag.e.toLowerCase();\n\n  \t\t\t\t// if this *isn't* the closing tag for the current element...\n  \t\t\t\tif (closingTagName !== lowerCaseName) {\n  \t\t\t\t\t// rewind parser\n  \t\t\t\t\tparser.pos = pos;\n\n  \t\t\t\t\t// if it doesn't close a parent tag, error\n  \t\t\t\t\tif (! ~parser.elementStack.indexOf(closingTagName)) {\n  \t\t\t\t\t\tvar errorMessage = \"Unexpected closing tag\";\n\n  \t\t\t\t\t\t// add additional help for void elements, since component names\n  \t\t\t\t\t\t// might clash with them\n  \t\t\t\t\t\tif (voidElementNames.test(closingTagName)) {\n  \t\t\t\t\t\t\terrorMessage += \" (<\" + closingTagName + \"> is a void element - it cannot contain children)\";\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\tparser.error(errorMessage);\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// implicit close by closing section tag. TODO clean this up\n  \t\t\telse if (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\t\tclosed = true;\n  \t\t\t\tparser.pos = pos;\n  \t\t\t} else {\n  \t\t\t\tif (child = parser.read(PARTIAL_READERS)) {\n  \t\t\t\t\tif (partials[child.n]) {\n  \t\t\t\t\t\tparser.pos = pos;\n  \t\t\t\t\t\tparser.error(\"Duplicate partial definition\");\n  \t\t\t\t\t}\n\n  \t\t\t\t\tutils_cleanup(child.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\t\t\tpartials[child.n] = child.f;\n  \t\t\t\t\thasPartials = true;\n  \t\t\t\t} else {\n  \t\t\t\t\tif (child = parser.read(READERS)) {\n  \t\t\t\t\t\tchildren.push(child);\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tclosed = true;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} while (!closed);\n\n  \t\tif (children.length) {\n  \t\t\telement.f = children;\n  \t\t}\n\n  \t\tif (hasPartials) {\n  \t\t\telement.p = partials;\n  \t\t}\n\n  \t\tparser.elementStack.pop();\n  \t}\n\n  \tparser.inside = null;\n\n  \tif (parser.sanitizeElements && parser.sanitizeElements.indexOf(lowerCaseName) !== -1) {\n  \t\treturn exclude;\n  \t}\n\n  \treturn element;\n  }\n\n  function canContain(name, remaining) {\n  \tvar match, disallowed;\n\n  \tmatch = /^<([a-zA-Z][a-zA-Z0-9]*)/.exec(remaining);\n  \tdisallowed = disallowedContents[name];\n\n  \tif (!match || !disallowed) {\n  \t\treturn true;\n  \t}\n\n  \treturn ! ~disallowed.indexOf(match[1].toLowerCase());\n  }\n\n  var converters_readText = readText;\n  function readText(parser) {\n  \tvar index, remaining, disallowed, barrier;\n\n  \tremaining = parser.remaining();\n\n  \tbarrier = parser.inside ? \"</\" + parser.inside : \"<\";\n\n  \tif (parser.inside && !parser.interpolate[parser.inside]) {\n  \t\tindex = remaining.indexOf(barrier);\n  \t} else {\n  \t\tdisallowed = parser.tags.map(function (t) {\n  \t\t\treturn t.open;\n  \t\t});\n  \t\tdisallowed = disallowed.concat(parser.tags.map(function (t) {\n  \t\t\treturn \"\\\\\" + t.open;\n  \t\t}));\n\n  \t\t// http://developers.whatwg.org/syntax.html#syntax-attributes\n  \t\tif (parser.inAttribute === true) {\n  \t\t\t// we're inside an unquoted attribute value\n  \t\t\tdisallowed.push(\"\\\"\", \"'\", \"=\", \"<\", \">\", \"`\");\n  \t\t} else if (parser.inAttribute) {\n  \t\t\t// quoted attribute value\n  \t\t\tdisallowed.push(parser.inAttribute);\n  \t\t} else {\n  \t\t\tdisallowed.push(barrier);\n  \t\t}\n\n  \t\tindex = getLowestIndex(remaining, disallowed);\n  \t}\n\n  \tif (!index) {\n  \t\treturn null;\n  \t}\n\n  \tif (index === -1) {\n  \t\tindex = remaining.length;\n  \t}\n\n  \tparser.pos += index;\n\n  \treturn parser.inside ? remaining.substr(0, index) : decodeCharacterReferences(remaining.substr(0, index));\n  }\n\n  var utils_escapeRegExp = escapeRegExp;\n  var utils_escapeRegExp__pattern = /[-/\\\\^$*+?.()|[\\]{}]/g;\n  function escapeRegExp(str) {\n  \treturn str.replace(utils_escapeRegExp__pattern, \"\\\\$&\");\n  }\n\n  var converters_readPartialDefinitionComment = readPartialDefinitionComment;\n\n  var startPattern = /^<!--\\s*/,\n      namePattern = /s*>\\s*([a-zA-Z_$][-a-zA-Z_$0-9]*)\\s*/,\n      finishPattern = /\\s*-->/,\n      child;\n\n  function readPartialDefinitionComment(parser) {\n  \tvar firstPos = parser.pos,\n  \t    open = parser.standardDelimiters[0],\n  \t    close = parser.standardDelimiters[1],\n  \t    content = undefined,\n  \t    closed = undefined;\n\n  \tif (!parser.matchPattern(startPattern) || !parser.matchString(open)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tvar name = parser.matchPattern(namePattern);\n\n  \twarnOnceIfDebug(\"Inline partial comments are deprecated.\\nUse this...\\n  {{#partial \" + name + \"}} ... {{/partial}}\\n\\n...instead of this:\\n  <!-- {{>\" + name + \"}} --> ... <!-- {{/\" + name + \"}} -->'\");\n\n  \t// make sure the rest of the comment is in the correct place\n  \tif (!parser.matchString(close) || !parser.matchPattern(finishPattern)) {\n  \t\tparser.pos = firstPos;\n  \t\treturn null;\n  \t}\n\n  \tcontent = [];\n\n  \tvar endPattern = new RegExp(\"^<!--\\\\s*\" + utils_escapeRegExp(open) + \"\\\\s*\\\\/\\\\s*\" + name + \"\\\\s*\" + utils_escapeRegExp(close) + \"\\\\s*-->\");\n\n  \tdo {\n  \t\tif (parser.matchPattern(endPattern)) {\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"expected closing comment ('<!-- \" + open + \"/\" + name + \"\" + close + \" -->')\");\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tf: content,\n  \t\tn: name\n  \t};\n  }\n\n  var converters_readPartialDefinitionSection = readPartialDefinitionSection;\n  var partialDefinitionSectionPattern = /^#\\s*partial\\s+/;\n  function readPartialDefinitionSection(parser) {\n  \tvar start, name, content, child, closed;\n\n  \tstart = parser.pos;\n\n  \tvar delimiters = parser.standardDelimiters;\n\n  \tif (!parser.matchString(delimiters[0])) {\n  \t\treturn null;\n  \t}\n\n  \tif (!parser.matchPattern(partialDefinitionSectionPattern)) {\n  \t\tparser.pos = start;\n  \t\treturn null;\n  \t}\n\n  \tname = parser.matchPattern(/^[a-zA-Z_$][a-zA-Z_$0-9\\-]*/);\n\n  \tif (!name) {\n  \t\tparser.error(\"expected legal partial name\");\n  \t}\n\n  \tif (!parser.matchString(delimiters[1])) {\n  \t\tparser.error(\"Expected closing delimiter '\" + delimiters[1] + \"'\");\n  \t}\n\n  \tcontent = [];\n\n  \tdo {\n  \t\t// TODO clean this up\n  \t\tif (child = section_readClosing(parser, { open: parser.standardDelimiters[0], close: parser.standardDelimiters[1] })) {\n  \t\t\tif (!child.r === \"partial\") {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tclosed = true;\n  \t\t} else {\n  \t\t\tchild = parser.read(READERS);\n\n  \t\t\tif (!child) {\n  \t\t\t\tparser.error(\"Expected \" + delimiters[0] + \"/partial\" + delimiters[1]);\n  \t\t\t}\n\n  \t\t\tcontent.push(child);\n  \t\t}\n  \t} while (!closed);\n\n  \treturn {\n  \t\tt: INLINE_PARTIAL,\n  \t\tn: name,\n  \t\tf: content\n  \t};\n  }\n\n  var converters_readTemplate = readTemplate;\n  function readTemplate(parser) {\n  \tvar fragment = [];\n  \tvar partials = create(null);\n  \tvar hasPartials = false;\n\n  \tvar preserveWhitespace = parser.preserveWhitespace;\n\n  \twhile (parser.pos < parser.str.length) {\n  \t\tvar pos = parser.pos,\n  \t\t    item = undefined,\n  \t\t    partial = undefined;\n\n  \t\tif (partial = parser.read(PARTIAL_READERS)) {\n  \t\t\tif (partials[partial.n]) {\n  \t\t\t\tparser.pos = pos;\n  \t\t\t\tparser.error(\"Duplicated partial definition\");\n  \t\t\t}\n\n  \t\t\tutils_cleanup(partial.f, parser.stripComments, preserveWhitespace, !preserveWhitespace, !preserveWhitespace);\n\n  \t\t\tpartials[partial.n] = partial.f;\n  \t\t\thasPartials = true;\n  \t\t} else if (item = parser.read(READERS)) {\n  \t\t\tfragment.push(item);\n  \t\t} else {\n  \t\t\tparser.error(\"Unexpected template content\");\n  \t\t}\n  \t}\n\n  \tvar result = {\n  \t\tv: TEMPLATE_VERSION,\n  \t\tt: fragment\n  \t};\n\n  \tif (hasPartials) {\n  \t\tresult.p = partials;\n  \t}\n\n  \treturn result;\n  }\n\n  var _parse = parse;\n\n  var STANDARD_READERS = [mustache_readPartial, mustache_readUnescaped, mustache_readSection, mustache_readYielder, mustache_readInterpolator, readMustacheComment];\n  var TRIPLE_READERS = [mustache_readTriple];\n  var STATIC_READERS = [mustache_readUnescaped, mustache_readSection, mustache_readInterpolator]; // TODO does it make sense to have a static section?\n\n  var StandardParser = undefined;\n  function parse(template, options) {\n  \treturn new StandardParser(template, options || {}).result;\n  }\n\n  var READERS = [converters_readMustache, converters_readHtmlComment, converters_readElement, converters_readText];\n  var PARTIAL_READERS = [converters_readPartialDefinitionComment, converters_readPartialDefinitionSection];\n\n  StandardParser = parse_Parser.extend({\n  \tinit: function (str, options) {\n  \t\tvar tripleDelimiters = options.tripleDelimiters || [\"{{{\", \"}}}\"],\n  \t\t    staticDelimiters = options.staticDelimiters || [\"[[\", \"]]\"],\n  \t\t    staticTripleDelimiters = options.staticTripleDelimiters || [\"[[[\", \"]]]\"];\n\n  \t\tthis.standardDelimiters = options.delimiters || [\"{{\", \"}}\"];\n\n  \t\tthis.tags = [{ isStatic: false, isTriple: false, open: this.standardDelimiters[0], close: this.standardDelimiters[1], readers: STANDARD_READERS }, { isStatic: false, isTriple: true, open: tripleDelimiters[0], close: tripleDelimiters[1], readers: TRIPLE_READERS }, { isStatic: true, isTriple: false, open: staticDelimiters[0], close: staticDelimiters[1], readers: STATIC_READERS }, { isStatic: true, isTriple: true, open: staticTripleDelimiters[0], close: staticTripleDelimiters[1], readers: TRIPLE_READERS }];\n\n  \t\tthis.sortMustacheTags();\n\n  \t\tthis.sectionDepth = 0;\n  \t\tthis.elementStack = [];\n\n  \t\tthis.interpolate = {\n  \t\t\tscript: !options.interpolate || options.interpolate.script !== false,\n  \t\t\tstyle: !options.interpolate || options.interpolate.style !== false\n  \t\t};\n\n  \t\tif (options.sanitize === true) {\n  \t\t\toptions.sanitize = {\n  \t\t\t\t// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json\n  \t\t\t\telements: \"applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title\".split(\" \"),\n  \t\t\t\teventAttributes: true\n  \t\t\t};\n  \t\t}\n\n  \t\tthis.stripComments = options.stripComments !== false;\n  \t\tthis.preserveWhitespace = options.preserveWhitespace;\n  \t\tthis.sanitizeElements = options.sanitize && options.sanitize.elements;\n  \t\tthis.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;\n  \t\tthis.includeLinePositions = options.includeLinePositions;\n  \t},\n\n  \tpostProcess: function (result) {\n  \t\t// special case - empty string\n  \t\tif (!result.length) {\n  \t\t\treturn { t: [], v: TEMPLATE_VERSION };\n  \t\t}\n\n  \t\tif (this.sectionDepth > 0) {\n  \t\t\tthis.error(\"A section was left open\");\n  \t\t}\n\n  \t\tutils_cleanup(result[0].t, this.stripComments, this.preserveWhitespace, !this.preserveWhitespace, !this.preserveWhitespace);\n\n  \t\treturn result[0];\n  \t},\n\n  \tconverters: [converters_readTemplate],\n\n  \tsortMustacheTags: function () {\n  \t\t// Sort in order of descending opening delimiter length (longer first),\n  \t\t// to protect against opening delimiters being substrings of each other\n  \t\tthis.tags.sort(function (a, b) {\n  \t\t\treturn b.open.length - a.open.length;\n  \t\t});\n  \t}\n  });\n\n  var parseOptions = [\"preserveWhitespace\", \"sanitize\", \"stripComments\", \"delimiters\", \"tripleDelimiters\", \"interpolate\"];\n\n  var parser = {\n  \tfromId: fromId, isHashedId: isHashedId, isParsed: isParsed, getParseOptions: getParseOptions, createHelper: template_parser__createHelper,\n  \tparse: doParse\n  };\n\n  function template_parser__createHelper(parseOptions) {\n  \tvar helper = create(parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn doParse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function doParse(template, parseOptions) {\n  \tif (!_parse) {\n  \t\tthrow new Error(\"Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser\");\n  \t}\n\n  \treturn _parse(template, parseOptions || this.options);\n  }\n\n  function fromId(id, options) {\n  \tvar template;\n\n  \tif (!isClient) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Cannot retrieve template #\" + id + \" as Ractive is not running in a browser.\");\n  \t}\n\n  \tif (isHashedId(id)) {\n  \t\tid = id.substring(1);\n  \t}\n\n  \tif (!(template = document.getElementById(id))) {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Could not find template element with id #\" + id);\n  \t}\n\n  \tif (template.tagName.toUpperCase() !== \"SCRIPT\") {\n  \t\tif (options && options.noThrow) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthrow new Error(\"Template element with id #\" + id + \", must be a <script> element\");\n  \t}\n\n  \treturn \"textContent\" in template ? template.textContent : template.innerHTML;\n  }\n\n  function isHashedId(id) {\n  \treturn id && id[0] === \"#\";\n  }\n\n  function isParsed(template) {\n  \treturn !(typeof template === \"string\");\n  }\n\n  function getParseOptions(ractive) {\n  \t// Could be Ractive or a Component\n  \tif (ractive.defaults) {\n  \t\tractive = ractive.defaults;\n  \t}\n\n  \treturn parseOptions.reduce(function (val, key) {\n  \t\tval[key] = ractive[key];\n  \t\treturn val;\n  \t}, {});\n  }\n\n  var template_parser = parser;\n\n  var templateConfigurator = {\n  \tname: \"template\",\n\n  \textend: function extend(Parent, proto, options) {\n  \t\tvar template;\n\n  \t\t// only assign if exists\n  \t\tif (\"template\" in options) {\n  \t\t\ttemplate = options.template;\n\n  \t\t\tif (typeof template === \"function\") {\n  \t\t\t\tproto.template = template;\n  \t\t\t} else {\n  \t\t\t\tproto.template = parseIfString(template, proto);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tinit: function init(Parent, ractive, options) {\n  \t\tvar template, fn;\n\n  \t\t// TODO because of prototypal inheritance, we might just be able to use\n  \t\t// ractive.template, and not bother passing through the Parent object.\n  \t\t// At present that breaks the test mocks' expectations\n  \t\ttemplate = \"template\" in options ? options.template : Parent.prototype.template;\n\n  \t\tif (typeof template === \"function\") {\n  \t\t\tfn = template;\n  \t\t\ttemplate = getDynamicTemplate(ractive, fn);\n\n  \t\t\tractive._config.template = {\n  \t\t\t\tfn: fn,\n  \t\t\t\tresult: template\n  \t\t\t};\n  \t\t}\n\n  \t\ttemplate = parseIfString(template, ractive);\n\n  \t\t// TODO the naming of this is confusing - ractive.template refers to [...],\n  \t\t// but Component.prototype.template refers to {v:1,t:[],p:[]}...\n  \t\t// it's unnecessary, because the developer never needs to access\n  \t\t// ractive.template\n  \t\tractive.template = template.t;\n\n  \t\tif (template.p) {\n  \t\t\textendPartials(ractive.partials, template.p);\n  \t\t}\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar result = resetValue(ractive),\n  \t\t    parsed;\n\n  \t\tif (result) {\n  \t\t\tparsed = parseIfString(result, ractive);\n\n  \t\t\tractive.template = parsed.t;\n  \t\t\textendPartials(ractive.partials, parsed.p, true);\n\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  };\n\n  function resetValue(ractive) {\n  \tvar initial = ractive._config.template,\n  \t    result;\n\n  \t// If this isn't a dynamic template, there's nothing to do\n  \tif (!initial || !initial.fn) {\n  \t\treturn;\n  \t}\n\n  \tresult = getDynamicTemplate(ractive, initial.fn);\n\n  \t// TODO deep equality check to prevent unnecessary re-rendering\n  \t// in the case of already-parsed templates\n  \tif (result !== initial.result) {\n  \t\tinitial.result = result;\n  \t\tresult = parseIfString(result, ractive);\n  \t\treturn result;\n  \t}\n  }\n\n  function getDynamicTemplate(ractive, fn) {\n  \tvar helper = template_template__createHelper(template_parser.getParseOptions(ractive));\n  \treturn fn.call(ractive, helper);\n  }\n\n  function template_template__createHelper(parseOptions) {\n  \tvar helper = create(template_parser);\n  \thelper.parse = function (template, options) {\n  \t\treturn template_parser.parse(template, options || parseOptions);\n  \t};\n  \treturn helper;\n  }\n\n  function parseIfString(template, ractive) {\n  \tif (typeof template === \"string\") {\n  \t\t// ID of an element containing the template?\n  \t\tif (template[0] === \"#\") {\n  \t\t\ttemplate = template_parser.fromId(template);\n  \t\t}\n\n  \t\ttemplate = _parse(template, template_parser.getParseOptions(ractive));\n  \t}\n\n  \t// Check that the template even exists\n  \telse if (template == undefined) {\n  \t\tthrow new Error(\"The template cannot be \" + template + \".\");\n  \t}\n\n  \t// Check the parsed template has a version at all\n  \telse if (typeof template.v !== \"number\") {\n  \t\tthrow new Error(\"The template parser was passed a non-string template, but the template doesn't have a version.  Make sure you're passing in the template you think you are.\");\n  \t}\n\n  \t// Check we're using the correct version\n  \telse if (template.v !== TEMPLATE_VERSION) {\n  \t\tthrow new Error(\"Mismatched template version (expected \" + TEMPLATE_VERSION + \", got \" + template.v + \") Please ensure you are using the latest version of Ractive.js in your build process as well as in your app\");\n  \t}\n\n  \treturn template;\n  }\n\n  function extendPartials(existingPartials, newPartials, overwrite) {\n  \tif (!newPartials) return;\n\n  \t// TODO there's an ambiguity here - we need to overwrite in the `reset()`\n  \t// case, but not initially...\n\n  \tfor (var key in newPartials) {\n  \t\tif (overwrite || !existingPartials.hasOwnProperty(key)) {\n  \t\t\texistingPartials[key] = newPartials[key];\n  \t\t}\n  \t}\n  }\n\n  var template_template = templateConfigurator;\n\n  var config_registries__registryNames, Registry, registries;\n\n  config_registries__registryNames = [\"adaptors\", \"components\", \"computed\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  Registry = function (name, useDefaults) {\n  \tthis.name = name;\n  \tthis.useDefaults = useDefaults;\n  };\n\n  Registry.prototype = {\n  \tconstructor: Registry,\n\n  \textend: function (Parent, proto, options) {\n  \t\tthis.configure(this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options);\n  \t},\n\n  \tinit: function () {},\n\n  \tconfigure: function (Parent, target, options) {\n  \t\tvar name = this.name,\n  \t\t    option = options[name],\n  \t\t    registry;\n\n  \t\tregistry = create(Parent[name]);\n\n  \t\tfor (var key in option) {\n  \t\t\tregistry[key] = option[key];\n  \t\t}\n\n  \t\ttarget[name] = registry;\n  \t},\n\n  \treset: function (ractive) {\n  \t\tvar registry = ractive[this.name];\n  \t\tvar changed = false;\n  \t\tObject.keys(registry).forEach(function (key) {\n  \t\t\tvar item = registry[key];\n  \t\t\tif (item._fn) {\n  \t\t\t\tif (item._fn.isOwner) {\n  \t\t\t\t\tregistry[key] = item._fn;\n  \t\t\t\t} else {\n  \t\t\t\t\tdelete registry[key];\n  \t\t\t\t}\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n  \t\treturn changed;\n  \t}\n  };\n\n  registries = config_registries__registryNames.map(function (name) {\n  \treturn new Registry(name, name === \"computed\");\n  });\n\n  var config_registries = registries;\n\n  /*this.configure(\n  \tthis.useDefaults ? Parent.defaults : Parent,\n  \tractive,\n  \toptions );*/\n\n  var wrapPrototype = wrap;\n\n  function wrap(parent, name, method) {\n  \tif (!/_super/.test(method)) {\n  \t\treturn method;\n  \t}\n\n  \tvar wrapper = function wrapSuper() {\n  \t\tvar superMethod = getSuperMethod(wrapper._parent, name),\n  \t\t    hasSuper = (\"_super\" in this),\n  \t\t    oldSuper = this._super,\n  \t\t    result;\n\n  \t\tthis._super = superMethod;\n\n  \t\tresult = method.apply(this, arguments);\n\n  \t\tif (hasSuper) {\n  \t\t\tthis._super = oldSuper;\n  \t\t} else {\n  \t\t\tdelete this._super;\n  \t\t}\n\n  \t\treturn result;\n  \t};\n\n  \twrapper._parent = parent;\n  \twrapper._method = method;\n\n  \treturn wrapper;\n  }\n\n  function getSuperMethod(parent, name) {\n  \tvar value, method;\n\n  \tif (name in parent) {\n  \t\tvalue = parent[name];\n\n  \t\tif (typeof value === \"function\") {\n  \t\t\tmethod = value;\n  \t\t} else {\n  \t\t\tmethod = function returnValue() {\n  \t\t\t\treturn value;\n  \t\t\t};\n  \t\t}\n  \t} else {\n  \t\tmethod = noop;\n  \t}\n\n  \treturn method;\n  }\n\n  var config_deprecate = deprecate;\n  function getMessage(deprecated, correct, isError) {\n  \treturn \"options.\" + deprecated + \" has been deprecated in favour of options.\" + correct + \".\" + (isError ? \" You cannot specify both options, please use options.\" + correct + \".\" : \"\");\n  }\n\n  function deprecateOption(options, deprecatedOption, correct) {\n  \tif (deprecatedOption in options) {\n  \t\tif (!(correct in options)) {\n  \t\t\twarnIfDebug(getMessage(deprecatedOption, correct));\n  \t\t\toptions[correct] = options[deprecatedOption];\n  \t\t} else {\n  \t\t\tthrow new Error(getMessage(deprecatedOption, correct, true));\n  \t\t}\n  \t}\n  }\n  function deprecate(options) {\n  \tdeprecateOption(options, \"beforeInit\", \"onconstruct\");\n  \tdeprecateOption(options, \"init\", \"onrender\");\n  \tdeprecateOption(options, \"complete\", \"oncomplete\");\n  \tdeprecateOption(options, \"eventDefinitions\", \"events\");\n\n  \t// Using extend with Component instead of options,\n  \t// like Human.extend( Spider ) means adaptors as a registry\n  \t// gets copied to options. So we have to check if actually an array\n  \tif (isArray(options.adaptors)) {\n  \t\tdeprecateOption(options, \"adaptors\", \"adapt\");\n  \t}\n  }\n\n  var config, order, defaultKeys, custom, isBlacklisted, isStandardKey;\n\n  custom = {\n  \tadapt: custom_adapt,\n  \tcss: css_css,\n  \tdata: custom_data,\n  \ttemplate: template_template\n  };\n\n  defaultKeys = Object.keys(config_defaults);\n\n  isStandardKey = makeObj(defaultKeys.filter(function (key) {\n  \treturn !custom[key];\n  }));\n\n  // blacklisted keys that we don't double extend\n  isBlacklisted = makeObj(defaultKeys.concat(config_registries.map(function (r) {\n  \treturn r.name;\n  })));\n\n  order = [].concat(defaultKeys.filter(function (key) {\n  \treturn !config_registries[key] && !custom[key];\n  }), config_registries, custom.data, custom.template, custom.css);\n\n  config = {\n  \textend: function (Parent, proto, options) {\n  \t\treturn configure(\"extend\", Parent, proto, options);\n  \t},\n\n  \tinit: function (Parent, ractive, options) {\n  \t\treturn configure(\"init\", Parent, ractive, options);\n  \t},\n\n  \treset: function (ractive) {\n  \t\treturn order.filter(function (c) {\n  \t\t\treturn c.reset && c.reset(ractive);\n  \t\t}).map(function (c) {\n  \t\t\treturn c.name;\n  \t\t});\n  \t},\n\n  \t// this defines the order. TODO this isn't used anywhere in the codebase,\n  \t// only in the test suite - should get rid of it\n  \torder: order };\n\n  function configure(method, Parent, target, options) {\n  \tconfig_deprecate(options);\n\n  \tfor (var key in options) {\n  \t\tif (isStandardKey.hasOwnProperty(key)) {\n  \t\t\tvar value = options[key];\n\n  \t\t\t// warn the developer if they passed a function and ignore its value\n\n  \t\t\t// NOTE: we allow some functions on \"el\" because we duck type element lists\n  \t\t\t// and some libraries or ef'ed-up virtual browsers (phantomJS) return a\n  \t\t\t// function object as the result of querySelector methods\n  \t\t\tif (key !== \"el\" && typeof value === \"function\") {\n  \t\t\t\twarnIfDebug(\"\" + key + \" is a Ractive option that does not expect a function and will be ignored\", method === \"init\" ? target : null);\n  \t\t\t} else {\n  \t\t\t\ttarget[key] = value;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tconfig_registries.forEach(function (registry) {\n  \t\tregistry[method](Parent, target, options);\n  \t});\n\n  \tcustom_adapt[method](Parent, target, options);\n  \ttemplate_template[method](Parent, target, options);\n  \tcss_css[method](Parent, target, options);\n\n  \textendOtherMethods(Parent.prototype, target, options);\n  }\n\n  function extendOtherMethods(parent, target, options) {\n  \tfor (var key in options) {\n  \t\tif (!isBlacklisted[key] && options.hasOwnProperty(key)) {\n  \t\t\tvar member = options[key];\n\n  \t\t\t// if this is a method that overwrites a method, wrap it:\n  \t\t\tif (typeof member === \"function\") {\n  \t\t\t\tmember = wrapPrototype(parent, key, member);\n  \t\t\t}\n\n  \t\t\ttarget[key] = member;\n  \t\t}\n  \t}\n  }\n\n  function makeObj(array) {\n  \tvar obj = {};\n  \tarray.forEach(function (x) {\n  \t\treturn obj[x] = true;\n  \t});\n  \treturn obj;\n  }\n\n  var config_config = config;\n\n  var prototype_bubble = Fragment$bubble;\n\n  function Fragment$bubble() {\n  \tthis.dirtyValue = this.dirtyArgs = true;\n\n  \tif (this.bound && typeof this.owner.bubble === \"function\") {\n  \t\tthis.owner.bubble();\n  \t}\n  }\n\n  var Fragment_prototype_detach = Fragment$detach;\n\n  function Fragment$detach() {\n  \tvar docFrag;\n\n  \tif (this.items.length === 1) {\n  \t\treturn this.items[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.items.forEach(function (item) {\n  \t\tvar node = item.detach();\n\n  \t\t// TODO The if {...} wasn't previously required - it is now, because we're\n  \t\t// forcibly detaching everything to reorder sections after an update. That's\n  \t\t// a non-ideal brute force approach, implemented to get all the tests to pass\n  \t\t// - as soon as it's replaced with something more elegant, this should\n  \t\t// revert to `docFrag.appendChild( item.detach() )`\n  \t\tif (node) {\n  \t\t\tdocFrag.appendChild(node);\n  \t\t}\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var Fragment_prototype_find = Fragment$find;\n\n  function Fragment$find(selector) {\n  \tvar i, len, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.find && (queryResult = item.find(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var Fragment_prototype_findAll = Fragment$findAll;\n\n  function Fragment$findAll(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAll) {\n  \t\t\t\titem.findAll(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findAllComponents = Fragment$findAllComponents;\n\n  function Fragment$findAllComponents(selector, query) {\n  \tvar i, len, item;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findAllComponents) {\n  \t\t\t\titem.findAllComponents(selector, query);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn query;\n  }\n\n  var Fragment_prototype_findComponent = Fragment$findComponent;\n\n  function Fragment$findComponent(selector) {\n  \tvar len, i, item, queryResult;\n\n  \tif (this.items) {\n  \t\tlen = this.items.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\titem = this.items[i];\n\n  \t\t\tif (item.findComponent && (queryResult = item.findComponent(selector))) {\n  \t\t\t\treturn queryResult;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t}\n  }\n\n  var prototype_findNextNode = Fragment$findNextNode;\n\n  function Fragment$findNextNode(item) {\n  \tvar index = item.index,\n  \t    node;\n\n  \tif (this.items[index + 1]) {\n  \t\tnode = this.items[index + 1].firstNode();\n  \t}\n\n  \t// if this is the root fragment, and there are no more items,\n  \t// it means we're at the end...\n  \telse if (this.owner === this.root) {\n  \t\tif (!this.owner.component) {\n  \t\t\t// TODO but something else could have been appended to\n  \t\t\t// this.root.el, no?\n  \t\t\tnode = null;\n  \t\t}\n\n  \t\t// ...unless this is a component\n  \t\telse {\n  \t\t\tnode = this.owner.component.findNextNode();\n  \t\t}\n  \t} else {\n  \t\tnode = this.owner.findNextNode(this);\n  \t}\n\n  \treturn node;\n  }\n\n  var prototype_firstNode = Fragment$firstNode;\n\n  function Fragment$firstNode() {\n  \tif (this.items && this.items[0]) {\n  \t\treturn this.items[0].firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var shared_processItems = processItems;\n\n  function processItems(items, values, guid, counter) {\n  \tcounter = counter || 0;\n\n  \treturn items.map(function (item) {\n  \t\tvar placeholderId, wrapped, value;\n\n  \t\tif (item.text) {\n  \t\t\treturn item.text;\n  \t\t}\n\n  \t\tif (item.fragments) {\n  \t\t\treturn item.fragments.map(function (fragment) {\n  \t\t\t\treturn processItems(fragment.items, values, guid, counter);\n  \t\t\t}).join(\"\");\n  \t\t}\n\n  \t\tplaceholderId = guid + \"-\" + counter++;\n\n  \t\tif (item.keypath && (wrapped = item.root.viewmodel.wrapped[item.keypath.str])) {\n  \t\t\tvalue = wrapped.value;\n  \t\t} else {\n  \t\t\tvalue = item.getValue();\n  \t\t}\n\n  \t\tvalues[placeholderId] = value;\n\n  \t\treturn \"${\" + placeholderId + \"}\";\n  \t}).join(\"\");\n  }\n\n  var getArgsList = Fragment$getArgsList;\n  function Fragment$getArgsList() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyArgs) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(\"[\" + source + \"]\", values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = [this.toString()];\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.argsList = result;\n  \t\tthis.dirtyArgs = false;\n  \t}\n\n  \treturn this.argsList;\n  }\n\n  var getNode = Fragment$getNode;\n\n  function Fragment$getNode() {\n  \tvar fragment = this;\n\n  \tdo {\n  \t\tif (fragment.pElement) {\n  \t\t\treturn fragment.pElement.node;\n  \t\t}\n  \t} while (fragment = fragment.parent);\n\n  \treturn this.root.detached || this.root.el;\n  }\n\n  var prototype_getValue = Fragment$getValue;\n  function Fragment$getValue() {\n  \tvar values, source, parsed, result;\n\n  \tif (this.dirtyValue) {\n  \t\tsource = shared_processItems(this.items, values = {}, this.root._guid);\n  \t\tparsed = parseJSON(source, values);\n\n  \t\tif (!parsed) {\n  \t\t\tresult = this.toString();\n  \t\t} else {\n  \t\t\tresult = parsed.value;\n  \t\t}\n\n  \t\tthis.value = result;\n  \t\tthis.dirtyValue = false;\n  \t}\n\n  \treturn this.value;\n  }\n\n  var shared_detach = function () {\n  \treturn detachNode(this.node);\n  };\n\n  var Text = function (options) {\n  \tthis.type = TEXT;\n  \tthis.text = options.template;\n  };\n\n  Text.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(this.text);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\treturn escape ? escapeHtml(this.text) : this.text;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\treturn this.detach();\n  \t\t}\n  \t}\n  };\n\n  var items_Text = Text;\n\n  var shared_unbind = shared_unbind__unbind;\n\n  function shared_unbind__unbind() {\n  \tif (this.registered) {\n  \t\t// this was registered as a dependant\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t}\n\n  \tif (this.resolver) {\n  \t\tthis.resolver.unbind();\n  \t}\n  }\n\n  var Mustache_getValue = Mustache$getValue;\n\n  function Mustache$getValue() {\n  \treturn this.value;\n  }\n\n  var ReferenceResolver = function (owner, ref, callback) {\n  \tvar keypath;\n\n  \tthis.ref = ref;\n  \tthis.resolved = false;\n\n  \tthis.root = owner.root;\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.callback = callback;\n\n  \tkeypath = shared_resolveRef(owner.root, ref, owner.parentFragment);\n  \tif (keypath != undefined) {\n  \t\tthis.resolve(keypath);\n  \t} else {\n  \t\tglobal_runloop.addUnresolved(this);\n  \t}\n  };\n\n  ReferenceResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath && !keypath) {\n  \t\t\t// it was resolved, and now it's not. Can happen if e.g. `bar` in\n  \t\t\t// `{{foo[bar]}}` becomes undefined\n  \t\t\tglobal_runloop.addUnresolved(this);\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.callback(keypath);\n  \t},\n\n  \tforceResolution: function () {\n  \t\tthis.resolve(getKeypath(this.ref));\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar keypath;\n\n  \t\tif (this.keypath != undefined) {\n  \t\t\tkeypath = this.keypath.replace(oldKeypath, newKeypath);\n  \t\t\t// was a new keypath created?\n  \t\t\tif (keypath !== undefined) {\n  \t\t\t\t// resolve it\n  \t\t\t\tthis.resolve(keypath);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.resolved) {\n  \t\t\tglobal_runloop.removeUnresolved(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_ReferenceResolver = ReferenceResolver;\n\n  var SpecialResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tthis.rebind();\n  };\n\n  var props = {\n  \t\"@keypath\": { prefix: \"c\", prop: [\"context\"] },\n  \t\"@index\": { prefix: \"i\", prop: [\"index\"] },\n  \t\"@key\": { prefix: \"k\", prop: [\"key\", \"index\"] }\n  };\n\n  function getProp(target, prop) {\n  \tvar value;\n  \tfor (var i = 0; i < prop.prop.length; i++) {\n  \t\tif ((value = target[prop.prop[i]]) !== undefined) {\n  \t\t\treturn value;\n  \t\t}\n  \t}\n  }\n\n  SpecialResolver.prototype = {\n  \trebind: function () {\n  \t\tvar ref = this.ref,\n  \t\t    fragment = this.parentFragment,\n  \t\t    prop = props[ref],\n  \t\t    value;\n\n  \t\tif (!prop) {\n  \t\t\tthrow new Error(\"Unknown special reference \\\"\" + ref + \"\\\" - valid references are @index, @key and @keypath\");\n  \t\t}\n\n  \t\t// have we already found the nearest parent?\n  \t\tif (this.cached) {\n  \t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + getProp(this.cached, prop)));\n  \t\t}\n\n  \t\t// special case for indices, which may cross component boundaries\n  \t\tif (prop.prop.indexOf(\"index\") !== -1 || prop.prop.indexOf(\"key\") !== -1) {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif (fragment.owner.currentSubtype === SECTION_EACH && (value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\tthis.cached = fragment;\n\n  \t\t\t\t\tfragment.registerIndexRef(this);\n\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value));\n  \t\t\t\t}\n\n  \t\t\t\t// watch for component boundaries\n  \t\t\t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t\t\t} else {\n  \t\t\t\t\tfragment = fragment.parent;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\twhile (fragment) {\n  \t\t\t\tif ((value = getProp(fragment, prop)) !== undefined) {\n  \t\t\t\t\treturn this.callback(getKeypath(\"@\" + prop.prefix + value.str));\n  \t\t\t\t}\n\n  \t\t\t\tfragment = fragment.parent;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.cached) {\n  \t\t\tthis.cached.unregisterIndexRef(this);\n  \t\t}\n  \t}\n  };\n\n  var Resolvers_SpecialResolver = SpecialResolver;\n\n  var IndexResolver = function (owner, ref, callback) {\n  \tthis.parentFragment = owner.parentFragment;\n  \tthis.ref = ref;\n  \tthis.callback = callback;\n\n  \tref.ref.fragment.registerIndexRef(this);\n\n  \tthis.rebind();\n  };\n\n  IndexResolver.prototype = {\n  \trebind: function () {\n  \t\tvar index,\n  \t\t    ref = this.ref.ref;\n\n  \t\tif (ref.ref.t === \"k\") {\n  \t\t\tindex = \"k\" + ref.fragment.key;\n  \t\t} else {\n  \t\t\tindex = \"i\" + ref.fragment.index;\n  \t\t}\n\n  \t\tif (index !== undefined) {\n  \t\t\tthis.callback(getKeypath(\"@\" + index));\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.ref.ref.fragment.unregisterIndexRef(this);\n  \t}\n  };\n\n  var Resolvers_IndexResolver = IndexResolver;\n\n  var Resolvers_findIndexRefs = findIndexRefs;\n\n  function findIndexRefs(fragment, refName) {\n  \tvar result = {},\n  \t    refs,\n  \t    fragRefs,\n  \t    ref,\n  \t    i,\n  \t    owner,\n  \t    hit = false;\n\n  \tif (!refName) {\n  \t\tresult.refs = refs = {};\n  \t}\n\n  \twhile (fragment) {\n  \t\tif ((owner = fragment.owner) && (fragRefs = owner.indexRefs)) {\n\n  \t\t\t// we're looking for a particular ref, and it's here\n  \t\t\tif (refName && (ref = owner.getIndexRef(refName))) {\n  \t\t\t\tresult.ref = {\n  \t\t\t\t\tfragment: fragment,\n  \t\t\t\t\tref: ref\n  \t\t\t\t};\n  \t\t\t\treturn result;\n  \t\t\t}\n\n  \t\t\t// we're collecting refs up-tree\n  \t\t\telse if (!refName) {\n  \t\t\t\tfor (i in fragRefs) {\n  \t\t\t\t\tref = fragRefs[i];\n\n  \t\t\t\t\t// don't overwrite existing refs - they should shadow parents\n  \t\t\t\t\tif (!refs[ref.n]) {\n  \t\t\t\t\t\thit = true;\n  \t\t\t\t\t\trefs[ref.n] = {\n  \t\t\t\t\t\t\tfragment: fragment,\n  \t\t\t\t\t\t\tref: ref\n  \t\t\t\t\t\t};\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// watch for component boundaries\n  \t\tif (!fragment.parent && fragment.owner && fragment.owner.component && fragment.owner.component.parentFragment && !fragment.owner.component.instance.isolated) {\n  \t\t\tresult.componentBoundary = true;\n  \t\t\tfragment = fragment.owner.component.parentFragment;\n  \t\t} else {\n  \t\t\tfragment = fragment.parent;\n  \t\t}\n  \t}\n\n  \tif (!hit) {\n  \t\treturn undefined;\n  \t} else {\n  \t\treturn result;\n  \t}\n  }\n\n  findIndexRefs.resolve = function resolve(indices) {\n  \tvar refs = {},\n  \t    k,\n  \t    ref;\n\n  \tfor (k in indices.refs) {\n  \t\tref = indices.refs[k];\n  \t\trefs[ref.ref.n] = ref.ref.t === \"k\" ? ref.fragment.key : ref.fragment.index;\n  \t}\n\n  \treturn refs;\n  };\n\n  var Resolvers_createReferenceResolver = createReferenceResolver;\n  function createReferenceResolver(owner, ref, callback) {\n  \tvar indexRef;\n\n  \tif (ref.charAt(0) === \"@\") {\n  \t\treturn new Resolvers_SpecialResolver(owner, ref, callback);\n  \t}\n\n  \tif (indexRef = Resolvers_findIndexRefs(owner.parentFragment, ref)) {\n  \t\treturn new Resolvers_IndexResolver(owner, indexRef, callback);\n  \t}\n\n  \treturn new Resolvers_ReferenceResolver(owner, ref, callback);\n  }\n\n  var shared_getFunctionFromString = getFunctionFromString;\n  var cache = {};\n  function getFunctionFromString(str, i) {\n  \tvar fn, args;\n\n  \tif (cache[str]) {\n  \t\treturn cache[str];\n  \t}\n\n  \targs = [];\n  \twhile (i--) {\n  \t\targs[i] = \"_\" + i;\n  \t}\n\n  \tfn = new Function(args.join(\",\"), \"return(\" + str + \")\");\n\n  \tcache[str] = fn;\n  \treturn fn;\n  }\n\n  var ExpressionResolver,\n      Resolvers_ExpressionResolver__bind = Function.prototype.bind;\n\n  ExpressionResolver = function (owner, parentFragment, expression, callback) {\n  \tvar _this = this;\n\n  \tvar ractive;\n\n  \tractive = owner.root;\n\n  \tthis.root = ractive;\n  \tthis.parentFragment = parentFragment;\n  \tthis.callback = callback;\n  \tthis.owner = owner;\n  \tthis.str = expression.s;\n  \tthis.keypaths = [];\n\n  \t// Create resolvers for each reference\n  \tthis.pending = expression.r.length;\n  \tthis.refResolvers = expression.r.map(function (ref, i) {\n  \t\treturn Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t_this.resolve(i, keypath);\n  \t\t});\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble();\n  };\n\n  ExpressionResolver.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.ready) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.uniqueString = getUniqueString(this.str, this.keypaths);\n  \t\tthis.keypath = createExpressionKeypath(this.uniqueString);\n\n  \t\tthis.createEvaluator();\n  \t\tthis.callback(this.keypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tvar resolver;\n\n  \t\twhile (resolver = this.refResolvers.pop()) {\n  \t\t\tresolver.unbind();\n  \t\t}\n  \t},\n\n  \tresolve: function (index, keypath) {\n  \t\tthis.keypaths[index] = keypath;\n  \t\tthis.bubble();\n  \t},\n\n  \tcreateEvaluator: function () {\n  \t\tvar _this = this;\n\n  \t\tvar computation, valueGetters, signature, keypath, fn;\n\n  \t\tkeypath = this.keypath;\n  \t\tcomputation = this.root.viewmodel.computations[keypath.str];\n\n  \t\t// only if it doesn't exist yet!\n  \t\tif (!computation) {\n  \t\t\tfn = shared_getFunctionFromString(this.str, this.refResolvers.length);\n\n  \t\t\tvalueGetters = this.keypaths.map(function (keypath) {\n  \t\t\t\tvar value;\n\n  \t\t\t\tif (keypath === \"undefined\") {\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn undefined;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\t// 'special' keypaths encode a value\n  \t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\tvalue = keypath.value;\n  \t\t\t\t\treturn function () {\n  \t\t\t\t\t\treturn value;\n  \t\t\t\t\t};\n  \t\t\t\t}\n\n  \t\t\t\treturn function () {\n  \t\t\t\t\tvar value = _this.root.viewmodel.get(keypath, { noUnwrap: true, fullRootGet: true });\n  \t\t\t\t\tif (typeof value === \"function\") {\n  \t\t\t\t\t\tvalue = wrapFunction(value, _this.root);\n  \t\t\t\t\t}\n  \t\t\t\t\treturn value;\n  \t\t\t\t};\n  \t\t\t});\n\n  \t\t\tsignature = {\n  \t\t\t\tdeps: this.keypaths.filter(isValidDependency),\n  \t\t\t\tgetter: function () {\n  \t\t\t\t\tvar args = valueGetters.map(call);\n  \t\t\t\t\treturn fn.apply(null, args);\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\tcomputation = this.root.viewmodel.compute(keypath, signature);\n  \t\t} else {\n  \t\t\tthis.root.viewmodel.mark(keypath);\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// TODO only bubble once, no matter how many references are affected by the rebind\n  \t\tthis.refResolvers.forEach(function (r) {\n  \t\t\treturn r.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n  };\n\n  var Resolvers_ExpressionResolver = ExpressionResolver;\n\n  function call(value) {\n  \treturn value.call();\n  }\n\n  function getUniqueString(str, keypaths) {\n  \t// get string that is unique to this expression\n  \treturn str.replace(/_([0-9]+)/g, function (match, $1) {\n  \t\tvar keypath, value;\n\n  \t\t// make sure we're not replacing a non-keypath _[0-9]\n  \t\tif (+$1 >= keypaths.length) {\n  \t\t\treturn \"_\" + $1;\n  \t\t}\n\n  \t\tkeypath = keypaths[$1];\n\n  \t\tif (keypath === undefined) {\n  \t\t\treturn \"undefined\";\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\tvalue = keypath.value;\n  \t\t\treturn typeof value === \"number\" ? value : \"\\\"\" + value + \"\\\"\";\n  \t\t}\n\n  \t\treturn keypath.str;\n  \t});\n  }\n\n  function createExpressionKeypath(uniqueString) {\n  \t// Sanitize by removing any periods or square brackets. Otherwise\n  \t// we can't split the keypath into keys!\n  \t// Remove asterisks too, since they mess with pattern observers\n  \treturn getKeypath(\"${\" + uniqueString.replace(/[\\.\\[\\]]/g, \"-\").replace(/\\*/, \"#MUL#\") + \"}\");\n  }\n\n  function isValidDependency(keypath) {\n  \treturn keypath !== undefined && keypath[0] !== \"@\";\n  }\n\n  function wrapFunction(fn, ractive) {\n  \tvar wrapped, prop, key;\n\n  \tif (fn.__ractive_nowrap) {\n  \t\treturn fn;\n  \t}\n\n  \tprop = \"__ractive_\" + ractive._guid;\n  \twrapped = fn[prop];\n\n  \tif (wrapped) {\n  \t\treturn wrapped;\n  \t} else if (/this/.test(fn.toString())) {\n  \t\tdefineProperty(fn, prop, {\n  \t\t\tvalue: Resolvers_ExpressionResolver__bind.call(fn, ractive),\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\t// Add properties/methods to wrapped function\n  \t\tfor (key in fn) {\n  \t\t\tif (fn.hasOwnProperty(key)) {\n  \t\t\t\tfn[prop][key] = fn[key];\n  \t\t\t}\n  \t\t}\n\n  \t\tractive._boundFunctions.push({\n  \t\t\tfn: fn,\n  \t\t\tprop: prop\n  \t\t});\n\n  \t\treturn fn[prop];\n  \t}\n\n  \tdefineProperty(fn, \"__ractive_nowrap\", {\n  \t\tvalue: fn\n  \t});\n\n  \treturn fn.__ractive_nowrap;\n  }\n\n  var MemberResolver = function (template, resolver, parentFragment) {\n  \tvar _this = this;\n\n  \tthis.resolver = resolver;\n  \tthis.root = resolver.root;\n  \tthis.parentFragment = parentFragment;\n  \tthis.viewmodel = resolver.root.viewmodel;\n\n  \tif (typeof template === \"string\") {\n  \t\tthis.value = template;\n  \t}\n\n  \t// Simple reference?\n  \telse if (template.t === REFERENCE) {\n  \t\tthis.refResolver = Resolvers_createReferenceResolver(this, template.n, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n\n  \t// Otherwise we have an expression in its own right\n  \telse {\n  \t\tnew Resolvers_ExpressionResolver(resolver, parentFragment, template, function (keypath) {\n  \t\t\t_this.resolve(keypath);\n  \t\t});\n  \t}\n  };\n\n  MemberResolver.prototype = {\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = this.viewmodel.get(keypath);\n\n  \t\tthis.bind();\n\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tbind: function () {\n  \t\tthis.viewmodel.register(this.keypath, this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tthis.value = value;\n  \t\tthis.resolver.bubble();\n  \t},\n\n  \tunbind: function () {\n  \t\tif (this.keypath) {\n  \t\t\tthis.viewmodel.unregister(this.keypath, this);\n  \t\t}\n\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.unbind();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.refResolver) {\n  \t\t\tthis.refResolver.forceResolution();\n  \t\t}\n  \t}\n  };\n\n  var ReferenceExpressionResolver_MemberResolver = MemberResolver;\n\n  var ReferenceExpressionResolver = function (mustache, template, callback) {\n  \tvar _this = this;\n\n  \tvar ractive, ref, keypath, parentFragment;\n\n  \tthis.parentFragment = parentFragment = mustache.parentFragment;\n  \tthis.root = ractive = mustache.root;\n  \tthis.mustache = mustache;\n\n  \tthis.ref = ref = template.r;\n  \tthis.callback = callback;\n\n  \tthis.unresolved = [];\n\n  \t// Find base keypath\n  \tif (keypath = shared_resolveRef(ractive, ref, parentFragment)) {\n  \t\tthis.base = keypath;\n  \t} else {\n  \t\tthis.baseResolver = new Resolvers_ReferenceResolver(this, ref, function (keypath) {\n  \t\t\t_this.base = keypath;\n  \t\t\t_this.baseResolver = null;\n  \t\t\t_this.bubble();\n  \t\t});\n  \t}\n\n  \t// Find values for members, or mark them as unresolved\n  \tthis.members = template.m.map(function (template) {\n  \t\treturn new ReferenceExpressionResolver_MemberResolver(template, _this, parentFragment);\n  \t});\n\n  \tthis.ready = true;\n  \tthis.bubble(); // trigger initial resolution if possible\n  };\n\n  ReferenceExpressionResolver.prototype = {\n  \tgetKeypath: function () {\n  \t\tvar values = this.members.map(ReferenceExpressionResolver_ReferenceExpressionResolver__getValue);\n\n  \t\tif (!values.every(isDefined) || this.baseResolver) {\n  \t\t\treturn null;\n  \t\t}\n\n  \t\treturn this.base.join(values.join(\".\"));\n  \t},\n\n  \tbubble: function () {\n  \t\tif (!this.ready || this.baseResolver) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.callback(this.getKeypath());\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.members.forEach(methodCallers__unbind);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tvar changed;\n\n  \t\tif (this.base) {\n  \t\t\tvar newBase = this.base.replace(oldKeypath, newKeypath);\n  \t\t\tif (newBase && newBase !== this.base) {\n  \t\t\t\tthis.base = newBase;\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.members.forEach(function (members) {\n  \t\t\tif (members.rebind(oldKeypath, newKeypath)) {\n  \t\t\t\tchanged = true;\n  \t\t\t}\n  \t\t});\n\n  \t\tif (changed) {\n  \t\t\tthis.bubble();\n  \t\t}\n  \t},\n\n  \tforceResolution: function () {\n  \t\tif (this.baseResolver) {\n  \t\t\tthis.base = getKeypath(this.ref);\n\n  \t\t\tthis.baseResolver.unbind();\n  \t\t\tthis.baseResolver = null;\n  \t\t}\n\n  \t\tthis.members.forEach(forceResolution);\n  \t\tthis.bubble();\n  \t}\n  };\n\n  function ReferenceExpressionResolver_ReferenceExpressionResolver__getValue(member) {\n  \treturn member.value;\n  }\n\n  function isDefined(value) {\n  \treturn value != undefined;\n  }\n\n  function forceResolution(member) {\n  \tmember.forceResolution();\n  }\n\n  var ReferenceExpressionResolver_ReferenceExpressionResolver = ReferenceExpressionResolver;\n\n  var Mustache_initialise = Mustache$init;\n  function Mustache$init(mustache, options) {\n\n  \tvar ref, parentFragment, template;\n\n  \tparentFragment = options.parentFragment;\n  \ttemplate = options.template;\n\n  \tmustache.root = parentFragment.root;\n  \tmustache.parentFragment = parentFragment;\n  \tmustache.pElement = parentFragment.pElement;\n\n  \tmustache.template = options.template;\n  \tmustache.index = options.index || 0;\n  \tmustache.isStatic = options.template.s;\n\n  \tmustache.type = options.template.t;\n\n  \tmustache.registered = false;\n\n  \t// if this is a simple mustache, with a reference, we just need to resolve\n  \t// the reference to a keypath\n  \tif (ref = template.r) {\n  \t\tmustache.resolver = Resolvers_createReferenceResolver(mustache, ref, resolve);\n  \t}\n\n  \t// if it's an expression, we have a bit more work to do\n  \tif (options.template.x) {\n  \t\tmustache.resolver = new Resolvers_ExpressionResolver(mustache, parentFragment, options.template.x, resolveAndRebindChildren);\n  \t}\n\n  \tif (options.template.rx) {\n  \t\tmustache.resolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(mustache, options.template.rx, resolveAndRebindChildren);\n  \t}\n\n  \t// Special case - inverted sections\n  \tif (mustache.template.n === SECTION_UNLESS && !mustache.hasOwnProperty(\"value\")) {\n  \t\tmustache.setValue(undefined);\n  \t}\n\n  \tfunction resolve(keypath) {\n  \t\tmustache.resolve(keypath);\n  \t}\n\n  \tfunction resolveAndRebindChildren(newKeypath) {\n  \t\tvar oldKeypath = mustache.keypath;\n\n  \t\tif (newKeypath != oldKeypath) {\n  \t\t\tmustache.resolve(newKeypath);\n\n  \t\t\tif (oldKeypath !== undefined) {\n  \t\t\t\tmustache.fragments && mustache.fragments.forEach(function (f) {\n  \t\t\t\t\tf.rebind(oldKeypath, newKeypath);\n  \t\t\t\t});\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Mustache_resolve = Mustache$resolve;\n\n  function Mustache$resolve(keypath) {\n  \tvar wasResolved, value, twowayBinding;\n\n  \t// 'Special' keypaths, e.g. @foo or @7, encode a value\n  \tif (keypath && keypath.isSpecial) {\n  \t\tthis.keypath = keypath;\n  \t\tthis.setValue(keypath.value);\n  \t\treturn;\n  \t}\n\n  \t// If we resolved previously, we need to unregister\n  \tif (this.registered) {\n  \t\t// undefined or null\n  \t\tthis.root.viewmodel.unregister(this.keypath, this);\n  \t\tthis.registered = false;\n\n  \t\twasResolved = true;\n  \t}\n\n  \tthis.keypath = keypath;\n\n  \t// If the new keypath exists, we need to register\n  \t// with the viewmodel\n  \tif (keypath != undefined) {\n  \t\t// undefined or null\n  \t\tvalue = this.root.viewmodel.get(keypath);\n  \t\tthis.root.viewmodel.register(keypath, this);\n\n  \t\tthis.registered = true;\n  \t}\n\n  \t// Either way we need to queue up a render (`value`\n  \t// will be `undefined` if there's no keypath)\n  \tthis.setValue(value);\n\n  \t// Two-way bindings need to point to their new target keypath\n  \tif (wasResolved && (twowayBinding = this.twowayBinding)) {\n  \t\ttwowayBinding.rebound();\n  \t}\n  }\n\n  var Mustache_rebind = Mustache$rebind;\n\n  function Mustache$rebind(oldKeypath, newKeypath) {\n  \t// Children first\n  \tif (this.fragments) {\n  \t\tthis.fragments.forEach(function (f) {\n  \t\t\treturn f.rebind(oldKeypath, newKeypath);\n  \t\t});\n  \t}\n\n  \t// Expression mustache?\n  \tif (this.resolver) {\n  \t\tthis.resolver.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Mustache = {\n  \tgetValue: Mustache_getValue,\n  \tinit: Mustache_initialise,\n  \tresolve: Mustache_resolve,\n  \trebind: Mustache_rebind\n  };\n\n  var Interpolator = function (options) {\n  \tthis.type = INTERPOLATOR;\n  \tMustache.init(this, options);\n  };\n\n  Interpolator.prototype = {\n  \tupdate: function () {\n  \t\tthis.node.data = this.value == undefined ? \"\" : this.value;\n  \t},\n  \tresolve: Mustache.resolve,\n  \trebind: Mustache.rebind,\n  \tdetach: shared_detach,\n\n  \tunbind: shared_unbind,\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createTextNode(safeToStringValue(this.value));\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tdetachNode(this.node);\n  \t\t}\n  \t},\n\n  \tgetValue: Mustache.getValue,\n\n  \t// TEMP\n  \tsetValue: function (value) {\n  \t\tvar wrapper;\n\n  \t\t// TODO is there a better way to approach this?\n  \t\tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n\n  \t\tif (!isEqual(value, this.value)) {\n  \t\t\tthis.value = value;\n  \t\t\tthis.parentFragment.bubble();\n\n  \t\t\tif (this.node) {\n  \t\t\t\tglobal_runloop.addView(this);\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function (escape) {\n  \t\tvar string = \"\" + safeToStringValue(this.value);\n  \t\treturn escape ? escapeHtml(string) : string;\n  \t}\n  };\n\n  var items_Interpolator = Interpolator;\n\n  var Section_prototype_bubble = Section$bubble;\n\n  function Section$bubble() {\n  \tthis.parentFragment.bubble();\n  }\n\n  var Section_prototype_detach = Section$detach;\n\n  function Section$detach() {\n  \tvar docFrag;\n\n  \tif (this.fragments.length === 1) {\n  \t\treturn this.fragments[0].detach();\n  \t}\n\n  \tdocFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (item) {\n  \t\tdocFrag.appendChild(item.detach());\n  \t});\n\n  \treturn docFrag;\n  }\n\n  var find = Section$find;\n\n  function Section$find(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].find(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findAll = Section$findAll;\n\n  function Section$findAll(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAll(selector, query);\n  \t}\n  }\n\n  var findAllComponents = Section$findAllComponents;\n\n  function Section$findAllComponents(selector, query) {\n  \tvar i, len;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tthis.fragments[i].findAllComponents(selector, query);\n  \t}\n  }\n\n  var findComponent = Section$findComponent;\n\n  function Section$findComponent(selector) {\n  \tvar i, len, queryResult;\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tif (queryResult = this.fragments[i].findComponent(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var findNextNode = Section$findNextNode;\n\n  function Section$findNextNode(fragment) {\n  \tif (this.fragments[fragment.index + 1]) {\n  \t\treturn this.fragments[fragment.index + 1].firstNode();\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var firstNode = Section$firstNode;\n\n  function Section$firstNode() {\n  \tvar len, i, node;\n\n  \tif (len = this.fragments.length) {\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tif (node = this.fragments[i].firstNode()) {\n  \t\t\t\treturn node;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var shuffle = Section$shuffle;\n\n  function Section$shuffle(newIndices) {\n  \tvar _this = this;\n\n  \tvar parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment;\n\n  \t// short circuit any double-updates, and ensure that this isn't applied to\n  \t// non-list sections\n  \tif (this.shuffling || this.unbound || this.currentSubtype !== SECTION_EACH) {\n  \t\treturn;\n  \t}\n\n  \tthis.shuffling = true;\n  \tglobal_runloop.scheduleTask(function () {\n  \t\treturn _this.shuffling = false;\n  \t});\n\n  \tparentFragment = this.parentFragment;\n\n  \treboundFragments = [];\n\n  \t// TODO: need to update this\n  \t// first, rebind existing fragments\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tvar fragment, by, oldKeypath, newKeypath, deps;\n\n  \t\tif (newIndex === oldIndex) {\n  \t\t\treboundFragments[newIndex] = _this.fragments[oldIndex];\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfragment = _this.fragments[oldIndex];\n\n  \t\tif (firstChange === undefined) {\n  \t\t\tfirstChange = oldIndex;\n  \t\t}\n\n  \t\t// does this fragment need to be torn down?\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.fragmentsToUnrender.push(fragment);\n  \t\t\tfragment.unbind();\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Otherwise, it needs to be rebound to a new index\n  \t\tby = newIndex - oldIndex;\n  \t\toldKeypath = _this.keypath.join(oldIndex);\n  \t\tnewKeypath = _this.keypath.join(newIndex);\n\n  \t\tfragment.index = newIndex;\n\n  \t\t// notify any registered index refs directly\n  \t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\tdeps.forEach(shuffle__blindRebind);\n  \t\t}\n\n  \t\tfragment.rebind(oldKeypath, newKeypath);\n  \t\treboundFragments[newIndex] = fragment;\n  \t});\n\n  \tnewLength = this.root.viewmodel.get(this.keypath).length;\n\n  \t// If nothing changed with the existing fragments, then we start adding\n  \t// new fragments at the end...\n  \tif (firstChange === undefined) {\n  \t\t// ...unless there are no new fragments to add\n  \t\tif (this.length === newLength) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tfirstChange = this.length;\n  \t}\n\n  \tthis.length = this.fragments.length = newLength;\n\n  \tif (this.rendered) {\n  \t\tglobal_runloop.addView(this);\n  \t}\n\n  \t// Prepare new fragment options\n  \tfragmentOptions = {\n  \t\ttemplate: this.template.f,\n  \t\troot: this.root,\n  \t\towner: this\n  \t};\n\n  \t// Add as many new fragments as we need to, or add back existing\n  \t// (detached) fragments\n  \tfor (i = firstChange; i < newLength; i += 1) {\n  \t\tfragment = reboundFragments[i];\n\n  \t\tif (!fragment) {\n  \t\t\tthis.fragmentsToCreate.push(i);\n  \t\t}\n\n  \t\tthis.fragments[i] = fragment;\n  \t}\n  }\n\n  function shuffle__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_rebind = function (oldKeypath, newKeypath) {\n  \tMustache.rebind.call(this, oldKeypath, newKeypath);\n  };\n\n  var Section_prototype_render = Section$render;\n\n  function Section$render() {\n  \tvar _this = this;\n\n  \tthis.docFrag = document.createDocumentFragment();\n\n  \tthis.fragments.forEach(function (f) {\n  \t\treturn _this.docFrag.appendChild(f.render());\n  \t});\n\n  \tthis.renderedFragments = this.fragments.slice();\n  \tthis.fragmentsToRender = [];\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var setValue = Section$setValue;\n\n  function Section$setValue(value) {\n  \tvar _this = this;\n\n  \tvar wrapper, fragmentOptions;\n\n  \tif (this.updating) {\n  \t\t// If a child of this section causes a re-evaluation - for example, an\n  \t\t// expression refers to a function that mutates the array that this\n  \t\t// section depends on - we'll end up with a double rendering bug (see\n  \t\t// https://github.com/ractivejs/ractive/issues/748). This prevents it.\n  \t\treturn;\n  \t}\n\n  \tthis.updating = true;\n\n  \t// with sections, we need to get the fake value if we have a wrapped object\n  \tif (this.keypath && (wrapper = this.root.viewmodel.wrapped[this.keypath.str])) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \t// If any fragments are awaiting creation after a splice,\n  \t// this is the place to do it\n  \tif (this.fragmentsToCreate.length) {\n  \t\tfragmentOptions = {\n  \t\t\ttemplate: this.template.f || [],\n  \t\t\troot: this.root,\n  \t\t\tpElement: this.pElement,\n  \t\t\towner: this\n  \t\t};\n\n  \t\tthis.fragmentsToCreate.forEach(function (index) {\n  \t\t\tvar fragment;\n\n  \t\t\tfragmentOptions.context = _this.keypath.join(index);\n  \t\t\tfragmentOptions.index = index;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t_this.fragmentsToRender.push(_this.fragments[index] = fragment);\n  \t\t});\n\n  \t\tthis.fragmentsToCreate.length = 0;\n  \t} else if (reevaluateSection(this, value)) {\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n\n  \tthis.value = value;\n  \tthis.updating = false;\n  }\n\n  function changeCurrentSubtype(section, value, obj) {\n  \tif (value === SECTION_EACH) {\n  \t\t// make sure ref type is up to date for key or value indices\n  \t\tif (section.indexRefs && section.indexRefs[0]) {\n  \t\t\tvar ref = section.indexRefs[0];\n\n  \t\t\t// when switching flavors, make sure the section gets updated\n  \t\t\tif (obj && ref.t === \"i\" || !obj && ref.t === \"k\") {\n  \t\t\t\t// if switching from object to list, unbind all of the old fragments\n  \t\t\t\tif (!obj) {\n  \t\t\t\t\tsection.length = 0;\n  \t\t\t\t\tsection.fragmentsToUnrender = section.fragments.slice(0);\n  \t\t\t\t\tsection.fragmentsToUnrender.forEach(function (f) {\n  \t\t\t\t\t\treturn f.unbind();\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tref.t = obj ? \"k\" : \"i\";\n  \t\t}\n  \t}\n\n  \tsection.currentSubtype = value;\n  }\n\n  function reevaluateSection(section, value) {\n  \tvar fragmentOptions = {\n  \t\ttemplate: section.template.f || [],\n  \t\troot: section.root,\n  \t\tpElement: section.parentFragment.pElement,\n  \t\towner: section\n  \t};\n\n  \tsection.hasContext = true;\n\n  \t// If we already know the section type, great\n  \t// TODO can this be optimised? i.e. pick an reevaluateSection function during init\n  \t// and avoid doing this each time?\n  \tif (section.subtype) {\n  \t\tswitch (section.subtype) {\n  \t\t\tcase SECTION_IF:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n\n  \t\t\tcase SECTION_UNLESS:\n  \t\t\t\tsection.hasContext = false;\n  \t\t\t\treturn reevaluateConditionalSection(section, value, true, fragmentOptions);\n\n  \t\t\tcase SECTION_WITH:\n  \t\t\t\treturn reevaluateContextSection(section, fragmentOptions);\n\n  \t\t\tcase SECTION_IF_WITH:\n  \t\t\t\treturn reevaluateConditionalContextSection(section, value, fragmentOptions);\n\n  \t\t\tcase SECTION_EACH:\n  \t\t\t\tif (isObject(value)) {\n  \t\t\t\t\tchangeCurrentSubtype(section, section.subtype, true);\n  \t\t\t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t\t\t}\n\n  \t\t\t\t// Fallthrough - if it's a conditional or an array we need to continue\n  \t\t}\n  \t}\n\n  \t// Otherwise we need to work out what sort of section we're dealing with\n  \tsection.ordered = !!isArrayLike(value);\n\n  \t// Ordered list section\n  \tif (section.ordered) {\n  \t\tchangeCurrentSubtype(section, SECTION_EACH, false);\n  \t\treturn reevaluateListSection(section, value, fragmentOptions);\n  \t}\n\n  \t// Unordered list, or context\n  \tif (isObject(value) || typeof value === \"function\") {\n  \t\t// Index reference indicates section should be treated as a list\n  \t\tif (section.template.i) {\n  \t\t\tchangeCurrentSubtype(section, SECTION_EACH, true);\n  \t\t\treturn reevaluateListObjectSection(section, value, fragmentOptions);\n  \t\t}\n\n  \t\t// Otherwise, object provides context for contents\n  \t\tchangeCurrentSubtype(section, SECTION_WITH, false);\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t}\n\n  \t// Conditional section\n  \tchangeCurrentSubtype(section, SECTION_IF, false);\n  \tsection.hasContext = false;\n  \treturn reevaluateConditionalSection(section, value, false, fragmentOptions);\n  }\n\n  function reevaluateListSection(section, value, fragmentOptions) {\n  \tvar i, length, fragment;\n\n  \tlength = value.length;\n\n  \tif (length === section.length) {\n  \t\t// Nothing to do\n  \t\treturn false;\n  \t}\n\n  \t// if the array is shorter than it was previously, remove items\n  \tif (length < section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(length, section.length - length);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t}\n\n  \t// otherwise...\n  \telse {\n  \t\tif (length > section.length) {\n  \t\t\t// add any new ones\n  \t\t\tfor (i = section.length; i < length; i += 1) {\n  \t\t\t\t// append list item to context stack\n  \t\t\t\tfragmentOptions.context = section.keypath.join(i);\n  \t\t\t\tfragmentOptions.index = i;\n\n  \t\t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\t\tsection.fragmentsToRender.push(section.fragments[i] = fragment);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tsection.length = length;\n  \treturn true;\n  }\n\n  function reevaluateListObjectSection(section, value, fragmentOptions) {\n  \tvar id, i, hasKey, fragment, changed, deps;\n\n  \thasKey = section.hasKey || (section.hasKey = {});\n\n  \t// remove any fragments that should no longer exist\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (!(fragment.key in value)) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragment.unbind();\n  \t\t\tsection.fragmentsToUnrender.push(fragment);\n  \t\t\tsection.fragments.splice(i, 1);\n\n  \t\t\thasKey[fragment.key] = false;\n  \t\t}\n  \t}\n\n  \t// notify any dependents about changed indices\n  \ti = section.fragments.length;\n  \twhile (i--) {\n  \t\tfragment = section.fragments[i];\n\n  \t\tif (fragment.index !== i) {\n  \t\t\tfragment.index = i;\n  \t\t\tif (deps = fragment.registeredIndexRefs) {\n  \t\t\t\tdeps.forEach(setValue__blindRebind);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// add any that haven't been created yet\n  \ti = section.fragments.length;\n  \tfor (id in value) {\n  \t\tif (!hasKey[id]) {\n  \t\t\tchanged = true;\n\n  \t\t\tfragmentOptions.context = section.keypath.join(id);\n  \t\t\tfragmentOptions.key = id;\n  \t\t\tfragmentOptions.index = i++;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\t\tsection.fragmentsToRender.push(fragment);\n  \t\t\tsection.fragments.push(fragment);\n  \t\t\thasKey[id] = true;\n  \t\t}\n  \t}\n\n  \tsection.length = section.fragments.length;\n  \treturn changed;\n  }\n\n  function reevaluateConditionalContextSection(section, value, fragmentOptions) {\n  \tif (value) {\n  \t\treturn reevaluateContextSection(section, fragmentOptions);\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function reevaluateContextSection(section, fragmentOptions) {\n  \tvar fragment;\n\n  \t// ...then if it isn't rendered, render it, adding section.keypath to the context stack\n  \t// (if it is already rendered, then any children dependent on the context stack\n  \t// will update themselves without any prompting)\n  \tif (!section.length) {\n  \t\t// append this section to the context stack\n  \t\tfragmentOptions.context = section.keypath;\n  \t\tfragmentOptions.index = 0;\n\n  \t\tfragment = new virtualdom_Fragment(fragmentOptions);\n\n  \t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\tsection.length = 1;\n\n  \t\treturn true;\n  \t}\n  }\n\n  function reevaluateConditionalSection(section, value, inverted, fragmentOptions) {\n  \tvar doRender, emptyArray, emptyObject, fragment, name;\n\n  \temptyArray = isArrayLike(value) && value.length === 0;\n  \temptyObject = false;\n  \tif (!isArrayLike(value) && isObject(value)) {\n  \t\temptyObject = true;\n  \t\tfor (name in value) {\n  \t\t\temptyObject = false;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (inverted) {\n  \t\tdoRender = emptyArray || emptyObject || !value;\n  \t} else {\n  \t\tdoRender = value && !emptyArray && !emptyObject;\n  \t}\n\n  \tif (doRender) {\n  \t\tif (!section.length) {\n  \t\t\t// no change to context stack\n  \t\t\tfragmentOptions.index = 0;\n\n  \t\t\tfragment = new virtualdom_Fragment(fragmentOptions);\n  \t\t\tsection.fragmentsToRender.push(section.fragments[0] = fragment);\n  \t\t\tsection.length = 1;\n\n  \t\t\treturn true;\n  \t\t}\n\n  \t\tif (section.length > 1) {\n  \t\t\tsection.fragmentsToUnrender = section.fragments.splice(1);\n  \t\t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n\n  \t\t\treturn true;\n  \t\t}\n  \t} else {\n  \t\treturn removeSectionFragments(section);\n  \t}\n  }\n\n  function removeSectionFragments(section) {\n  \tif (section.length) {\n  \t\tsection.fragmentsToUnrender = section.fragments.splice(0, section.fragments.length).filter(isRendered);\n  \t\tsection.fragmentsToUnrender.forEach(methodCallers__unbind);\n  \t\tsection.length = section.fragmentsToRender.length = 0;\n  \t\treturn true;\n  \t}\n  }\n\n  function isRendered(fragment) {\n  \treturn fragment.rendered;\n  }\n\n  function setValue__blindRebind(dep) {\n  \t// the keypath doesn't actually matter here as it won't have changed\n  \tdep.rebind(\"\", \"\");\n  }\n\n  var prototype_toString = Section$toString;\n\n  function Section$toString(escape) {\n  \tvar str, i, len;\n\n  \tstr = \"\";\n\n  \ti = 0;\n  \tlen = this.length;\n\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tstr += this.fragments[i].toString(escape);\n  \t}\n\n  \treturn str;\n  }\n\n  var prototype_unbind = Section$unbind;\n  function Section$unbind() {\n  \tvar _this = this;\n\n  \tthis.fragments.forEach(methodCallers__unbind);\n  \tthis.fragmentsToRender.forEach(function (f) {\n  \t\treturn removeFromArray(_this.fragments, f);\n  \t});\n  \tthis.fragmentsToRender = [];\n  \tshared_unbind.call(this);\n\n  \tthis.length = 0;\n  \tthis.unbound = true;\n  }\n\n  var prototype_unrender = Section$unrender;\n\n  function Section$unrender(shouldDestroy) {\n  \tthis.fragments.forEach(shouldDestroy ? unrenderAndDestroy : prototype_unrender__unrender);\n  \tthis.renderedFragments = [];\n  \tthis.rendered = false;\n  }\n\n  function unrenderAndDestroy(fragment) {\n  \tfragment.unrender(true);\n  }\n\n  function prototype_unrender__unrender(fragment) {\n  \tfragment.unrender(false);\n  }\n\n  var prototype_update = Section$update;\n\n  function Section$update() {\n  \tvar fragment, renderIndex, renderedFragments, anchor, target, i, len;\n\n  \t// `this.renderedFragments` is in the order of the previous render.\n  \t// If fragments have shuffled about, this allows us to quickly\n  \t// reinsert them in the correct place\n  \trenderedFragments = this.renderedFragments;\n\n  \t// Remove fragments that have been marked for destruction\n  \twhile (fragment = this.fragmentsToUnrender.pop()) {\n  \t\tfragment.unrender(true);\n  \t\trenderedFragments.splice(renderedFragments.indexOf(fragment), 1);\n  \t}\n\n  \t// Render new fragments (but don't insert them yet)\n  \twhile (fragment = this.fragmentsToRender.shift()) {\n  \t\tfragment.render();\n  \t}\n\n  \tif (this.rendered) {\n  \t\ttarget = this.parentFragment.getNode();\n  \t}\n\n  \tlen = this.fragments.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tfragment = this.fragments[i];\n  \t\trenderIndex = renderedFragments.indexOf(fragment, i); // search from current index - it's guaranteed to be the same or higher\n\n  \t\tif (renderIndex === i) {\n  \t\t\t// already in the right place. insert accumulated nodes (if any) and carry on\n  \t\t\tif (this.docFrag.childNodes.length) {\n  \t\t\t\tanchor = fragment.firstNode();\n  \t\t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t\t}\n\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tthis.docFrag.appendChild(fragment.detach());\n\n  \t\t// update renderedFragments\n  \t\tif (renderIndex !== -1) {\n  \t\t\trenderedFragments.splice(renderIndex, 1);\n  \t\t}\n  \t\trenderedFragments.splice(i, 0, fragment);\n  \t}\n\n  \tif (this.rendered && this.docFrag.childNodes.length) {\n  \t\tanchor = this.parentFragment.findNextNode(this);\n  \t\ttarget.insertBefore(this.docFrag, anchor);\n  \t}\n\n  \t// Save the rendering order for next time\n  \tthis.renderedFragments = this.fragments.slice();\n  }\n\n  var Section = function (options) {\n  \tthis.type = SECTION;\n  \tthis.subtype = this.currentSubtype = options.template.n;\n  \tthis.inverted = this.subtype === SECTION_UNLESS;\n\n  \tthis.pElement = options.pElement;\n\n  \tthis.fragments = [];\n  \tthis.fragmentsToCreate = [];\n  \tthis.fragmentsToRender = [];\n  \tthis.fragmentsToUnrender = [];\n\n  \tif (options.template.i) {\n  \t\tthis.indexRefs = options.template.i.split(\",\").map(function (k, i) {\n  \t\t\treturn { n: k, t: i === 0 ? \"k\" : \"i\" };\n  \t\t});\n  \t}\n\n  \tthis.renderedFragments = [];\n\n  \tthis.length = 0; // number of times this section is rendered\n\n  \tMustache.init(this, options);\n  };\n\n  Section.prototype = {\n  \tbubble: Section_prototype_bubble,\n  \tdetach: Section_prototype_detach,\n  \tfind: find,\n  \tfindAll: findAll,\n  \tfindAllComponents: findAllComponents,\n  \tfindComponent: findComponent,\n  \tfindNextNode: findNextNode,\n  \tfirstNode: firstNode,\n  \tgetIndexRef: function (name) {\n  \t\tif (this.indexRefs) {\n  \t\t\tvar i = this.indexRefs.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tvar ref = this.indexRefs[i];\n  \t\t\t\tif (ref.n === name) {\n  \t\t\t\t\treturn ref;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t},\n  \tgetValue: Mustache.getValue,\n  \tshuffle: shuffle,\n  \trebind: prototype_rebind,\n  \trender: Section_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: setValue,\n  \ttoString: prototype_toString,\n  \tunbind: prototype_unbind,\n  \tunrender: prototype_unrender,\n  \tupdate: prototype_update\n  };\n\n  var _Section = Section;\n\n  var Triple_prototype_detach = Triple$detach;\n\n  function Triple$detach() {\n  \tvar len, i;\n\n  \tif (this.docFrag) {\n  \t\tlen = this.nodes.length;\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\tthis.docFrag.appendChild(this.nodes[i]);\n  \t\t}\n\n  \t\treturn this.docFrag;\n  \t}\n  }\n\n  var Triple_prototype_find = Triple$find;\n  function Triple$find(selector) {\n  \tvar i, len, node, queryResult;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\treturn node;\n  \t\t}\n\n  \t\tif (queryResult = node.querySelector(selector)) {\n  \t\t\treturn queryResult;\n  \t\t}\n  \t}\n\n  \treturn null;\n  }\n\n  var Triple_prototype_findAll = Triple$findAll;\n  function Triple$findAll(selector, queryResult) {\n  \tvar i, len, node, queryAllResult, numNodes, j;\n\n  \tlen = this.nodes.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tnode = this.nodes[i];\n\n  \t\tif (node.nodeType !== 1) {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (matches(node, selector)) {\n  \t\t\tqueryResult.push(node);\n  \t\t}\n\n  \t\tif (queryAllResult = node.querySelectorAll(selector)) {\n  \t\t\tnumNodes = queryAllResult.length;\n  \t\t\tfor (j = 0; j < numNodes; j += 1) {\n  \t\t\t\tqueryResult.push(queryAllResult[j]);\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_firstNode = Triple$firstNode;\n\n  function Triple$firstNode() {\n  \tif (this.rendered && this.nodes[0]) {\n  \t\treturn this.nodes[0];\n  \t}\n\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var elementCache = {},\n      ieBug,\n      ieBlacklist;\n\n  try {\n  \tcreateElement(\"table\").innerHTML = \"foo\";\n  } catch (err) {\n  \tieBug = true;\n\n  \tieBlacklist = {\n  \t\tTABLE: [\"<table class=\\\"x\\\">\", \"</table>\"],\n  \t\tTHEAD: [\"<table><thead class=\\\"x\\\">\", \"</thead></table>\"],\n  \t\tTBODY: [\"<table><tbody class=\\\"x\\\">\", \"</tbody></table>\"],\n  \t\tTR: [\"<table><tr class=\\\"x\\\">\", \"</tr></table>\"],\n  \t\tSELECT: [\"<select class=\\\"x\\\">\", \"</select>\"]\n  \t};\n  }\n\n  var insertHtml = function (html, node, docFrag) {\n  \tvar container,\n  \t    nodes = [],\n  \t    wrapper,\n  \t    selectedOption,\n  \t    child,\n  \t    i;\n\n  \t// render 0 and false\n  \tif (html != null && html !== \"\") {\n  \t\tif (ieBug && (wrapper = ieBlacklist[node.tagName])) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = wrapper[0] + html + wrapper[1];\n  \t\t\tcontainer = container.querySelector(\".x\");\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t} else if (node.namespaceURI === namespaces.svg) {\n  \t\t\tcontainer = element(\"DIV\");\n  \t\t\tcontainer.innerHTML = \"<svg class=\\\"x\\\">\" + html + \"</svg>\";\n  \t\t\tcontainer = container.querySelector(\".x\");\n  \t\t} else {\n  \t\t\tcontainer = element(node.tagName);\n  \t\t\tcontainer.innerHTML = html;\n\n  \t\t\tif (container.tagName === \"SELECT\") {\n  \t\t\t\tselectedOption = container.options[container.selectedIndex];\n  \t\t\t}\n  \t\t}\n\n  \t\twhile (child = container.firstChild) {\n  \t\t\tnodes.push(child);\n  \t\t\tdocFrag.appendChild(child);\n  \t\t}\n\n  \t\t// This is really annoying. Extracting <option> nodes from the\n  \t\t// temporary container <select> causes the remaining ones to\n  \t\t// become selected. So now we have to deselect them. IE8, you\n  \t\t// amaze me. You really do\n  \t\t// ...and now Chrome too\n  \t\tif (node.tagName === \"SELECT\") {\n  \t\t\ti = nodes.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tif (nodes[i] !== selectedOption) {\n  \t\t\t\t\tnodes[i].selected = false;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn nodes;\n  };\n\n  function element(tagName) {\n  \treturn elementCache[tagName] || (elementCache[tagName] = createElement(tagName));\n  }\n\n  var helpers_updateSelect = updateSelect;\n\n  function updateSelect(parentElement) {\n  \tvar selectedOptions, option, value;\n\n  \tif (!parentElement || parentElement.name !== \"select\" || !parentElement.binding) {\n  \t\treturn;\n  \t}\n\n  \tselectedOptions = toArray(parentElement.node.options).filter(isSelected);\n\n  \t// If one of them had a `selected` attribute, we need to sync\n  \t// the model to the view\n  \tif (parentElement.getAttribute(\"multiple\")) {\n  \t\tvalue = selectedOptions.map(function (o) {\n  \t\t\treturn o.value;\n  \t\t});\n  \t} else if (option = selectedOptions[0]) {\n  \t\tvalue = option.value;\n  \t}\n\n  \tif (value !== undefined) {\n  \t\tparentElement.binding.setValue(value);\n  \t}\n\n  \tparentElement.bubble();\n  }\n\n  function isSelected(option) {\n  \treturn option.selected;\n  }\n\n  var Triple_prototype_render = Triple$render;\n  function Triple$render() {\n  \tif (this.rendered) {\n  \t\tthrow new Error(\"Attempted to render an item that was already rendered\");\n  \t}\n\n  \tthis.docFrag = document.createDocumentFragment();\n  \tthis.nodes = insertHtml(this.value, this.parentFragment.getNode(), this.docFrag);\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n\n  \tthis.rendered = true;\n  \treturn this.docFrag;\n  }\n\n  var prototype_setValue = Triple$setValue;\n  function Triple$setValue(value) {\n  \tvar wrapper;\n\n  \t// TODO is there a better way to approach this?\n  \tif (wrapper = this.root.viewmodel.wrapped[this.keypath.str]) {\n  \t\tvalue = wrapper.get();\n  \t}\n\n  \tif (value !== this.value) {\n  \t\tthis.value = value;\n  \t\tthis.parentFragment.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var Triple_prototype_toString = Triple$toString;\n  function Triple$toString() {\n  \treturn this.value != undefined ? decodeCharacterReferences(\"\" + this.value) : \"\";\n  }\n\n  var Triple_prototype_unrender = Triple$unrender;\n  function Triple$unrender(shouldDestroy) {\n  \tif (this.rendered && shouldDestroy) {\n  \t\tthis.nodes.forEach(detachNode);\n  \t\tthis.rendered = false;\n  \t}\n\n  \t// TODO update live queries\n  }\n\n  var Triple_prototype_update = Triple$update;\n  function Triple$update() {\n  \tvar node, parentNode;\n\n  \tif (!this.rendered) {\n  \t\treturn;\n  \t}\n\n  \t// Remove existing nodes\n  \twhile (this.nodes && this.nodes.length) {\n  \t\tnode = this.nodes.pop();\n  \t\tnode.parentNode.removeChild(node);\n  \t}\n\n  \t// Insert new nodes\n  \tparentNode = this.parentFragment.getNode();\n\n  \tthis.nodes = insertHtml(this.value, parentNode, this.docFrag);\n  \tparentNode.insertBefore(this.docFrag, this.parentFragment.findNextNode(this));\n\n  \t// Special case - we're inserting the contents of a <select>\n  \thelpers_updateSelect(this.pElement);\n  }\n\n  var Triple = function (options) {\n  \tthis.type = TRIPLE;\n  \tMustache.init(this, options);\n  };\n\n  Triple.prototype = {\n  \tdetach: Triple_prototype_detach,\n  \tfind: Triple_prototype_find,\n  \tfindAll: Triple_prototype_findAll,\n  \tfirstNode: Triple_prototype_firstNode,\n  \tgetValue: Mustache.getValue,\n  \trebind: Mustache.rebind,\n  \trender: Triple_prototype_render,\n  \tresolve: Mustache.resolve,\n  \tsetValue: prototype_setValue,\n  \ttoString: Triple_prototype_toString,\n  \tunbind: shared_unbind,\n  \tunrender: Triple_prototype_unrender,\n  \tupdate: Triple_prototype_update\n  };\n\n  var _Triple = Triple;\n\n  var Element_prototype_bubble = function () {\n  \tthis.parentFragment.bubble();\n  };\n\n  var Element_prototype_detach = Element$detach;\n\n  function Element$detach() {\n  \tvar node = this.node,\n  \t    parentNode;\n\n  \tif (node) {\n  \t\t// need to check for parent node - DOM may have been altered\n  \t\t// by something other than Ractive! e.g. jQuery UI...\n  \t\tif (parentNode = node.parentNode) {\n  \t\t\tparentNode.removeChild(node);\n  \t\t}\n\n  \t\treturn node;\n  \t}\n  }\n\n  var Element_prototype_find = function (selector) {\n  \tif (!this.node) {\n  \t\t// this element hasn't been rendered yet\n  \t\treturn null;\n  \t}\n\n  \tif (matches(this.node, selector)) {\n  \t\treturn this.node;\n  \t}\n\n  \tif (this.fragment && this.fragment.find) {\n  \t\treturn this.fragment.find(selector);\n  \t}\n  };\n\n  var Element_prototype_findAll = function (selector, query) {\n  \t// Add this node to the query, if applicable, and register the\n  \t// query on this element\n  \tif (query._test(this, true) && query.live) {\n  \t\t(this.liveQueries || (this.liveQueries = [])).push(query);\n  \t}\n\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAll(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findAllComponents = function (selector, query) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.findAllComponents(selector, query);\n  \t}\n  };\n\n  var Element_prototype_findComponent = function (selector) {\n  \tif (this.fragment) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t}\n  };\n\n  var Element_prototype_findNextNode = Element$findNextNode;\n\n  function Element$findNextNode() {\n  \treturn null;\n  }\n\n  var Element_prototype_firstNode = Element$firstNode;\n\n  function Element$firstNode() {\n  \treturn this.node;\n  }\n\n  var getAttribute = Element$getAttribute;\n\n  function Element$getAttribute(name) {\n  \tif (!this.attributes || !this.attributes[name]) {\n  \t\treturn;\n  \t}\n\n  \treturn this.attributes[name].value;\n  }\n\n  var truthy = /^true|on|yes|1$/i;\n  var processBindingAttributes__isNumeric = /^[0-9]+$/;\n\n  var processBindingAttributes = function (element, template) {\n  \tvar val, attrs, attributes;\n\n  \tattributes = template.a || {};\n  \tattrs = {};\n\n  \t// attributes that are present but don't have a value (=)\n  \t// will be set to the number 0, which we condider to be true\n  \t// the string '0', however is false\n\n  \tval = attributes.twoway;\n  \tif (val !== undefined) {\n  \t\tattrs.twoway = val === 0 || truthy.test(val);\n  \t}\n\n  \tval = attributes.lazy;\n  \tif (val !== undefined) {\n  \t\t// check for timeout value\n  \t\tif (val !== 0 && processBindingAttributes__isNumeric.test(val)) {\n  \t\t\tattrs.lazy = parseInt(val);\n  \t\t} else {\n  \t\t\tattrs.lazy = val === 0 || truthy.test(val);\n  \t\t}\n  \t}\n\n  \treturn attrs;\n  };\n\n  var Attribute_prototype_bubble = Attribute$bubble;\n  function Attribute$bubble() {\n  \tvar value = this.useProperty || !this.rendered ? this.fragment.getValue() : this.fragment.toString();\n\n  \t// TODO this can register the attribute multiple times (see render test\n  \t// 'Attribute with nested mustaches')\n  \tif (!isEqual(value, this.value)) {\n\n  \t\t// Need to clear old id from ractive.nodes\n  \t\tif (this.name === \"id\" && this.value) {\n  \t\t\tdelete this.root.nodes[this.value];\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tif (this.name === \"value\" && this.node) {\n  \t\t\t// We need to store the value on the DOM like this so we\n  \t\t\t// can retrieve it later without it being coerced to a string\n  \t\t\tthis.node._ractive.value = value;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t}\n  }\n\n  var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;\n  svgCamelCaseElements = \"altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern\".split(\" \");\n  svgCamelCaseAttributes = \"attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan\".split(\" \");\n\n  createMap = function (items) {\n  \tvar map = {},\n  \t    i = items.length;\n  \twhile (i--) {\n  \t\tmap[items[i].toLowerCase()] = items[i];\n  \t}\n  \treturn map;\n  };\n\n  map = createMap(svgCamelCaseElements.concat(svgCamelCaseAttributes));\n\n  var enforceCase = function (elementName) {\n  \tvar lowerCaseElementName = elementName.toLowerCase();\n  \treturn map[lowerCaseElementName] || lowerCaseElementName;\n  };\n\n  var determineNameAndNamespace = function (attribute, name) {\n  \tvar colonIndex, namespacePrefix;\n\n  \t// are we dealing with a namespaced attribute, e.g. xlink:href?\n  \tcolonIndex = name.indexOf(\":\");\n  \tif (colonIndex !== -1) {\n\n  \t\t// looks like we are, yes...\n  \t\tnamespacePrefix = name.substr(0, colonIndex);\n\n  \t\t// ...unless it's a namespace *declaration*, which we ignore (on the assumption\n  \t\t// that only valid namespaces will be used)\n  \t\tif (namespacePrefix !== \"xmlns\") {\n  \t\t\tname = name.substring(colonIndex + 1);\n\n  \t\t\tattribute.name = enforceCase(name);\n  \t\t\tattribute.namespace = namespaces[namespacePrefix.toLowerCase()];\n  \t\t\tattribute.namespacePrefix = namespacePrefix;\n\n  \t\t\tif (!attribute.namespace) {\n  \t\t\t\tthrow \"Unknown namespace (\\\"\" + namespacePrefix + \"\\\")\";\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \t// SVG attribute names are case sensitive\n  \tattribute.name = attribute.element.namespace !== namespaces.html ? enforceCase(name) : name;\n  };\n\n  var helpers_getInterpolator = getInterpolator;\n  function getInterpolator(attribute) {\n  \tvar items = attribute.fragment.items;\n\n  \tif (items.length !== 1) {\n  \t\treturn;\n  \t}\n\n  \tif (items[0].type === INTERPOLATOR) {\n  \t\treturn items[0];\n  \t}\n  }\n\n  var prototype_init = Attribute$init;\n  function Attribute$init(options) {\n  \tthis.type = ATTRIBUTE;\n  \tthis.element = options.element;\n  \tthis.root = options.root;\n\n  \tdetermineNameAndNamespace(this, options.name);\n  \tthis.isBoolean = booleanAttributes.test(this.name);\n\n  \t// if it's an empty attribute, or just a straight key-value pair, with no\n  \t// mustache shenanigans, set the attribute accordingly and go home\n  \tif (!options.value || typeof options.value === \"string\") {\n  \t\tthis.value = this.isBoolean ? true : options.value || \"\";\n  \t\treturn;\n  \t}\n\n  \t// otherwise we need to do some work\n\n  \t// share parentFragment with parent element\n  \tthis.parentFragment = this.element.parentFragment;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: options.value,\n  \t\troot: this.root,\n  \t\towner: this\n  \t});\n\n  \t// TODO can we use this.fragment.toString() in some cases? It's quicker\n  \tthis.value = this.fragment.getValue();\n\n  \t// Store a reference to this attribute's interpolator, if its fragment\n  \t// takes the form `{{foo}}`. This is necessary for two-way binding and\n  \t// for correctly rendering HTML later\n  \tthis.interpolator = helpers_getInterpolator(this);\n  \tthis.isBindable = !!this.interpolator && !this.interpolator.isStatic;\n\n  \t// mark as ready\n  \tthis.ready = true;\n  }\n\n  var Attribute_prototype_rebind = Attribute$rebind;\n\n  function Attribute$rebind(oldKeypath, newKeypath) {\n  \tif (this.fragment) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Attribute_prototype_render = Attribute$render;\n  var propertyNames = {\n  \t\"accept-charset\": \"acceptCharset\",\n  \taccesskey: \"accessKey\",\n  \tbgcolor: \"bgColor\",\n  \t\"class\": \"className\",\n  \tcodebase: \"codeBase\",\n  \tcolspan: \"colSpan\",\n  \tcontenteditable: \"contentEditable\",\n  \tdatetime: \"dateTime\",\n  \tdirname: \"dirName\",\n  \t\"for\": \"htmlFor\",\n  \t\"http-equiv\": \"httpEquiv\",\n  \tismap: \"isMap\",\n  \tmaxlength: \"maxLength\",\n  \tnovalidate: \"noValidate\",\n  \tpubdate: \"pubDate\",\n  \treadonly: \"readOnly\",\n  \trowspan: \"rowSpan\",\n  \ttabindex: \"tabIndex\",\n  \tusemap: \"useMap\"\n  };\n  function Attribute$render(node) {\n  \tvar propertyName;\n\n  \tthis.node = node;\n\n  \t// should we use direct property access, or setAttribute?\n  \tif (!node.namespaceURI || node.namespaceURI === namespaces.html) {\n  \t\tpropertyName = propertyNames[this.name] || this.name;\n\n  \t\tif (node[propertyName] !== undefined) {\n  \t\t\tthis.propertyName = propertyName;\n  \t\t}\n\n  \t\t// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.\n  \t\t// node.selected = true rather than node.setAttribute( 'selected', '' )\n  \t\tif (this.isBoolean || this.isTwoway) {\n  \t\t\tthis.useProperty = true;\n  \t\t}\n\n  \t\tif (propertyName === \"value\") {\n  \t\t\tnode._ractive.value = this.value;\n  \t\t}\n  \t}\n\n  \tthis.rendered = true;\n  \tthis.update();\n  }\n\n  var Attribute_prototype_toString = Attribute$toString;\n\n  function Attribute$toString() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar namespacePrefix = _ref.namespacePrefix;\n  \tvar value = _ref.value;\n  \tvar interpolator = _ref.interpolator;\n  \tvar fragment = _ref.fragment;\n\n  \t// Special case - select and textarea values (should not be stringified)\n  \tif (name === \"value\" && (this.element.name === \"select\" || this.element.name === \"textarea\")) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - content editable\n  \tif (name === \"value\" && this.element.getAttribute(\"contenteditable\") !== undefined) {\n  \t\treturn;\n  \t}\n\n  \t// Special case - radio names\n  \tif (name === \"name\" && this.element.name === \"input\" && interpolator) {\n  \t\treturn \"name={{\" + (interpolator.keypath.str || interpolator.ref) + \"}}\";\n  \t}\n\n  \t// Boolean attributes\n  \tif (this.isBoolean) {\n  \t\treturn value ? name : \"\";\n  \t}\n\n  \tif (fragment) {\n  \t\t// special case - this catches undefined/null values (#1211)\n  \t\tif (fragment.items.length === 1 && fragment.items[0].value == null) {\n  \t\t\treturn \"\";\n  \t\t}\n\n  \t\tvalue = fragment.toString();\n  \t}\n\n  \tif (namespacePrefix) {\n  \t\tname = namespacePrefix + \":\" + name;\n  \t}\n\n  \treturn value ? name + \"=\\\"\" + Attribute_prototype_toString__escape(value) + \"\\\"\" : name;\n  }\n\n  function Attribute_prototype_toString__escape(value) {\n  \treturn value.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#39;\");\n  }\n\n  var Attribute_prototype_unbind = Attribute$unbind;\n\n  function Attribute$unbind() {\n  \t// ignore non-dynamic attributes\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.name === \"id\") {\n  \t\tdelete this.root.nodes[this.value];\n  \t}\n  }\n\n  var updateSelectValue = Attribute$updateSelect;\n\n  function Attribute$updateSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    option,\n  \t    optionValue,\n  \t    i;\n\n  \tif (!this.locked) {\n  \t\tthis.node._ractive.value = value;\n\n  \t\toptions = this.node.options;\n  \t\ti = options.length;\n\n  \t\twhile (i--) {\n  \t\t\toption = options[i];\n  \t\t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n\n  \t\t\tif (optionValue == value) {\n  \t\t\t\t// double equals as we may be comparing numbers with strings\n  \t\t\t\toption.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// if we're still here, it means the new value didn't match any of the options...\n  \t// TODO figure out what to do in this situation\n  }\n\n  var updateMultipleSelectValue = Attribute$updateMultipleSelect;\n  function Attribute$updateMultipleSelect() {\n  \tvar value = this.value,\n  \t    options,\n  \t    i,\n  \t    option,\n  \t    optionValue;\n\n  \tif (!isArray(value)) {\n  \t\tvalue = [value];\n  \t}\n\n  \toptions = this.node.options;\n  \ti = options.length;\n\n  \twhile (i--) {\n  \t\toption = options[i];\n  \t\toptionValue = option._ractive ? option._ractive.value : option.value; // options inserted via a triple don't have _ractive\n  \t\toption.selected = arrayContains(value, optionValue);\n  \t}\n  }\n\n  var updateRadioName = Attribute$updateRadioName;\n\n  function Attribute$updateRadioName() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tnode.checked = value == node._ractive.value;\n  }\n\n  var updateRadioValue = Attribute$updateRadioValue;\n  function Attribute$updateRadioValue() {\n  \tvar wasChecked,\n  \t    node = this.node,\n  \t    binding,\n  \t    bindings,\n  \t    i;\n\n  \twasChecked = node.checked;\n\n  \tnode.value = this.element.getAttribute(\"value\");\n  \tnode.checked = this.element.getAttribute(\"value\") === this.element.getAttribute(\"name\");\n\n  \t// This is a special case - if the input was checked, and the value\n  \t// changed so that it's no longer checked, the twoway binding is\n  \t// most likely out of date. To fix it we have to jump through some\n  \t// hoops... this is a little kludgy but it works\n  \tif (wasChecked && !node.checked && this.element.binding) {\n  \t\tbindings = this.element.binding.siblings;\n\n  \t\tif (i = bindings.length) {\n  \t\t\twhile (i--) {\n  \t\t\t\tbinding = bindings[i];\n\n  \t\t\t\tif (!binding.element.node) {\n  \t\t\t\t\t// this is the initial render, siblings are still rendering!\n  \t\t\t\t\t// we'll come back later...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tif (binding.element.node.checked) {\n  \t\t\t\t\tglobal_runloop.addRactive(binding.root);\n  \t\t\t\t\treturn binding.handleChange();\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis.root.viewmodel.set(binding.keypath, undefined);\n  \t\t}\n  \t}\n  }\n\n  var updateCheckboxName = Attribute$updateCheckboxName;\n  function Attribute$updateCheckboxName() {\n  \tvar _ref = this;\n\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;var binding = element.binding;var valueAttribute;var i;\n\n  \tvalueAttribute = element.getAttribute(\"value\");\n\n  \tif (!isArray(value)) {\n  \t\tbinding.isChecked = node.checked = value == valueAttribute;\n  \t} else {\n  \t\ti = value.length;\n  \t\twhile (i--) {\n  \t\t\tif (valueAttribute == value[i]) {\n  \t\t\t\tbinding.isChecked = node.checked = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t\tbinding.isChecked = node.checked = false;\n  \t}\n  }\n\n  var updateClassName = Attribute$updateClassName;\n  function Attribute$updateClassName() {\n  \tthis.node.className = safeToStringValue(this.value);\n  }\n\n  var updateIdAttribute = Attribute$updateIdAttribute;\n\n  function Attribute$updateIdAttribute() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \tthis.root.nodes[value] = node;\n  \tnode.id = value;\n  }\n\n  var updateIEStyleAttribute = Attribute$updateIEStyleAttribute;\n\n  function Attribute$updateIEStyleAttribute() {\n  \tvar node, value;\n\n  \tnode = this.node;\n  \tvalue = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tnode.style.setAttribute(\"cssText\", value);\n  }\n\n  var updateContentEditableValue = Attribute$updateContentEditableValue;\n\n  function Attribute$updateContentEditableValue() {\n  \tvar value = this.value;\n\n  \tif (value === undefined) {\n  \t\tvalue = \"\";\n  \t}\n\n  \tif (!this.locked) {\n  \t\tthis.node.innerHTML = value;\n  \t}\n  }\n\n  var updateValue = Attribute$updateValue;\n\n  function Attribute$updateValue() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar value = _ref.value;\n\n  \t// store actual value, so it doesn't get coerced to a string\n  \tnode._ractive.value = value;\n\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tnode.value = value == undefined ? \"\" : value;\n  \t}\n  }\n\n  var updateBoolean = Attribute$updateBooleanAttribute;\n\n  function Attribute$updateBooleanAttribute() {\n  \t// with two-way binding, only update if the change wasn't initiated by the user\n  \t// otherwise the cursor will often be sent to the wrong place\n  \tif (!this.locked) {\n  \t\tthis.node[this.propertyName] = this.value;\n  \t}\n  }\n\n  var updateEverythingElse = Attribute$updateEverythingElse;\n\n  function Attribute$updateEverythingElse() {\n  \tvar _ref = this;\n\n  \tvar node = _ref.node;\n  \tvar namespace = _ref.namespace;\n  \tvar name = _ref.name;\n  \tvar value = _ref.value;\n  \tvar fragment = _ref.fragment;\n\n  \tif (namespace) {\n  \t\tnode.setAttributeNS(namespace, name, (fragment || value).toString());\n  \t} else if (!this.isBoolean) {\n  \t\tif (value == null) {\n  \t\t\tnode.removeAttribute(name);\n  \t\t} else {\n  \t\t\tnode.setAttribute(name, (fragment || value).toString());\n  \t\t}\n  \t}\n\n  \t// Boolean attributes - truthy becomes '', falsy means 'remove attribute'\n  \telse {\n  \t\tif (value) {\n  \t\t\tnode.setAttribute(name, \"\");\n  \t\t} else {\n  \t\t\tnode.removeAttribute(name);\n  \t\t}\n  \t}\n  }\n\n  // There are a few special cases when it comes to updating attributes. For this reason,\n  // the prototype .update() method points to this method, which waits until the\n  // attribute has finished initialising, then replaces the prototype method with a more\n  // suitable one. That way, we save ourselves doing a bunch of tests on each call\n  var Attribute_prototype_update = Attribute$update;\n  function Attribute$update() {\n  \tvar _ref = this;\n\n  \tvar name = _ref.name;\n  \tvar element = _ref.element;\n  \tvar node = _ref.node;var type;var updateMethod;\n\n  \tif (name === \"id\") {\n  \t\tupdateMethod = updateIdAttribute;\n  \t} else if (name === \"value\") {\n  \t\t// special case - selects\n  \t\tif (element.name === \"select\" && name === \"value\") {\n  \t\t\tupdateMethod = element.getAttribute(\"multiple\") ? updateMultipleSelectValue : updateSelectValue;\n  \t\t} else if (element.name === \"textarea\") {\n  \t\t\tupdateMethod = updateValue;\n  \t\t}\n\n  \t\t// special case - contenteditable\n  \t\telse if (element.getAttribute(\"contenteditable\") != null) {\n  \t\t\tupdateMethod = updateContentEditableValue;\n  \t\t}\n\n  \t\t// special case - <input>\n  \t\telse if (element.name === \"input\") {\n  \t\t\ttype = element.getAttribute(\"type\");\n\n  \t\t\t// type='file' value='{{fileList}}'>\n  \t\t\tif (type === \"file\") {\n  \t\t\t\tupdateMethod = noop; // read-only\n  \t\t\t}\n\n  \t\t\t// type='radio' name='{{twoway}}'\n  \t\t\telse if (type === \"radio\" && element.binding && element.binding.name === \"name\") {\n  \t\t\t\tupdateMethod = updateRadioValue;\n  \t\t\t} else {\n  \t\t\t\tupdateMethod = updateValue;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// special case - <input type='radio' name='{{twoway}}' value='foo'>\n  \telse if (this.isTwoway && name === \"name\") {\n  \t\tif (node.type === \"radio\") {\n  \t\t\tupdateMethod = updateRadioName;\n  \t\t} else if (node.type === \"checkbox\") {\n  \t\t\tupdateMethod = updateCheckboxName;\n  \t\t}\n  \t}\n\n  \t// special case - style attributes in Internet Exploder\n  \telse if (name === \"style\" && node.style.setAttribute) {\n  \t\tupdateMethod = updateIEStyleAttribute;\n  \t}\n\n  \t// special case - class names. IE fucks things up, again\n  \telse if (name === \"class\" && (!node.namespaceURI || node.namespaceURI === namespaces.html)) {\n  \t\tupdateMethod = updateClassName;\n  \t} else if (this.useProperty) {\n  \t\tupdateMethod = updateBoolean;\n  \t}\n\n  \tif (!updateMethod) {\n  \t\tupdateMethod = updateEverythingElse;\n  \t}\n\n  \tthis.update = updateMethod;\n  \tthis.update();\n  }\n\n  var Attribute = function (options) {\n  \tthis.init(options);\n  };\n\n  Attribute.prototype = {\n  \tbubble: Attribute_prototype_bubble,\n  \tinit: prototype_init,\n  \trebind: Attribute_prototype_rebind,\n  \trender: Attribute_prototype_render,\n  \ttoString: Attribute_prototype_toString,\n  \tunbind: Attribute_prototype_unbind,\n  \tupdate: Attribute_prototype_update\n  };\n\n  var _Attribute = Attribute;\n\n  var createAttributes = function (element, attributes) {\n  \tvar name,\n  \t    attribute,\n  \t    result = [];\n\n  \tfor (name in attributes) {\n  \t\t// skip binding attributes\n  \t\tif (name === \"twoway\" || name === \"lazy\") {\n  \t\t\tcontinue;\n  \t\t}\n\n  \t\tif (attributes.hasOwnProperty(name)) {\n  \t\t\tattribute = new _Attribute({\n  \t\t\t\telement: element,\n  \t\t\t\tname: name,\n  \t\t\t\tvalue: attributes[name],\n  \t\t\t\troot: element.root\n  \t\t\t});\n\n  \t\t\tresult[name] = attribute;\n\n  \t\t\tif (name !== \"value\") {\n  \t\t\t\tresult.push(attribute);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// value attribute goes last. This is because it\n  \t// may get clamped on render otherwise, e.g. in\n  \t// `<input type='range' value='999' min='0' max='1000'>`\n  \t// since default max is 100\n  \tif (attribute = result.value) {\n  \t\tresult.push(attribute);\n  \t}\n\n  \treturn result;\n  };\n\n  var _ConditionalAttribute__div;\n\n  if (typeof document !== \"undefined\") {\n  \t_ConditionalAttribute__div = createElement(\"div\");\n  }\n\n  var ConditionalAttribute = function (element, template) {\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n\n  \tthis.attributes = [];\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\troot: element.root,\n  \t\towner: this,\n  \t\ttemplate: [template]\n  \t});\n  };\n\n  ConditionalAttribute.prototype = {\n  \tbubble: function () {\n  \t\tif (this.node) {\n  \t\t\tthis.update();\n  \t\t}\n\n  \t\tthis.element.bubble();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \trender: function (node) {\n  \t\tthis.node = node;\n  \t\tthis.isSvg = node.namespaceURI === namespaces.svg;\n\n  \t\tthis.update();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tupdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar str, attrs;\n\n  \t\tstr = this.fragment.toString();\n  \t\tattrs = parseAttributes(str, this.isSvg);\n\n  \t\t// any attributes that previously existed but no longer do\n  \t\t// must be removed\n  \t\tthis.attributes.filter(function (a) {\n  \t\t\treturn notIn(attrs, a);\n  \t\t}).forEach(function (a) {\n  \t\t\t_this.node.removeAttribute(a.name);\n  \t\t});\n\n  \t\tattrs.forEach(function (a) {\n  \t\t\t_this.node.setAttribute(a.name, a.value);\n  \t\t});\n\n  \t\tthis.attributes = attrs;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var _ConditionalAttribute = ConditionalAttribute;\n\n  function parseAttributes(str, isSvg) {\n  \tvar tag = isSvg ? \"svg\" : \"div\";\n  \t_ConditionalAttribute__div.innerHTML = \"<\" + tag + \" \" + str + \"></\" + tag + \">\";\n\n  \treturn toArray(_ConditionalAttribute__div.childNodes[0].attributes);\n  }\n\n  function notIn(haystack, needle) {\n  \tvar i = haystack.length;\n\n  \twhile (i--) {\n  \t\tif (haystack[i].name === needle.name) {\n  \t\t\treturn false;\n  \t\t}\n  \t}\n\n  \treturn true;\n  }\n\n  var createConditionalAttributes = function (element, attributes) {\n  \tif (!attributes) {\n  \t\treturn [];\n  \t}\n\n  \treturn attributes.map(function (a) {\n  \t\treturn new _ConditionalAttribute(element, a);\n  \t});\n  };\n\n  var Binding = function (element) {\n  \tvar interpolator, keypath, value, parentForm;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.attribute = element.attributes[this.name || \"value\"];\n\n  \tinterpolator = this.attribute.interpolator;\n  \tinterpolator.twowayBinding = this;\n\n  \tif (keypath = interpolator.keypath) {\n  \t\tif (keypath.str.slice(-1) === \"}\") {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with expressions (`%s` on <%s>)\", interpolator.resolver.uniqueString, element.name, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (keypath.isSpecial) {\n  \t\t\twarnOnceIfDebug(\"Two-way binding does not work with %s\", interpolator.resolver.ref, { ractive: this.root });\n  \t\t\treturn false;\n  \t\t}\n  \t} else {\n  \t\t// A mustache may be *ambiguous*. Let's say we were given\n  \t\t// `value=\"{{bar}}\"`. If the context was `foo`, and `foo.bar`\n  \t\t// *wasn't* `undefined`, the keypath would be `foo.bar`.\n  \t\t// Then, any user input would result in `foo.bar` being updated.\n  \t\t//\n  \t\t// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be\n  \t\t// left with an unresolved partial keypath - so we are forced to make an\n  \t\t// assumption. That assumption is that the input in question should\n  \t\t// be forced to resolve to `bar`, and any user input would affect `bar`\n  \t\t// and not `foo.bar`.\n  \t\t//\n  \t\t// Did that make any sense? No? Oh. Sorry. Well the moral of the story is\n  \t\t// be explicit when using two-way data-binding about what keypath you're\n  \t\t// updating. Using it in lists is probably a recipe for confusion...\n  \t\tvar ref = interpolator.template.r ? \"'\" + interpolator.template.r + \"' reference\" : \"expression\";\n  \t\twarnIfDebug(\"The %s being used for two-way binding is ambiguous, and may cause unexpected results. Consider initialising your data to eliminate the ambiguity\", ref, { ractive: this.root });\n  \t\tinterpolator.resolver.forceResolution();\n  \t\tkeypath = interpolator.keypath;\n  \t}\n\n  \tthis.attribute.isTwoway = true;\n  \tthis.keypath = keypath;\n\n  \t// initialise value, if it's undefined\n  \tvalue = this.root.viewmodel.get(keypath);\n\n  \tif (value === undefined && this.getInitialValue) {\n  \t\tvalue = this.getInitialValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.root.viewmodel.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tif (parentForm = findParentForm(element)) {\n  \t\tthis.resetValue = value;\n  \t\tparentForm.formBindings.push(this);\n  \t}\n  };\n\n  Binding.prototype = {\n  \thandleChange: function () {\n  \t\tvar _this = this;\n\n  \t\tglobal_runloop.start(this.root);\n  \t\tthis.attribute.locked = true;\n  \t\tthis.root.viewmodel.set(this.keypath, this.getValue());\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.attribute.locked = false;\n  \t\t});\n  \t\tglobal_runloop.end();\n  \t},\n\n  \trebound: function () {\n  \t\tvar bindings, oldKeypath, newKeypath;\n\n  \t\toldKeypath = this.keypath;\n  \t\tnewKeypath = this.attribute.interpolator.keypath;\n\n  \t\t// The attribute this binding is linked to has already done the work\n  \t\tif (oldKeypath === newKeypath) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tremoveFromArray(this.root._twowayBindings[oldKeypath.str], this);\n\n  \t\tthis.keypath = newKeypath;\n\n  \t\tbindings = this.root._twowayBindings[newKeypath.str] || (this.root._twowayBindings[newKeypath.str] = []);\n  \t\tbindings.push(this);\n  \t},\n\n  \tunbind: function () {}\n  };\n\n  Binding.extend = function (properties) {\n  \tvar Parent = this,\n  \t    SpecialisedBinding;\n\n  \tSpecialisedBinding = function (element) {\n  \t\tBinding.call(this, element);\n\n  \t\tif (this.init) {\n  \t\t\tthis.init();\n  \t\t}\n  \t};\n\n  \tSpecialisedBinding.prototype = create(Parent.prototype);\n  \tutils_object__extend(SpecialisedBinding.prototype, properties);\n\n  \tSpecialisedBinding.extend = Binding.extend;\n\n  \treturn SpecialisedBinding;\n  };\n\n  var Binding_Binding = Binding;\n\n  function findParentForm(element) {\n  \twhile (element = element.parent) {\n  \t\tif (element.name === \"form\") {\n  \t\t\treturn element;\n  \t\t}\n  \t}\n  }\n\n  // this is called when the element is unbound.\n  // Specialised bindings can override it\n\n  // This is the handler for DOM events that would lead to a change in the model\n  // (i.e. change, sometimes, input, and occasionally click and keyup)\n  var handleDomEvent = handleChange;\n\n  function handleChange() {\n  \tthis._ractive.binding.handleChange();\n  }\n\n  var GenericBinding;\n\n  GenericBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.value;\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    lazy,\n  \t\t    timeout = false;\n  \t\tthis.rendered = true;\n\n  \t\t// any lazy setting for this element overrides the root\n  \t\t// if the value is a number, it's a timeout\n  \t\tlazy = this.root.lazy;\n  \t\tif (this.element.lazy === true) {\n  \t\t\tlazy = true;\n  \t\t} else if (this.element.lazy === false) {\n  \t\t\tlazy = false;\n  \t\t} else if (is__isNumeric(this.element.lazy)) {\n  \t\t\tlazy = false;\n  \t\t\ttimeout = +this.element.lazy;\n  \t\t} else if (is__isNumeric(lazy || \"\")) {\n  \t\t\ttimeout = +lazy;\n  \t\t\tlazy = false;\n\n  \t\t\t// make sure the timeout is available to the handler\n  \t\t\tthis.element.lazy = timeout;\n  \t\t}\n\n  \t\tthis.handler = timeout ? handleDelay : handleDomEvent;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (!lazy) {\n  \t\t\tnode.addEventListener(\"input\", this.handler, false);\n\n  \t\t\tif (node.attachEvent) {\n  \t\t\t\tnode.addEventListener(\"keyup\", this.handler, false);\n  \t\t\t}\n  \t\t}\n\n  \t\tnode.addEventListener(\"blur\", handleBlur, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n  \t\tthis.rendered = false;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"input\", this.handler, false);\n  \t\tnode.removeEventListener(\"keyup\", this.handler, false);\n  \t\tnode.removeEventListener(\"blur\", handleBlur, false);\n  \t}\n  });\n\n  var Binding_GenericBinding = GenericBinding;\n\n  function handleBlur() {\n  \tvar value;\n\n  \thandleDomEvent.call(this);\n\n  \tvalue = this._ractive.root.viewmodel.get(this._ractive.binding.keypath);\n  \tthis.value = value == undefined ? \"\" : value;\n  }\n\n  function handleDelay() {\n  \tvar binding = this._ractive.binding,\n  \t    el = this;\n\n  \tif (!!binding._timeout) clearTimeout(binding._timeout);\n\n  \tbinding._timeout = setTimeout(function () {\n  \t\tif (binding.rendered) handleDomEvent.call(el);\n  \t\tbinding._timeout = undefined;\n  \t}, binding.element.lazy);\n  }\n\n  var ContentEditableBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.fragment ? this.element.fragment.toString() : \"\";\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.innerHTML;\n  \t}\n  });\n\n  var Binding_ContentEditableBinding = ContentEditableBinding;\n\n  var shared_getSiblings = getSiblings;\n  var sets = {};\n  function getSiblings(id, group, keypath) {\n  \tvar hash = id + group + keypath;\n  \treturn sets[hash] || (sets[hash] = []);\n  }\n\n  var RadioBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radio\", this.element.getAttribute(\"name\"));\n  \t\tthis.siblings.push(this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \thandleChange: function () {\n  \t\tglobal_runloop.start(this.root);\n\n  \t\tthis.siblings.forEach(function (binding) {\n  \t\t\tbinding.root.viewmodel.set(binding.keypath, binding.getValue());\n  \t\t});\n\n  \t\tglobal_runloop.end();\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioBinding = RadioBinding;\n\n  var RadioNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tinit: function () {\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"radioname\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tthis.radioName = true; // so that ractive.updateModel() knows what to do with this\n  \t},\n\n  \tgetInitialValue: function () {\n  \t\tif (this.element.getAttribute(\"checked\")) {\n  \t\t\treturn this.element.getAttribute(\"value\");\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.root.viewmodel.get(this.keypath) == this.element.getAttribute(\"value\");\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar node = this.element.node;\n  \t\treturn node._ractive ? node._ractive.value : node.value;\n  \t},\n\n  \thandleChange: function () {\n  \t\t// If this <input> is the one that's checked, then the value of its\n  \t\t// `name` keypath gets set to its value\n  \t\tif (this.element.node.checked) {\n  \t\t\tBinding_Binding.prototype.handleChange.call(this);\n  \t\t}\n  \t},\n\n  \trebound: function (oldKeypath, newKeypath) {\n  \t\tvar node;\n\n  \t\tBinding_Binding.prototype.rebound.call(this, oldKeypath, newKeypath);\n\n  \t\tif (node = this.element.node) {\n  \t\t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t}\n  });\n\n  var Binding_RadioNameBinding = RadioNameBinding;\n\n  var CheckboxNameBinding = Binding_Binding.extend({\n  \tname: \"name\",\n\n  \tgetInitialValue: function () {\n  \t\t// This only gets called once per group (of inputs that\n  \t\t// share a name), because it only gets called if there\n  \t\t// isn't an initial value. By the same token, we can make\n  \t\t// a note of that fact that there was no initial value,\n  \t\t// and populate it using any `checked` attributes that\n  \t\t// exist (which users should avoid, but which we should\n  \t\t// support anyway to avoid breaking expectations)\n  \t\tthis.noInitialValue = true;\n  \t\treturn [];\n  \t},\n\n  \tinit: function () {\n  \t\tvar existingValue, bindingValue;\n\n  \t\tthis.checkboxName = true; // so that ractive.updateModel() knows what to do with this\n\n  \t\t// Each input has a reference to an array containing it and its\n  \t\t// siblings, as two-way binding depends on being able to ascertain\n  \t\t// the status of all inputs within the group\n  \t\tthis.siblings = shared_getSiblings(this.root._guid, \"checkboxes\", this.keypath.str);\n  \t\tthis.siblings.push(this);\n\n  \t\tif (this.noInitialValue) {\n  \t\t\tthis.siblings.noInitialValue = true;\n  \t\t}\n\n  \t\t// If no initial value was set, and this input is checked, we\n  \t\t// update the model\n  \t\tif (this.siblings.noInitialValue && this.element.getAttribute(\"checked\")) {\n  \t\t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\t\texistingValue.push(bindingValue);\n  \t\t}\n  \t},\n\n  \tunbind: function () {\n  \t\tremoveFromArray(this.siblings, this);\n  \t},\n\n  \trender: function () {\n  \t\tvar node = this.element.node,\n  \t\t    existingValue,\n  \t\t    bindingValue;\n\n  \t\texistingValue = this.root.viewmodel.get(this.keypath);\n  \t\tbindingValue = this.element.getAttribute(\"value\");\n\n  \t\tif (isArray(existingValue)) {\n  \t\t\tthis.isChecked = arrayContains(existingValue, bindingValue);\n  \t\t} else {\n  \t\t\tthis.isChecked = existingValue == bindingValue;\n  \t\t}\n\n  \t\tnode.name = \"{{\" + this.keypath.str + \"}}\";\n  \t\tnode.checked = this.isChecked;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\t// in case of IE emergency, bind to click event as well\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tchanged: function () {\n  \t\tvar wasChecked = !!this.isChecked;\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\treturn this.isChecked === wasChecked;\n  \t},\n\n  \thandleChange: function () {\n  \t\tthis.isChecked = this.element.node.checked;\n  \t\tBinding_Binding.prototype.handleChange.call(this);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.siblings.filter(isChecked).map(Binding_CheckboxNameBinding__getValue);\n  \t}\n  });\n\n  function isChecked(binding) {\n  \treturn binding.isChecked;\n  }\n\n  function Binding_CheckboxNameBinding__getValue(binding) {\n  \treturn binding.element.getAttribute(\"value\");\n  }\n\n  var Binding_CheckboxNameBinding = CheckboxNameBinding;\n\n  var CheckboxBinding = Binding_Binding.extend({\n  \tname: \"checked\",\n\n  \trender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tif (node.attachEvent) {\n  \t\t\tnode.addEventListener(\"click\", handleDomEvent, false);\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tvar node = this.element.node;\n\n  \t\tnode.removeEventListener(\"change\", handleDomEvent, false);\n  \t\tnode.removeEventListener(\"click\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.checked;\n  \t}\n  });\n\n  var Binding_CheckboxBinding = CheckboxBinding;\n\n  var SelectBinding = Binding_Binding.extend({\n  \tgetInitialValue: function () {\n  \t\tvar options = this.element.options,\n  \t\t    len,\n  \t\t    i,\n  \t\t    value,\n  \t\t    optionWasSelected;\n\n  \t\tif (this.element.getAttribute(\"value\") !== undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\ti = len = options.length;\n\n  \t\tif (!len) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// take the final selected option...\n  \t\twhile (i--) {\n  \t\t\tif (options[i].getAttribute(\"selected\")) {\n  \t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n\n  \t\t// or the first non-disabled option, if none are selected\n  \t\tif (!optionWasSelected) {\n  \t\t\twhile (++i < len) {\n  \t\t\t\tif (!options[i].getAttribute(\"disabled\")) {\n  \t\t\t\t\tvalue = options[i].getAttribute(\"value\");\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\t// This is an optimisation (aka hack) that allows us to forgo some\n  \t\t// other more expensive work\n  \t\tif (value !== undefined) {\n  \t\t\tthis.element.attributes.value.value = value;\n  \t\t}\n\n  \t\treturn value;\n  \t},\n\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \t// TODO this method is an anomaly... is it necessary?\n  \tsetValue: function (value) {\n  \t\tthis.root.viewmodel.set(this.keypath, value);\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar options, i, len, option, optionValue;\n\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (options[i].selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\treturn optionValue;\n  \t\t\t}\n  \t\t}\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t}\n  });\n\n  var Binding_SelectBinding = SelectBinding;\n\n  var MultipleSelectBinding = Binding_SelectBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn this.element.options.filter(function (option) {\n  \t\t\treturn option.getAttribute(\"selected\");\n  \t\t}).map(function (option) {\n  \t\t\treturn option.getAttribute(\"value\");\n  \t\t});\n  \t},\n\n  \trender: function () {\n  \t\tvar valueFromModel;\n\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n\n  \t\tvalueFromModel = this.root.viewmodel.get(this.keypath);\n\n  \t\tif (valueFromModel === undefined) {\n  \t\t\t// get value from DOM, if possible\n  \t\t\tthis.handleChange();\n  \t\t}\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tsetValue: function () {\n  \t\tthrow new Error(\"TODO not implemented yet\");\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar selectedValues, options, i, len, option, optionValue;\n\n  \t\tselectedValues = [];\n  \t\toptions = this.element.node.options;\n  \t\tlen = options.length;\n\n  \t\tfor (i = 0; i < len; i += 1) {\n  \t\t\toption = options[i];\n\n  \t\t\tif (option.selected) {\n  \t\t\t\toptionValue = option._ractive ? option._ractive.value : option.value;\n  \t\t\t\tselectedValues.push(optionValue);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn selectedValues;\n  \t},\n\n  \thandleChange: function () {\n  \t\tvar attribute, previousValue, value;\n\n  \t\tattribute = this.attribute;\n  \t\tpreviousValue = attribute.value;\n\n  \t\tvalue = this.getValue();\n\n  \t\tif (previousValue === undefined || !arrayContentsMatch(value, previousValue)) {\n  \t\t\tBinding_SelectBinding.prototype.handleChange.call(this);\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \tforceUpdate: function () {\n  \t\tvar _this = this;\n\n  \t\tvar value = this.getValue();\n\n  \t\tif (value !== undefined) {\n  \t\t\tthis.attribute.locked = true;\n  \t\t\tglobal_runloop.scheduleTask(function () {\n  \t\t\t\treturn _this.attribute.locked = false;\n  \t\t\t});\n  \t\t\tthis.root.viewmodel.set(this.keypath, value);\n  \t\t}\n  \t},\n\n  \tupdateModel: function () {\n  \t\tif (this.attribute.value === undefined || !this.attribute.value.length) {\n  \t\t\tthis.root.viewmodel.set(this.keypath, this.initialValue);\n  \t\t}\n  \t}\n  });\n\n  var Binding_MultipleSelectBinding = MultipleSelectBinding;\n\n  var FileListBinding = Binding_Binding.extend({\n  \trender: function () {\n  \t\tthis.element.node.addEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tunrender: function () {\n  \t\tthis.element.node.removeEventListener(\"change\", handleDomEvent, false);\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.element.node.files;\n  \t}\n  });\n\n  var Binding_FileListBinding = FileListBinding;\n\n  var NumericBinding = Binding_GenericBinding.extend({\n  \tgetInitialValue: function () {\n  \t\treturn undefined;\n  \t},\n\n  \tgetValue: function () {\n  \t\tvar value = parseFloat(this.element.node.value);\n  \t\treturn isNaN(value) ? undefined : value;\n  \t}\n  });\n\n  var init_createTwowayBinding = createTwowayBinding;\n\n  function createTwowayBinding(element) {\n  \tvar attributes = element.attributes,\n  \t    type,\n  \t    Binding,\n  \t    bindName,\n  \t    bindChecked,\n  \t    binding;\n\n  \t// if this is a late binding, and there's already one, it\n  \t// needs to be torn down\n  \tif (element.binding) {\n  \t\telement.binding.teardown();\n  \t\telement.binding = null;\n  \t}\n\n  \t// contenteditable\n  \tif (\n  \t// if the contenteditable attribute is true or is bindable and may thus become true\n  \t(element.getAttribute(\"contenteditable\") || !!attributes.contenteditable && isBindable(attributes.contenteditable)) && isBindable(attributes.value)) {\n  \t\tBinding = Binding_ContentEditableBinding;\n  \t}\n\n  \t// <input>\n  \telse if (element.name === \"input\") {\n  \t\ttype = element.getAttribute(\"type\");\n\n  \t\tif (type === \"radio\" || type === \"checkbox\") {\n  \t\t\tbindName = isBindable(attributes.name);\n  \t\t\tbindChecked = isBindable(attributes.checked);\n\n  \t\t\t// we can either bind the name attribute, or the checked attribute - not both\n  \t\t\tif (bindName && bindChecked) {\n  \t\t\t\twarnIfDebug(\"A radio input can have two-way binding on its name attribute, or its checked attribute - not both\", { ractive: element.root });\n  \t\t\t}\n\n  \t\t\tif (bindName) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioNameBinding : Binding_CheckboxNameBinding;\n  \t\t\t} else if (bindChecked) {\n  \t\t\t\tBinding = type === \"radio\" ? Binding_RadioBinding : Binding_CheckboxBinding;\n  \t\t\t}\n  \t\t} else if (type === \"file\" && isBindable(attributes.value)) {\n  \t\t\tBinding = Binding_FileListBinding;\n  \t\t} else if (isBindable(attributes.value)) {\n  \t\t\tBinding = type === \"number\" || type === \"range\" ? NumericBinding : Binding_GenericBinding;\n  \t\t}\n  \t}\n\n  \t// <select>\n  \telse if (element.name === \"select\" && isBindable(attributes.value)) {\n  \t\tBinding = element.getAttribute(\"multiple\") ? Binding_MultipleSelectBinding : Binding_SelectBinding;\n  \t}\n\n  \t// <textarea>\n  \telse if (element.name === \"textarea\" && isBindable(attributes.value)) {\n  \t\tBinding = Binding_GenericBinding;\n  \t}\n\n  \tif (Binding && (binding = new Binding(element)) && binding.keypath) {\n  \t\treturn binding;\n  \t}\n  }\n\n  function isBindable(attribute) {\n  \treturn attribute && attribute.isBindable;\n  }\n\n  // and this element also has a value attribute to bind\n\n  var EventHandler_prototype_bubble = EventHandler$bubble;\n\n  function EventHandler$bubble() {\n  \tvar hasAction = this.getAction();\n\n  \tif (hasAction && !this.hasListener) {\n  \t\tthis.listen();\n  \t} else if (!hasAction && this.hasListener) {\n  \t\tthis.unrender();\n  \t}\n  }\n\n  // This function may be overwritten, if the event directive\n  // includes parameters\n  var EventHandler_prototype_fire = EventHandler$fire;\n  function EventHandler$fire(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event });\n  }\n\n  var getAction = EventHandler$getAction;\n\n  function EventHandler$getAction() {\n  \treturn this.action.toString().trim();\n  }\n\n  var EventHandler_prototype_init = EventHandler$init;\n\n  var eventPattern = /^event(?:\\.(.+))?/;\n  function EventHandler$init(element, name, template) {\n  \tvar _this = this;\n\n  \tvar action, refs, ractive;\n\n  \tthis.element = element;\n  \tthis.root = element.root;\n  \tthis.parentFragment = element.parentFragment;\n  \tthis.name = name;\n\n  \tif (name.indexOf(\"*\") !== -1) {\n  \t\tfatal(\"Only component proxy-events may contain \\\"*\\\" wildcards, <%s on-%s=\\\"...\\\"/> is not valid\", element.name, name);\n  \t\tthis.invalid = true;\n  \t}\n\n  \tif (template.m) {\n  \t\trefs = template.a.r;\n\n  \t\t// This is a method call\n  \t\tthis.method = template.m;\n  \t\tthis.keypaths = [];\n  \t\tthis.fn = shared_getFunctionFromString(template.a.s, refs.length);\n\n  \t\tthis.parentFragment = element.parentFragment;\n  \t\tractive = this.root;\n\n  \t\t// Create resolvers for each reference\n  \t\tthis.refResolvers = [];\n  \t\trefs.forEach(function (ref, i) {\n  \t\t\tvar match = undefined;\n\n  \t\t\t// special case - the `event` object\n  \t\t\tif (match = eventPattern.exec(ref)) {\n  \t\t\t\t_this.keypaths[i] = {\n  \t\t\t\t\teventObject: true,\n  \t\t\t\t\trefinements: match[1] ? match[1].split(\".\") : []\n  \t\t\t\t};\n  \t\t\t} else {\n  \t\t\t\t_this.refResolvers.push(Resolvers_createReferenceResolver(_this, ref, function (keypath) {\n  \t\t\t\t\treturn _this.resolve(i, keypath);\n  \t\t\t\t}));\n  \t\t\t}\n  \t\t});\n\n  \t\tthis.fire = fireMethodCall;\n  \t} else {\n  \t\t// Get action ('foo' in 'on-click='foo')\n  \t\taction = template.n || template;\n  \t\tif (typeof action !== \"string\") {\n  \t\t\taction = new virtualdom_Fragment({\n  \t\t\t\ttemplate: action,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tthis.action = action;\n\n  \t\t// Get parameters\n  \t\tif (template.d) {\n  \t\t\tthis.dynamicParams = new virtualdom_Fragment({\n  \t\t\t\ttemplate: template.d,\n  \t\t\t\troot: this.root,\n  \t\t\t\towner: this.element\n  \t\t\t});\n\n  \t\t\tthis.fire = fireEventWithDynamicParams;\n  \t\t} else if (template.a) {\n  \t\t\tthis.params = template.a;\n  \t\t\tthis.fire = fireEventWithParams;\n  \t\t}\n  \t}\n  }\n\n  function fireMethodCall(event) {\n  \tvar ractive, values, args;\n\n  \tractive = this.root;\n\n  \tif (typeof ractive[this.method] !== \"function\") {\n  \t\tthrow new Error(\"Attempted to call a non-existent method (\\\"\" + this.method + \"\\\")\");\n  \t}\n\n  \tvalues = this.keypaths.map(function (keypath) {\n  \t\tvar value, len, i;\n\n  \t\tif (keypath === undefined) {\n  \t\t\t// not yet resolved\n  \t\t\treturn undefined;\n  \t\t}\n\n  \t\t// TODO the refinements stuff would be better handled at parse time\n  \t\tif (keypath.eventObject) {\n  \t\t\tvalue = event;\n\n  \t\t\tif (len = keypath.refinements.length) {\n  \t\t\t\tfor (i = 0; i < len; i += 1) {\n  \t\t\t\t\tvalue = value[keypath.refinements[i]];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t} else {\n  \t\t\tvalue = ractive.viewmodel.get(keypath);\n  \t\t}\n\n  \t\treturn value;\n  \t});\n\n  \tshared_eventStack.enqueue(ractive, event);\n\n  \targs = this.fn.apply(null, values);\n  \tractive[this.method].apply(ractive, args);\n\n  \tshared_eventStack.dequeue(ractive);\n  }\n\n  function fireEventWithParams(event) {\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: this.params });\n  }\n\n  function fireEventWithDynamicParams(event) {\n  \tvar args = this.dynamicParams.getArgsList();\n\n  \t// need to strip [] from ends if a string!\n  \tif (typeof args === \"string\") {\n  \t\targs = args.substr(1, args.length - 2);\n  \t}\n\n  \tshared_fireEvent(this.root, this.getAction(), { event: event, args: args });\n  }\n\n  var shared_genericHandler = genericHandler;\n  function genericHandler(event) {\n  \tvar storage,\n  \t    handler,\n  \t    indices,\n  \t    index = {};\n\n  \tstorage = this._ractive;\n  \thandler = storage.events[event.type];\n\n  \tif (indices = Resolvers_findIndexRefs(handler.element.parentFragment)) {\n  \t\tindex = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \thandler.fire({\n  \t\tnode: this,\n  \t\toriginal: event,\n  \t\tindex: index,\n  \t\tkeypath: storage.keypath.str,\n  \t\tcontext: storage.root.viewmodel.get(storage.keypath)\n  \t});\n  }\n\n  var listen = EventHandler$listen;\n\n  var customHandlers = {},\n      touchEvents = {\n  \ttouchstart: true,\n  \ttouchmove: true,\n  \ttouchend: true,\n  \ttouchcancel: true,\n  \t//not w3c, but supported in some browsers\n  \ttouchleave: true\n  };\n  function EventHandler$listen() {\n  \tvar definition,\n  \t    name = this.name;\n\n  \tif (this.invalid) {\n  \t\treturn;\n  \t}\n\n  \tif (definition = findInViewHierarchy(\"events\", this.root, name)) {\n  \t\tthis.custom = definition(this.node, getCustomHandler(name));\n  \t} else {\n  \t\t// Looks like we're dealing with a standard DOM event... but let's check\n  \t\tif (!(\"on\" + name in this.node) && !(window && \"on\" + name in window) && !isJsdom) {\n\n  \t\t\t// okay to use touch events if this browser doesn't support them\n  \t\t\tif (!touchEvents[name]) {\n  \t\t\t\twarnOnceIfDebug(missingPlugin(name, \"event\"), { node: this.node });\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.node.addEventListener(name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = true;\n  }\n\n  function getCustomHandler(name) {\n  \tif (!customHandlers[name]) {\n  \t\tcustomHandlers[name] = function (event) {\n  \t\t\tvar storage = event.node._ractive;\n\n  \t\t\tevent.index = storage.index;\n  \t\t\tevent.keypath = storage.keypath.str;\n  \t\t\tevent.context = storage.root.viewmodel.get(storage.keypath);\n\n  \t\t\tstorage.events[name].fire(event);\n  \t\t};\n  \t}\n\n  \treturn customHandlers[name];\n  }\n\n  var EventHandler_prototype_rebind = EventHandler$rebind;\n\n  function EventHandler$rebind(oldKeypath, newKeypath) {\n  \tvar fragment;\n  \tif (this.method) {\n  \t\tfragment = this.element.parentFragment;\n  \t\tthis.refResolvers.forEach(rebind);\n\n  \t\treturn;\n  \t}\n\n  \tif (typeof this.action !== \"string\") {\n  \t\trebind(this.action);\n  \t}\n\n  \tif (this.dynamicParams) {\n  \t\trebind(this.dynamicParams);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing && thing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var EventHandler_prototype_render = EventHandler$render;\n\n  function EventHandler$render() {\n  \tthis.node = this.element.node;\n  \t// store this on the node itself, so it can be retrieved by a\n  \t// universal handler\n  \tthis.node._ractive.events[this.name] = this;\n\n  \tif (this.method || this.getAction()) {\n  \t\tthis.listen();\n  \t}\n  }\n\n  var prototype_resolve = EventHandler$resolve;\n\n  function EventHandler$resolve(index, keypath) {\n  \tthis.keypaths[index] = keypath;\n  }\n\n  var EventHandler_prototype_unbind = EventHandler$unbind;\n  function EventHandler$unbind() {\n  \tif (this.method) {\n  \t\tthis.refResolvers.forEach(methodCallers__unbind);\n  \t\treturn;\n  \t}\n\n  \t// Tear down dynamic name\n  \tif (typeof this.action !== \"string\") {\n  \t\tthis.action.unbind();\n  \t}\n\n  \t// Tear down dynamic parameters\n  \tif (this.dynamicParams) {\n  \t\tthis.dynamicParams.unbind();\n  \t}\n  }\n\n  var EventHandler_prototype_unrender = EventHandler$unrender;\n  function EventHandler$unrender() {\n\n  \tif (this.custom) {\n  \t\tthis.custom.teardown();\n  \t} else {\n  \t\tthis.node.removeEventListener(this.name, shared_genericHandler, false);\n  \t}\n\n  \tthis.hasListener = false;\n  }\n\n  var EventHandler = function (element, name, template) {\n  \tthis.init(element, name, template);\n  };\n\n  EventHandler.prototype = {\n  \tbubble: EventHandler_prototype_bubble,\n  \tfire: EventHandler_prototype_fire,\n  \tgetAction: getAction,\n  \tinit: EventHandler_prototype_init,\n  \tlisten: listen,\n  \trebind: EventHandler_prototype_rebind,\n  \trender: EventHandler_prototype_render,\n  \tresolve: prototype_resolve,\n  \tunbind: EventHandler_prototype_unbind,\n  \tunrender: EventHandler_prototype_unrender\n  };\n\n  var _EventHandler = EventHandler;\n\n  var createEventHandlers = function (element, template) {\n  \tvar i,\n  \t    name,\n  \t    names,\n  \t    handler,\n  \t    result = [];\n\n  \tfor (name in template) {\n  \t\tif (template.hasOwnProperty(name)) {\n  \t\t\tnames = name.split(\"-\");\n  \t\t\ti = names.length;\n\n  \t\t\twhile (i--) {\n  \t\t\t\thandler = new _EventHandler(element, names[i], template[name]);\n  \t\t\t\tresult.push(handler);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn result;\n  };\n\n  var Decorator = function (element, template) {\n  \tvar self = this,\n  \t    ractive,\n  \t    name,\n  \t    fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no decorator\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = this.fragment.getArgsList();\n\n  \t\tthis.fragment.bubble = function () {\n  \t\t\tthis.dirtyArgs = this.dirtyValue = true;\n  \t\t\tself.params = this.getArgsList();\n\n  \t\t\tif (self.ready) {\n  \t\t\t\tself.update();\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \tthis.fn = findInViewHierarchy(\"decorators\", ractive, name);\n\n  \tif (!this.fn) {\n  \t\tfatal(missingPlugin(name, \"decorator\"));\n  \t}\n  };\n\n  Decorator.prototype = {\n  \tinit: function () {\n  \t\tvar node, result, args;\n\n  \t\tnode = this.element.node;\n\n  \t\tif (this.params) {\n  \t\t\targs = [node].concat(this.params);\n  \t\t\tresult = this.fn.apply(this.root, args);\n  \t\t} else {\n  \t\t\tresult = this.fn.call(this.root, node);\n  \t\t}\n\n  \t\tif (!result || !result.teardown) {\n  \t\t\tthrow new Error(\"Decorator definition must return an object with a teardown method\");\n  \t\t}\n\n  \t\t// TODO does this make sense?\n  \t\tthis.actual = result;\n  \t\tthis.ready = true;\n  \t},\n\n  \tupdate: function () {\n  \t\tif (this.actual.update) {\n  \t\t\tthis.actual.update.apply(this.root, this.params);\n  \t\t} else {\n  \t\t\tthis.actual.teardown(true);\n  \t\t\tthis.init();\n  \t\t}\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \tteardown: function (updating) {\n  \t\tthis.torndown = true;\n  \t\tif (this.ready) {\n  \t\t\tthis.actual.teardown();\n  \t\t}\n\n  \t\tif (!updating && this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t}\n  };\n\n  var _Decorator = Decorator;\n\n  function select__bubble() {\n  \tvar _this = this;\n\n  \tif (!this.dirty) {\n  \t\tthis.dirty = true;\n\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tsync(_this);\n  \t\t\t_this.dirty = false;\n  \t\t});\n  \t}\n\n  \tthis.parentFragment.bubble(); // default behaviour\n  }\n\n  function sync(selectElement) {\n  \tvar selectNode, selectValue, isMultiple, options, optionWasSelected;\n\n  \tselectNode = selectElement.node;\n\n  \tif (!selectNode) {\n  \t\treturn;\n  \t}\n\n  \toptions = toArray(selectNode.options);\n\n  \tselectValue = selectElement.getAttribute(\"value\");\n  \tisMultiple = selectElement.getAttribute(\"multiple\");\n\n  \t// If the <select> has a specified value, that should override\n  \t// these options\n  \tif (selectValue !== undefined) {\n  \t\toptions.forEach(function (o) {\n  \t\t\tvar optionValue, shouldSelect;\n\n  \t\t\toptionValue = o._ractive ? o._ractive.value : o.value;\n  \t\t\tshouldSelect = isMultiple ? valueContains(selectValue, optionValue) : selectValue == optionValue;\n\n  \t\t\tif (shouldSelect) {\n  \t\t\t\toptionWasSelected = true;\n  \t\t\t}\n\n  \t\t\to.selected = shouldSelect;\n  \t\t});\n\n  \t\tif (!optionWasSelected) {\n  \t\t\tif (options[0]) {\n  \t\t\t\toptions[0].selected = true;\n  \t\t\t}\n\n  \t\t\tif (selectElement.binding) {\n  \t\t\t\tselectElement.binding.forceUpdate();\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Otherwise the value should be initialised according to which\n  \t// <option> element is selected, if twoway binding is in effect\n  \telse if (selectElement.binding) {\n  \t\tselectElement.binding.forceUpdate();\n  \t}\n  }\n\n  function valueContains(selectValue, optionValue) {\n  \tvar i = selectValue.length;\n  \twhile (i--) {\n  \t\tif (selectValue[i] == optionValue) {\n  \t\t\treturn true;\n  \t\t}\n  \t}\n  }\n\n  function special_option__init(option, template) {\n  \toption.select = findParentSelect(option.parent);\n\n  \t// we might be inside a <datalist> element\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \toption.select.options.push(option);\n\n  \t// If the value attribute is missing, use the element's content\n  \tif (!template.a) {\n  \t\ttemplate.a = {};\n  \t}\n\n  \t// ...as long as it isn't disabled\n  \tif (template.a.value === undefined && !template.a.hasOwnProperty(\"disabled\")) {\n  \t\ttemplate.a.value = template.f;\n  \t}\n\n  \t// If there is a `selected` attribute, but the <select>\n  \t// already has a value, delete it\n  \tif (\"selected\" in template.a && option.select.getAttribute(\"value\") !== undefined) {\n  \t\tdelete template.a.selected;\n  \t}\n  }\n\n  function special_option__unbind(option) {\n  \tif (option.select) {\n  \t\tremoveFromArray(option.select.options, option);\n  \t}\n  }\n\n  function findParentSelect(element) {\n  \tif (!element) {\n  \t\treturn;\n  \t}\n\n  \tdo {\n  \t\tif (element.name === \"select\") {\n  \t\t\treturn element;\n  \t\t}\n  \t} while (element = element.parent);\n  }\n\n  var Element_prototype_init = Element$init;\n  function Element$init(options) {\n  \tvar parentFragment, template, ractive, binding, bindings, twoway, bindingAttrs;\n\n  \tthis.type = ELEMENT;\n\n  \t// stuff we'll need later\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \ttemplate = this.template = options.template;\n\n  \tthis.parent = options.pElement || parentFragment.pElement;\n\n  \tthis.root = ractive = parentFragment.root;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n\n  \tthis.name = enforceCase(template.e);\n\n  \t// Special case - <option> elements\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__init(this, template);\n  \t}\n\n  \t// Special case - <select> elements\n  \tif (this.name === \"select\") {\n  \t\tthis.options = [];\n  \t\tthis.bubble = select__bubble; // TODO this is a kludge\n  \t}\n\n  \t// Special case - <form> elements\n  \tif (this.name === \"form\") {\n  \t\tthis.formBindings = [];\n  \t}\n\n  \t// handle binding attributes first (twoway, lazy)\n  \tbindingAttrs = processBindingAttributes(this, template);\n\n  \t// create attributes\n  \tthis.attributes = createAttributes(this, template.a);\n  \tthis.conditionalAttributes = createConditionalAttributes(this, template.m);\n\n  \t// append children, if there are any\n  \tif (template.f) {\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.f,\n  \t\t\troot: ractive,\n  \t\t\towner: this,\n  \t\t\tpElement: this,\n  \t\t\tcssIds: null\n  \t\t});\n  \t}\n\n  \t// the element setting should override the ractive setting\n  \ttwoway = ractive.twoway;\n  \tif (bindingAttrs.twoway === false) twoway = false;else if (bindingAttrs.twoway === true) twoway = true;\n\n  \tthis.twoway = twoway;\n  \tthis.lazy = bindingAttrs.lazy;\n\n  \t// create twoway binding\n  \tif (twoway && (binding = init_createTwowayBinding(this, template.a))) {\n  \t\tthis.binding = binding;\n\n  \t\t// register this with the root, so that we can do ractive.updateModel()\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str] || (this.root._twowayBindings[binding.keypath.str] = []);\n  \t\tbindings.push(binding);\n  \t}\n\n  \t// create event proxies\n  \tif (template.v) {\n  \t\tthis.eventHandlers = createEventHandlers(this, template.v);\n  \t}\n\n  \t// create decorator\n  \tif (template.o) {\n  \t\tthis.decorator = new _Decorator(this, template.o);\n  \t}\n\n  \t// create transitions\n  \tthis.intro = template.t0 || template.t1;\n  \tthis.outro = template.t0 || template.t2;\n  }\n\n  var Element_prototype_rebind = Element$rebind;\n  function Element$rebind(oldKeypath, newKeypath) {\n  \tvar i, storage, liveQueries, ractive;\n\n  \tif (this.attributes) {\n  \t\tthis.attributes.forEach(rebind);\n  \t}\n\n  \tif (this.conditionalAttributes) {\n  \t\tthis.conditionalAttributes.forEach(rebind);\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(rebind);\n  \t}\n\n  \tif (this.decorator) {\n  \t\trebind(this.decorator);\n  \t}\n\n  \t// rebind children\n  \tif (this.fragment) {\n  \t\trebind(this.fragment);\n  \t}\n\n  \t// Update live queries, if necessary\n  \tif (liveQueries = this.liveQueries) {\n  \t\tractive = this.root;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tliveQueries[i]._makeDirty();\n  \t\t}\n  \t}\n\n  \tif (this.node && (storage = this.node._ractive)) {\n\n  \t\t// adjust keypath if needed\n  \t\tassignNewKeypath(storage, \"keypath\", oldKeypath, newKeypath);\n  \t}\n\n  \tfunction rebind(thing) {\n  \t\tthing.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  function special_img__render(img) {\n  \tvar loadHandler;\n\n  \t// if this is an <img>, and we're in a crap browser, we may need to prevent it\n  \t// from overriding width and height when it loads the src\n  \tif (img.attributes.width || img.attributes.height) {\n  \t\timg.node.addEventListener(\"load\", loadHandler = function () {\n  \t\t\tvar width = img.getAttribute(\"width\"),\n  \t\t\t    height = img.getAttribute(\"height\");\n\n  \t\t\tif (width !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"width\", width);\n  \t\t\t}\n\n  \t\t\tif (height !== undefined) {\n  \t\t\t\timg.node.setAttribute(\"height\", height);\n  \t\t\t}\n\n  \t\t\timg.node.removeEventListener(\"load\", loadHandler, false);\n  \t\t}, false);\n  \t}\n  }\n\n  function form__render(element) {\n  \telement.node.addEventListener(\"reset\", handleReset, false);\n  }\n\n  function form__unrender(element) {\n  \telement.node.removeEventListener(\"reset\", handleReset, false);\n  }\n\n  function handleReset() {\n  \tvar element = this._ractive.proxy;\n\n  \tglobal_runloop.start();\n  \telement.formBindings.forEach(updateModel);\n  \tglobal_runloop.end();\n  }\n\n  function updateModel(binding) {\n  \tbinding.root.viewmodel.set(binding.keypath, binding.resetValue);\n  }\n\n  var Transition_prototype_init = Transition$init;\n  function Transition$init(element, template, isIntro) {\n  \tvar ractive, name, fragment;\n\n  \tthis.element = element;\n  \tthis.root = ractive = element.root;\n  \tthis.isIntro = isIntro;\n\n  \tname = template.n || template;\n\n  \tif (typeof name !== \"string\") {\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: name,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tname = fragment.toString();\n  \t\tfragment.unbind();\n\n  \t\tif (name === \"\") {\n  \t\t\t// empty string okay, just no transition\n  \t\t\treturn;\n  \t\t}\n  \t}\n\n  \tthis.name = name;\n\n  \tif (template.a) {\n  \t\tthis.params = template.a;\n  \t} else if (template.d) {\n  \t\t// TODO is there a way to interpret dynamic arguments without all the\n  \t\t// 'dependency thrashing'?\n  \t\tfragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template.d,\n  \t\t\troot: ractive,\n  \t\t\towner: element\n  \t\t});\n\n  \t\tthis.params = fragment.getArgsList();\n  \t\tfragment.unbind();\n  \t}\n\n  \tthis._fn = findInViewHierarchy(\"transitions\", ractive, name);\n\n  \tif (!this._fn) {\n  \t\twarnOnceIfDebug(missingPlugin(name, \"transition\"), { ractive: this.root });\n  \t}\n  }\n\n  var camelCase = function (hyphenatedStr) {\n  \treturn hyphenatedStr.replace(/-([a-zA-Z])/g, function (match, $1) {\n  \t\treturn $1.toUpperCase();\n  \t});\n  };\n\n  var helpers_prefix__prefix, prefixCache, helpers_prefix__testStyle;\n\n  if (!isClient) {\n  \thelpers_prefix__prefix = null;\n  } else {\n  \tprefixCache = {};\n  \thelpers_prefix__testStyle = createElement(\"div\").style;\n\n  \thelpers_prefix__prefix = function (prop) {\n  \t\tvar i, vendor, capped;\n\n  \t\tprop = camelCase(prop);\n\n  \t\tif (!prefixCache[prop]) {\n  \t\t\tif (helpers_prefix__testStyle[prop] !== undefined) {\n  \t\t\t\tprefixCache[prop] = prop;\n  \t\t\t} else {\n  \t\t\t\t// test vendors...\n  \t\t\t\tcapped = prop.charAt(0).toUpperCase() + prop.substring(1);\n\n  \t\t\t\ti = vendors.length;\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tvendor = vendors[i];\n  \t\t\t\t\tif (helpers_prefix__testStyle[vendor + capped] !== undefined) {\n  \t\t\t\t\t\tprefixCache[prop] = vendor + capped;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn prefixCache[prop];\n  \t};\n  }\n\n  var helpers_prefix = helpers_prefix__prefix;\n\n  var getStyle, prototype_getStyle__getComputedStyle;\n\n  if (!isClient) {\n  \tgetStyle = null;\n  } else {\n  \tprototype_getStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tgetStyle = function (props) {\n  \t\tvar computedStyle, styles, i, prop, value;\n\n  \t\tcomputedStyle = prototype_getStyle__getComputedStyle(this.node);\n\n  \t\tif (typeof props === \"string\") {\n  \t\t\tvalue = computedStyle[helpers_prefix(props)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\treturn value;\n  \t\t}\n\n  \t\tif (!isArray(props)) {\n  \t\t\tthrow new Error(\"Transition$getStyle must be passed a string, or an array of strings representing CSS properties\");\n  \t\t}\n\n  \t\tstyles = {};\n\n  \t\ti = props.length;\n  \t\twhile (i--) {\n  \t\t\tprop = props[i];\n  \t\t\tvalue = computedStyle[helpers_prefix(prop)];\n  \t\t\tif (value === \"0px\") {\n  \t\t\t\tvalue = 0;\n  \t\t\t}\n  \t\t\tstyles[prop] = value;\n  \t\t}\n\n  \t\treturn styles;\n  \t};\n  }\n\n  var prototype_getStyle = getStyle;\n\n  var setStyle = function (style, value) {\n  \tvar prop;\n\n  \tif (typeof style === \"string\") {\n  \t\tthis.node.style[helpers_prefix(style)] = value;\n  \t} else {\n  \t\tfor (prop in style) {\n  \t\t\tif (style.hasOwnProperty(prop)) {\n  \t\t\t\tthis.node.style[helpers_prefix(prop)] = style[prop];\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \treturn this;\n  };\n\n  var Ticker = function (options) {\n  \tvar easing;\n\n  \tthis.duration = options.duration;\n  \tthis.step = options.step;\n  \tthis.complete = options.complete;\n\n  \t// easing\n  \tif (typeof options.easing === \"string\") {\n  \t\teasing = options.root.easing[options.easing];\n\n  \t\tif (!easing) {\n  \t\t\twarnOnceIfDebug(missingPlugin(options.easing, \"easing\"));\n  \t\t\teasing = linear;\n  \t\t}\n  \t} else if (typeof options.easing === \"function\") {\n  \t\teasing = options.easing;\n  \t} else {\n  \t\teasing = linear;\n  \t}\n\n  \tthis.easing = easing;\n\n  \tthis.start = utils_getTime();\n  \tthis.end = this.start + this.duration;\n\n  \tthis.running = true;\n  \tshared_animations.add(this);\n  };\n\n  Ticker.prototype = {\n  \ttick: function (now) {\n  \t\tvar elapsed, eased;\n\n  \t\tif (!this.running) {\n  \t\t\treturn false;\n  \t\t}\n\n  \t\tif (now > this.end) {\n  \t\t\tif (this.step) {\n  \t\t\t\tthis.step(1);\n  \t\t\t}\n\n  \t\t\tif (this.complete) {\n  \t\t\t\tthis.complete(1);\n  \t\t\t}\n\n  \t\t\treturn false;\n  \t\t}\n\n  \t\telapsed = now - this.start;\n  \t\teased = this.easing(elapsed / this.duration);\n\n  \t\tif (this.step) {\n  \t\t\tthis.step(eased);\n  \t\t}\n\n  \t\treturn true;\n  \t},\n\n  \tstop: function () {\n  \t\tif (this.abort) {\n  \t\t\tthis.abort();\n  \t\t}\n\n  \t\tthis.running = false;\n  \t}\n  };\n\n  var shared_Ticker = Ticker;\n  function linear(t) {\n  \treturn t;\n  }\n\n  var unprefixPattern = new RegExp(\"^-(?:\" + vendors.join(\"|\") + \")-\");\n\n  var unprefix = function (prop) {\n  \treturn prop.replace(unprefixPattern, \"\");\n  };\n\n  var vendorPattern = new RegExp(\"^(?:\" + vendors.join(\"|\") + \")([A-Z])\");\n\n  var hyphenate = function (str) {\n  \tvar hyphenated;\n\n  \tif (!str) {\n  \t\treturn \"\"; // edge case\n  \t}\n\n  \tif (vendorPattern.test(str)) {\n  \t\tstr = \"-\" + str;\n  \t}\n\n  \thyphenated = str.replace(/[A-Z]/g, function (match) {\n  \t\treturn \"-\" + match.toLowerCase();\n  \t});\n\n  \treturn hyphenated;\n  };\n\n  var createTransitions,\n      animateStyle_createTransitions__testStyle,\n      TRANSITION,\n      TRANSITIONEND,\n      CSS_TRANSITIONS_ENABLED,\n      TRANSITION_DURATION,\n      TRANSITION_PROPERTY,\n      TRANSITION_TIMING_FUNCTION,\n      canUseCssTransitions = {},\n      cannotUseCssTransitions = {};\n\n  if (!isClient) {\n  \tcreateTransitions = null;\n  } else {\n  \tanimateStyle_createTransitions__testStyle = createElement(\"div\").style;\n\n  \t// determine some facts about our environment\n  \t(function () {\n  \t\tif (animateStyle_createTransitions__testStyle.transition !== undefined) {\n  \t\t\tTRANSITION = \"transition\";\n  \t\t\tTRANSITIONEND = \"transitionend\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else if (animateStyle_createTransitions__testStyle.webkitTransition !== undefined) {\n  \t\t\tTRANSITION = \"webkitTransition\";\n  \t\t\tTRANSITIONEND = \"webkitTransitionEnd\";\n  \t\t\tCSS_TRANSITIONS_ENABLED = true;\n  \t\t} else {\n  \t\t\tCSS_TRANSITIONS_ENABLED = false;\n  \t\t}\n  \t})();\n\n  \tif (TRANSITION) {\n  \t\tTRANSITION_DURATION = TRANSITION + \"Duration\";\n  \t\tTRANSITION_PROPERTY = TRANSITION + \"Property\";\n  \t\tTRANSITION_TIMING_FUNCTION = TRANSITION + \"TimingFunction\";\n  \t}\n\n  \tcreateTransitions = function (t, to, options, changedProperties, resolve) {\n\n  \t\t// Wait a beat (otherwise the target styles will be applied immediately)\n  \t\t// TODO use a fastdom-style mechanism?\n  \t\tsetTimeout(function () {\n\n  \t\t\tvar hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;\n\n  \t\t\tcheckComplete = function () {\n  \t\t\t\tif (jsTransitionsComplete && cssTransitionsComplete) {\n  \t\t\t\t\t// will changes to events and fire have an unexpected consequence here?\n  \t\t\t\t\tt.root.fire(t.name + \":end\", t.node, t.isIntro);\n  \t\t\t\t\tresolve();\n  \t\t\t\t}\n  \t\t\t};\n\n  \t\t\t// this is used to keep track of which elements can use CSS to animate\n  \t\t\t// which properties\n  \t\t\thashPrefix = (t.node.namespaceURI || \"\") + t.node.tagName;\n\n  \t\t\tt.node.style[TRANSITION_PROPERTY] = changedProperties.map(helpers_prefix).map(hyphenate).join(\",\");\n  \t\t\tt.node.style[TRANSITION_TIMING_FUNCTION] = hyphenate(options.easing || \"linear\");\n  \t\t\tt.node.style[TRANSITION_DURATION] = options.duration / 1000 + \"s\";\n\n  \t\t\ttransitionEndHandler = function (event) {\n  \t\t\t\tvar index;\n\n  \t\t\t\tindex = changedProperties.indexOf(camelCase(unprefix(event.propertyName)));\n  \t\t\t\tif (index !== -1) {\n  \t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t}\n\n  \t\t\t\tif (changedProperties.length) {\n  \t\t\t\t\t// still transitioning...\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n\n  \t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\tcheckComplete();\n  \t\t\t};\n\n  \t\t\tt.node.addEventListener(TRANSITIONEND, transitionEndHandler, false);\n\n  \t\t\tsetTimeout(function () {\n  \t\t\t\tvar i = changedProperties.length,\n  \t\t\t\t    hash,\n  \t\t\t\t    originalValue,\n  \t\t\t\t    index,\n  \t\t\t\t    propertiesToTransitionInJs = [],\n  \t\t\t\t    prop,\n  \t\t\t\t    suffix;\n\n  \t\t\t\twhile (i--) {\n  \t\t\t\t\tprop = changedProperties[i];\n  \t\t\t\t\thash = hashPrefix + prop;\n\n  \t\t\t\t\tif (CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = to[prop];\n\n  \t\t\t\t\t\t// If we're not sure if CSS transitions are supported for\n  \t\t\t\t\t\t// this tag/property combo, find out now\n  \t\t\t\t\t\tif (!canUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n\n  \t\t\t\t\t\t\t// if this property is transitionable in this browser,\n  \t\t\t\t\t\t\t// the current style will be different from the target style\n  \t\t\t\t\t\t\tcanUseCssTransitions[hash] = t.getStyle(prop) != to[prop];\n  \t\t\t\t\t\t\tcannotUseCssTransitions[hash] = !canUseCssTransitions[hash];\n\n  \t\t\t\t\t\t\t// Reset, if we're going to use timers after all\n  \t\t\t\t\t\t\tif (cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t\t\tt.node.style[helpers_prefix(prop)] = originalValue;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tif (!CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[hash]) {\n  \t\t\t\t\t\t// we need to fall back to timer-based stuff\n  \t\t\t\t\t\tif (originalValue === undefined) {\n  \t\t\t\t\t\t\toriginalValue = t.getStyle(prop);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// need to remove this from changedProperties, otherwise transitionEndHandler\n  \t\t\t\t\t\t// will get confused\n  \t\t\t\t\t\tindex = changedProperties.indexOf(prop);\n  \t\t\t\t\t\tif (index === -1) {\n  \t\t\t\t\t\t\twarnIfDebug(\"Something very strange happened with transitions. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\", { node: t.node });\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tchangedProperties.splice(index, 1);\n  \t\t\t\t\t\t}\n\n  \t\t\t\t\t\t// TODO Determine whether this property is animatable at all\n\n  \t\t\t\t\t\tsuffix = /[^\\d]*$/.exec(to[prop])[0];\n\n  \t\t\t\t\t\t// ...then kick off a timer-based transition\n  \t\t\t\t\t\tpropertiesToTransitionInJs.push({\n  \t\t\t\t\t\t\tname: helpers_prefix(prop),\n  \t\t\t\t\t\t\tinterpolator: shared_interpolate(parseFloat(originalValue), parseFloat(to[prop])),\n  \t\t\t\t\t\t\tsuffix: suffix\n  \t\t\t\t\t\t});\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// javascript transitions\n  \t\t\t\tif (propertiesToTransitionInJs.length) {\n  \t\t\t\t\tnew shared_Ticker({\n  \t\t\t\t\t\troot: t.root,\n  \t\t\t\t\t\tduration: options.duration,\n  \t\t\t\t\t\teasing: camelCase(options.easing || \"\"),\n  \t\t\t\t\t\tstep: function (pos) {\n  \t\t\t\t\t\t\tvar prop, i;\n\n  \t\t\t\t\t\t\ti = propertiesToTransitionInJs.length;\n  \t\t\t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\t\t\tprop = propertiesToTransitionInJs[i];\n  \t\t\t\t\t\t\t\tt.node.style[prop.name] = prop.interpolator(pos) + prop.suffix;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t},\n  \t\t\t\t\t\tcomplete: function () {\n  \t\t\t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t\t\t\tcheckComplete();\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tjsTransitionsComplete = true;\n  \t\t\t\t}\n\n  \t\t\t\tif (!changedProperties.length) {\n  \t\t\t\t\t// We need to cancel the transitionEndHandler, and deal with\n  \t\t\t\t\t// the fact that it will never fire\n  \t\t\t\t\tt.node.removeEventListener(TRANSITIONEND, transitionEndHandler, false);\n  \t\t\t\t\tcssTransitionsComplete = true;\n  \t\t\t\t\tcheckComplete();\n  \t\t\t\t}\n  \t\t\t}, 0);\n  \t\t}, options.delay || 0);\n  \t};\n  }\n\n  var animateStyle_createTransitions = createTransitions;\n\n  var hidden, vendor, animateStyle_visibility__prefix, animateStyle_visibility__i, visibility;\n\n  if (typeof document !== \"undefined\") {\n  \thidden = \"hidden\";\n\n  \tvisibility = {};\n\n  \tif (hidden in document) {\n  \t\tanimateStyle_visibility__prefix = \"\";\n  \t} else {\n  \t\tanimateStyle_visibility__i = vendors.length;\n  \t\twhile (animateStyle_visibility__i--) {\n  \t\t\tvendor = vendors[animateStyle_visibility__i];\n  \t\t\thidden = vendor + \"Hidden\";\n\n  \t\t\tif (hidden in document) {\n  \t\t\t\tanimateStyle_visibility__prefix = vendor;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tif (animateStyle_visibility__prefix !== undefined) {\n  \t\tdocument.addEventListener(animateStyle_visibility__prefix + \"visibilitychange\", onChange);\n\n  \t\t// initialise\n  \t\tonChange();\n  \t} else {\n  \t\t// gah, we're in an old browser\n  \t\tif (\"onfocusout\" in document) {\n  \t\t\tdocument.addEventListener(\"focusout\", onHide);\n  \t\t\tdocument.addEventListener(\"focusin\", onShow);\n  \t\t} else {\n  \t\t\twindow.addEventListener(\"pagehide\", onHide);\n  \t\t\twindow.addEventListener(\"blur\", onHide);\n\n  \t\t\twindow.addEventListener(\"pageshow\", onShow);\n  \t\t\twindow.addEventListener(\"focus\", onShow);\n  \t\t}\n\n  \t\tvisibility.hidden = false; // until proven otherwise. Not ideal but hey\n  \t}\n  }\n\n  function onChange() {\n  \tvisibility.hidden = document[hidden];\n  }\n\n  function onHide() {\n  \tvisibility.hidden = true;\n  }\n\n  function onShow() {\n  \tvisibility.hidden = false;\n  }\n\n  var animateStyle_visibility = visibility;\n\n  var animateStyle, _animateStyle__getComputedStyle, resolved;\n\n  if (!isClient) {\n  \tanimateStyle = null;\n  } else {\n  \t_animateStyle__getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;\n\n  \tanimateStyle = function (style, value, options) {\n  \t\tvar _this = this;\n\n  \t\tvar to;\n\n  \t\tif (arguments.length === 4) {\n  \t\t\tthrow new Error(\"t.animateStyle() returns a promise - use .then() instead of passing a callback\");\n  \t\t}\n\n  \t\t// Special case - page isn't visible. Don't animate anything, because\n  \t\t// that way you'll never get CSS transitionend events\n  \t\tif (animateStyle_visibility.hidden) {\n  \t\t\tthis.setStyle(style, value);\n  \t\t\treturn resolved || (resolved = utils_Promise.resolve());\n  \t\t}\n\n  \t\tif (typeof style === \"string\") {\n  \t\t\tto = {};\n  \t\t\tto[style] = value;\n  \t\t} else {\n  \t\t\tto = style;\n\n  \t\t\t// shuffle arguments\n  \t\t\toptions = value;\n  \t\t}\n\n  \t\t// As of 0.3.9, transition authors should supply an `option` object with\n  \t\t// `duration` and `easing` properties (and optional `delay`), plus a\n  \t\t// callback function that gets called after the animation completes\n\n  \t\t// TODO remove this check in a future version\n  \t\tif (!options) {\n  \t\t\twarnOnceIfDebug(\"The \\\"%s\\\" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340\", this.name);\n  \t\t\toptions = this;\n  \t\t}\n\n  \t\tvar promise = new utils_Promise(function (resolve) {\n  \t\t\tvar propertyNames, changedProperties, computedStyle, current, from, i, prop;\n\n  \t\t\t// Edge case - if duration is zero, set style synchronously and complete\n  \t\t\tif (!options.duration) {\n  \t\t\t\t_this.setStyle(to);\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\t// Get a list of the properties we're animating\n  \t\t\tpropertyNames = Object.keys(to);\n  \t\t\tchangedProperties = [];\n\n  \t\t\t// Store the current styles\n  \t\t\tcomputedStyle = _animateStyle__getComputedStyle(_this.node);\n\n  \t\t\tfrom = {};\n  \t\t\ti = propertyNames.length;\n  \t\t\twhile (i--) {\n  \t\t\t\tprop = propertyNames[i];\n  \t\t\t\tcurrent = computedStyle[helpers_prefix(prop)];\n\n  \t\t\t\tif (current === \"0px\") {\n  \t\t\t\t\tcurrent = 0;\n  \t\t\t\t}\n\n  \t\t\t\t// we need to know if we're actually changing anything\n  \t\t\t\tif (current != to[prop]) {\n  \t\t\t\t\t// use != instead of !==, so we can compare strings with numbers\n  \t\t\t\t\tchangedProperties.push(prop);\n\n  \t\t\t\t\t// make the computed style explicit, so we can animate where\n  \t\t\t\t\t// e.g. height='auto'\n  \t\t\t\t\t_this.node.style[helpers_prefix(prop)] = current;\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\t// If we're not actually changing anything, the transitionend event\n  \t\t\t// will never fire! So we complete early\n  \t\t\tif (!changedProperties.length) {\n  \t\t\t\tresolve();\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tanimateStyle_createTransitions(_this, to, options, changedProperties, resolve);\n  \t\t});\n\n  \t\treturn promise;\n  \t};\n  }\n\n  var _animateStyle = animateStyle;\n\n  var processParams = function (params, defaults) {\n  \tif (typeof params === \"number\") {\n  \t\tparams = { duration: params };\n  \t} else if (typeof params === \"string\") {\n  \t\tif (params === \"slow\") {\n  \t\t\tparams = { duration: 600 };\n  \t\t} else if (params === \"fast\") {\n  \t\t\tparams = { duration: 200 };\n  \t\t} else {\n  \t\t\tparams = { duration: 400 };\n  \t\t}\n  \t} else if (!params) {\n  \t\tparams = {};\n  \t}\n\n  \treturn fillGaps({}, params, defaults);\n  };\n\n  var prototype_start = Transition$start;\n\n  function Transition$start() {\n  \tvar _this = this;\n\n  \tvar node, originalStyle, completed;\n\n  \tnode = this.node = this.element.node;\n  \toriginalStyle = node.getAttribute(\"style\");\n\n  \t// create t.complete() - we don't want this on the prototype,\n  \t// because we don't want `this` silliness when passing it as\n  \t// an argument\n  \tthis.complete = function (noReset) {\n  \t\tif (completed) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!noReset && _this.isIntro) {\n  \t\t\tresetStyle(node, originalStyle);\n  \t\t}\n\n  \t\tnode._ractive.transition = null;\n  \t\t_this._manager.remove(_this);\n\n  \t\tcompleted = true;\n  \t};\n\n  \t// If the transition function doesn't exist, abort\n  \tif (!this._fn) {\n  \t\tthis.complete();\n  \t\treturn;\n  \t}\n\n  \tthis._fn.apply(this.root, [this].concat(this.params));\n  }\n\n  function resetStyle(node, style) {\n  \tif (style) {\n  \t\tnode.setAttribute(\"style\", style);\n  \t} else {\n\n  \t\t// Next line is necessary, to remove empty style attribute!\n  \t\t// See http://stackoverflow.com/a/7167553\n  \t\tnode.getAttribute(\"style\");\n  \t\tnode.removeAttribute(\"style\");\n  \t}\n  }\n\n  var Transition = function (owner, template, isIntro) {\n  \tthis.init(owner, template, isIntro);\n  };\n\n  Transition.prototype = {\n  \tinit: Transition_prototype_init,\n  \tstart: prototype_start,\n  \tgetStyle: prototype_getStyle,\n  \tsetStyle: setStyle,\n  \tanimateStyle: _animateStyle,\n  \tprocessParams: processParams\n  };\n\n  var _Transition = Transition;\n\n  var Element_prototype_render = Element$render;\n\n  var updateCss, updateScript;\n\n  updateCss = function () {\n  \tvar node = this.node,\n  \t    content = this.fragment.toString(false);\n\n  \t// IE8 has no styleSheet unless there's a type text/css\n  \tif (window && window.appearsToBeIELessEqual8) {\n  \t\tnode.type = \"text/css\";\n  \t}\n\n  \tif (node.styleSheet) {\n  \t\tnode.styleSheet.cssText = content;\n  \t} else {\n\n  \t\twhile (node.hasChildNodes()) {\n  \t\t\tnode.removeChild(node.firstChild);\n  \t\t}\n\n  \t\tnode.appendChild(document.createTextNode(content));\n  \t}\n  };\n\n  updateScript = function () {\n  \tif (!this.node.type || this.node.type === \"text/javascript\") {\n  \t\twarnIfDebug(\"Script tag was updated. This does not cause the code to be re-evaluated!\", { ractive: this.root });\n  \t\t// As it happens, we ARE in a position to re-evaluate the code if we wanted\n  \t\t// to - we could eval() it, or insert it into a fresh (temporary) script tag.\n  \t\t// But this would be a terrible idea with unpredictable results, so let's not.\n  \t}\n\n  \tthis.node.text = this.fragment.toString(false);\n  };\n  function Element$render() {\n  \tvar _this = this;\n\n  \tvar root = this.root,\n  \t    namespace,\n  \t    node,\n  \t    transition;\n\n  \tnamespace = getNamespace(this);\n  \tnode = this.node = createElement(this.name, namespace);\n\n  \t// Is this a top-level node of a component? If so, we may need to add\n  \t// a data-ractive-css attribute, for CSS encapsulation\n  \tif (this.parentFragment.cssIds) {\n  \t\tthis.node.setAttribute(\"data-ractive-css\", this.parentFragment.cssIds.map(function (x) {\n  \t\t\treturn \"{\" + x + \"}\";\n  \t\t}).join(\" \"));\n  \t}\n\n  \t// Add _ractive property to the node - we use this object to store stuff\n  \t// related to proxy events, two-way bindings etc\n  \tdefineProperty(this.node, \"_ractive\", {\n  \t\tvalue: {\n  \t\t\tproxy: this,\n  \t\t\tkeypath: getInnerContext(this.parentFragment),\n  \t\t\tevents: create(null),\n  \t\t\troot: root\n  \t\t}\n  \t});\n\n  \t// Render attributes\n  \tthis.attributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n  \tthis.conditionalAttributes.forEach(function (a) {\n  \t\treturn a.render(node);\n  \t});\n\n  \t// Render children\n  \tif (this.fragment) {\n  \t\t// Special case - <script> element\n  \t\tif (this.name === \"script\") {\n  \t\t\tthis.bubble = updateScript;\n  \t\t\tthis.node.text = this.fragment.toString(false); // bypass warning initially\n  \t\t\tthis.fragment.unrender = noop; // TODO this is a kludge\n  \t\t}\n\n  \t\t// Special case - <style> element\n  \t\telse if (this.name === \"style\") {\n  \t\t\tthis.bubble = updateCss;\n  \t\t\tthis.bubble();\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t}\n\n  \t\t// Special case - contenteditable\n  \t\telse if (this.binding && this.getAttribute(\"contenteditable\")) {\n  \t\t\tthis.fragment.unrender = noop;\n  \t\t} else {\n  \t\t\tthis.node.appendChild(this.fragment.render());\n  \t\t}\n  \t}\n\n  \t// deal with two-way bindings\n  \tif (this.binding) {\n  \t\tthis.binding.render();\n  \t\tthis.node._ractive.binding = this.binding;\n  \t}\n\n  \t// Add proxy event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(function (h) {\n  \t\t\treturn h.render();\n  \t\t});\n  \t}\n\n  \tif (this.name === \"option\") {\n  \t\tprocessOption(this);\n  \t}\n\n  \t// Special cases\n  \tif (this.name === \"img\") {\n  \t\t// if this is an <img>, and we're in a crap browser, we may\n  \t\t// need to prevent it from overriding width and height when\n  \t\t// it loads the src\n  \t\tspecial_img__render(this);\n  \t} else if (this.name === \"form\") {\n  \t\t// forms need to keep track of their bindings, in case of reset\n  \t\tform__render(this);\n  \t} else if (this.name === \"input\" || this.name === \"textarea\") {\n  \t\t// inputs and textareas should store their initial value as\n  \t\t// `defaultValue` in case of reset\n  \t\tthis.node.defaultValue = this.node.value;\n  \t} else if (this.name === \"option\") {\n  \t\t// similarly for option nodes\n  \t\tthis.node.defaultSelected = this.node.selected;\n  \t}\n\n  \t// apply decorator(s)\n  \tif (this.decorator && this.decorator.fn) {\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\tif (!_this.decorator.torndown) {\n  \t\t\t\t_this.decorator.init();\n  \t\t\t}\n  \t\t}, true);\n  \t}\n\n  \t// trigger intro transition\n  \tif (root.transitionsEnabled && this.intro) {\n  \t\ttransition = new _Transition(this, this.intro, true);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t}, true);\n\n  \t\tthis.transition = transition;\n  \t}\n\n  \tif (this.node.autofocus) {\n  \t\t// Special case. Some browsers (*cough* Firefix *cough*) have a problem\n  \t\t// with dynamically-generated elements having autofocus, and they won't\n  \t\t// allow you to programmatically focus the element until it's in the DOM\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn _this.node.focus();\n  \t\t}, true);\n  \t}\n\n  \tupdateLiveQueries(this);\n  \treturn this.node;\n  }\n\n  function getNamespace(element) {\n  \tvar namespace, xmlns, parent;\n\n  \t// Use specified namespace...\n  \tif (xmlns = element.getAttribute(\"xmlns\")) {\n  \t\tnamespace = xmlns;\n  \t}\n\n  \t// ...or SVG namespace, if this is an <svg> element\n  \telse if (element.name === \"svg\") {\n  \t\tnamespace = namespaces.svg;\n  \t} else if (parent = element.parent) {\n  \t\t// ...or HTML, if the parent is a <foreignObject>\n  \t\tif (parent.name === \"foreignObject\") {\n  \t\t\tnamespace = namespaces.html;\n  \t\t}\n\n  \t\t// ...or inherit from the parent node\n  \t\telse {\n  \t\t\tnamespace = parent.node.namespaceURI;\n  \t\t}\n  \t} else {\n  \t\tnamespace = element.root.el.namespaceURI;\n  \t}\n\n  \treturn namespace;\n  }\n\n  function processOption(option) {\n  \tvar optionValue, selectValue, i;\n\n  \tif (!option.select) {\n  \t\treturn;\n  \t}\n\n  \tselectValue = option.select.getAttribute(\"value\");\n  \tif (selectValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \toptionValue = option.getAttribute(\"value\");\n\n  \tif (option.select.node.multiple && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (optionValue == selectValue[i]) {\n  \t\t\t\toption.node.selected = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t} else {\n  \t\toption.node.selected = optionValue == selectValue;\n  \t}\n  }\n\n  function updateLiveQueries(element) {\n  \tvar instance, liveQueries, i, selector, query;\n\n  \t// Does this need to be added to any live queries?\n  \tinstance = element.root;\n\n  \tdo {\n  \t\tliveQueries = instance._liveQueries;\n\n  \t\ti = liveQueries.length;\n  \t\twhile (i--) {\n  \t\t\tselector = liveQueries[i];\n  \t\t\tquery = liveQueries[\"_\" + selector];\n\n  \t\t\tif (query._test(element)) {\n  \t\t\t\t// keep register of applicable selectors, for when we teardown\n  \t\t\t\t(element.liveQueries || (element.liveQueries = [])).push(query);\n  \t\t\t}\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Element_prototype_toString = function () {\n  \tvar str, escape;\n\n  \tif (this.template.y) {\n  \t\t// DOCTYPE declaration\n  \t\treturn \"<!DOCTYPE\" + this.template.dd + \">\";\n  \t}\n\n  \tstr = \"<\" + this.template.e;\n\n  \tstr += this.attributes.map(stringifyAttribute).join(\"\") + this.conditionalAttributes.map(stringifyAttribute).join(\"\");\n\n  \t// Special case - selected options\n  \tif (this.name === \"option\" && optionIsSelected(this)) {\n  \t\tstr += \" selected\";\n  \t}\n\n  \t// Special case - two-way radio name bindings\n  \tif (this.name === \"input\" && inputIsCheckedRadio(this)) {\n  \t\tstr += \" checked\";\n  \t}\n\n  \tstr += \">\";\n\n  \t// Special case - textarea\n  \tif (this.name === \"textarea\" && this.getAttribute(\"value\") !== undefined) {\n  \t\tstr += escapeHtml(this.getAttribute(\"value\"));\n  \t}\n\n  \t// Special case - contenteditable\n  \telse if (this.getAttribute(\"contenteditable\") !== undefined) {\n  \t\tstr += this.getAttribute(\"value\") || \"\";\n  \t}\n\n  \tif (this.fragment) {\n  \t\tescape = this.name !== \"script\" && this.name !== \"style\";\n  \t\tstr += this.fragment.toString(escape);\n  \t}\n\n  \t// add a closing tag if this isn't a void element\n  \tif (!voidElementNames.test(this.template.e)) {\n  \t\tstr += \"</\" + this.template.e + \">\";\n  \t}\n\n  \treturn str;\n  };\n\n  function optionIsSelected(element) {\n  \tvar optionValue, selectValue, i;\n\n  \toptionValue = element.getAttribute(\"value\");\n\n  \tif (optionValue === undefined || !element.select) {\n  \t\treturn false;\n  \t}\n\n  \tselectValue = element.select.getAttribute(\"value\");\n\n  \tif (selectValue == optionValue) {\n  \t\treturn true;\n  \t}\n\n  \tif (element.select.getAttribute(\"multiple\") && isArray(selectValue)) {\n  \t\ti = selectValue.length;\n  \t\twhile (i--) {\n  \t\t\tif (selectValue[i] == optionValue) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n\n  function inputIsCheckedRadio(element) {\n  \tvar attributes, typeAttribute, valueAttribute, nameAttribute;\n\n  \tattributes = element.attributes;\n\n  \ttypeAttribute = attributes.type;\n  \tvalueAttribute = attributes.value;\n  \tnameAttribute = attributes.name;\n\n  \tif (!typeAttribute || typeAttribute.value !== \"radio\" || !valueAttribute || !nameAttribute.interpolator) {\n  \t\treturn;\n  \t}\n\n  \tif (valueAttribute.value === nameAttribute.interpolator.value) {\n  \t\treturn true;\n  \t}\n  }\n\n  function stringifyAttribute(attribute) {\n  \tvar str = attribute.toString();\n  \treturn str ? \" \" + str : \"\";\n  }\n\n  var Element_prototype_unbind = Element$unbind;\n  function Element$unbind() {\n  \tif (this.fragment) {\n  \t\tthis.fragment.unbind();\n  \t}\n\n  \tif (this.binding) {\n  \t\tthis.binding.unbind();\n  \t}\n\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unbind);\n  \t}\n\n  \t// Special case - <option>\n  \tif (this.name === \"option\") {\n  \t\tspecial_option__unbind(this);\n  \t}\n\n  \tthis.attributes.forEach(methodCallers__unbind);\n  \tthis.conditionalAttributes.forEach(methodCallers__unbind);\n  }\n\n  var Element_prototype_unrender = Element$unrender;\n\n  function Element$unrender(shouldDestroy) {\n  \tvar binding, bindings, transition;\n\n  \tif (transition = this.transition) {\n  \t\ttransition.complete();\n  \t}\n\n  \t// Detach as soon as we can\n  \tif (this.name === \"option\") {\n  \t\t// <option> elements detach immediately, so that\n  \t\t// their parent <select> element syncs correctly, and\n  \t\t// since option elements can't have transitions anyway\n  \t\tthis.detach();\n  \t} else if (shouldDestroy) {\n  \t\tglobal_runloop.detachWhenReady(this);\n  \t}\n\n  \t// Children first. that way, any transitions on child elements will be\n  \t// handled by the current transitionManager\n  \tif (this.fragment) {\n  \t\tthis.fragment.unrender(false);\n  \t}\n\n  \tif (binding = this.binding) {\n  \t\tthis.binding.unrender();\n\n  \t\tthis.node._ractive.binding = null;\n  \t\tbindings = this.root._twowayBindings[binding.keypath.str];\n  \t\tbindings.splice(bindings.indexOf(binding), 1);\n  \t}\n\n  \t// Remove event handlers\n  \tif (this.eventHandlers) {\n  \t\tthis.eventHandlers.forEach(methodCallers__unrender);\n  \t}\n\n  \tif (this.decorator) {\n  \t\tglobal_runloop.registerDecorator(this.decorator);\n  \t}\n\n  \t// trigger outro transition if necessary\n  \tif (this.root.transitionsEnabled && this.outro) {\n  \t\ttransition = new _Transition(this, this.outro, false);\n  \t\tglobal_runloop.registerTransition(transition);\n  \t\tglobal_runloop.scheduleTask(function () {\n  \t\t\treturn transition.start();\n  \t\t});\n  \t}\n\n  \t// Remove this node from any live queries\n  \tif (this.liveQueries) {\n  \t\tremoveFromLiveQueries(this);\n  \t}\n\n  \tif (this.name === \"form\") {\n  \t\tform__unrender(this);\n  \t}\n  }\n\n  function removeFromLiveQueries(element) {\n  \tvar query, selector, i;\n\n  \ti = element.liveQueries.length;\n  \twhile (i--) {\n  \t\tquery = element.liveQueries[i];\n  \t\tselector = query.selector;\n\n  \t\tquery._remove(element.node);\n  \t}\n  }\n\n  var Element = function (options) {\n  \tthis.init(options);\n  };\n\n  Element.prototype = {\n  \tbubble: Element_prototype_bubble,\n  \tdetach: Element_prototype_detach,\n  \tfind: Element_prototype_find,\n  \tfindAll: Element_prototype_findAll,\n  \tfindAllComponents: Element_prototype_findAllComponents,\n  \tfindComponent: Element_prototype_findComponent,\n  \tfindNextNode: Element_prototype_findNextNode,\n  \tfirstNode: Element_prototype_firstNode,\n  \tgetAttribute: getAttribute,\n  \tinit: Element_prototype_init,\n  \trebind: Element_prototype_rebind,\n  \trender: Element_prototype_render,\n  \ttoString: Element_prototype_toString,\n  \tunbind: Element_prototype_unbind,\n  \tunrender: Element_prototype_unrender\n  };\n\n  var _Element = Element;\n\n  var deIndent__empty = /^\\s*$/,\n      deIndent__leadingWhitespace = /^\\s*/;\n\n  var deIndent = function (str) {\n  \tvar lines, firstLine, lastLine, minIndent;\n\n  \tlines = str.split(\"\\n\");\n\n  \t// remove first and last line, if they only contain whitespace\n  \tfirstLine = lines[0];\n  \tif (firstLine !== undefined && deIndent__empty.test(firstLine)) {\n  \t\tlines.shift();\n  \t}\n\n  \tlastLine = lastItem(lines);\n  \tif (lastLine !== undefined && deIndent__empty.test(lastLine)) {\n  \t\tlines.pop();\n  \t}\n\n  \tminIndent = lines.reduce(reducer, null);\n\n  \tif (minIndent) {\n  \t\tstr = lines.map(function (line) {\n  \t\t\treturn line.replace(minIndent, \"\");\n  \t\t}).join(\"\\n\");\n  \t}\n\n  \treturn str;\n  };\n\n  function reducer(previous, line) {\n  \tvar lineIndent = deIndent__leadingWhitespace.exec(line)[0];\n\n  \tif (previous === null || lineIndent.length < previous.length) {\n  \t\treturn lineIndent;\n  \t}\n\n  \treturn previous;\n  }\n\n  var Partial_getPartialTemplate = getPartialTemplate;\n\n  function getPartialTemplate(ractive, name, parentFragment) {\n  \tvar partial;\n\n  \t// If the partial in instance or view heirarchy instances, great\n  \tif (partial = getPartialFromRegistry(ractive, name, parentFragment || {})) {\n  \t\treturn partial;\n  \t}\n\n  \t// Does it exist on the page as a script tag?\n  \tpartial = template_parser.fromId(name, { noThrow: true });\n\n  \tif (partial) {\n  \t\t// is this necessary?\n  \t\tpartial = deIndent(partial);\n\n  \t\t// parse and register to this ractive instance\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(ractive));\n\n  \t\t// register (and return main partial if there are others in the template)\n  \t\treturn ractive.partials[name] = parsed.t;\n  \t}\n  }\n\n  function getPartialFromRegistry(ractive, name, parentFragment) {\n  \tvar fn = undefined,\n  \t    partial = findParentPartial(name, parentFragment.owner);\n\n  \t// if there was an instance up-hierarchy, cool\n  \tif (partial) return partial;\n\n  \t// find first instance in the ractive or view hierarchy that has this partial\n  \tvar instance = findInstance(\"partials\", ractive, name);\n\n  \tif (!instance) {\n  \t\treturn;\n  \t}\n\n  \tpartial = instance.partials[name];\n\n  \t// partial is a function?\n  \tif (typeof partial === \"function\") {\n  \t\tfn = partial.bind(instance);\n  \t\tfn.isOwner = instance.partials.hasOwnProperty(name);\n  \t\tpartial = fn.call(ractive, template_parser);\n  \t}\n\n  \tif (!partial && partial !== \"\") {\n  \t\twarnIfDebug(noRegistryFunctionReturn, name, \"partial\", \"partial\", { ractive: ractive });\n  \t\treturn;\n  \t}\n\n  \t// If this was added manually to the registry,\n  \t// but hasn't been parsed, parse it now\n  \tif (!template_parser.isParsed(partial)) {\n\n  \t\t// use the parseOptions of the ractive instance on which it was found\n  \t\tvar parsed = template_parser.parse(partial, template_parser.getParseOptions(instance));\n\n  \t\t// Partials cannot contain nested partials!\n  \t\t// TODO add a test for this\n  \t\tif (parsed.p) {\n  \t\t\twarnIfDebug(\"Partials ({{>%s}}) cannot contain nested inline partials\", name, { ractive: ractive });\n  \t\t}\n\n  \t\t// if fn, use instance to store result, otherwise needs to go\n  \t\t// in the correct point in prototype chain on instance or constructor\n  \t\tvar target = fn ? instance : findOwner(instance, name);\n\n  \t\t// may be a template with partials, which need to be registered and main template extracted\n  \t\ttarget.partials[name] = partial = parsed.t;\n  \t}\n\n  \t// store for reset\n  \tif (fn) {\n  \t\tpartial._fn = fn;\n  \t}\n\n  \treturn partial.v ? partial.t : partial;\n  }\n\n  function findOwner(ractive, key) {\n  \treturn ractive.partials.hasOwnProperty(key) ? ractive : findConstructor(ractive.constructor, key);\n  }\n\n  function findConstructor(constructor, key) {\n  \tif (!constructor) {\n  \t\treturn;\n  \t}\n  \treturn constructor.partials.hasOwnProperty(key) ? constructor : findConstructor(constructor._Parent, key);\n  }\n\n  function findParentPartial(name, parent) {\n  \tif (parent) {\n  \t\tif (parent.template && parent.template.p && parent.template.p[name]) {\n  \t\t\treturn parent.template.p[name];\n  \t\t} else if (parent.parentFragment && parent.parentFragment.owner) {\n  \t\t\treturn findParentPartial(name, parent.parentFragment.owner);\n  \t\t}\n  \t}\n  }\n\n  var applyIndent = function (string, indent) {\n  \tvar indented;\n\n  \tif (!indent) {\n  \t\treturn string;\n  \t}\n\n  \tindented = string.split(\"\\n\").map(function (line, notFirstLine) {\n  \t\treturn notFirstLine ? indent + line : line;\n  \t}).join(\"\\n\");\n\n  \treturn indented;\n  };\n\n  var missingPartialMessage = \"Could not find template for partial \\\"%s\\\"\";\n\n  var Partial = function (options) {\n  \tvar parentFragment, template;\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n\n  \tthis.root = parentFragment.root;\n  \tthis.type = PARTIAL;\n  \tthis.index = options.index;\n  \tthis.name = options.template.r;\n  \tthis.rendered = false;\n\n  \tthis.fragment = this.fragmentToRender = this.fragmentToUnrender = null;\n\n  \tMustache.init(this, options);\n\n  \t// If this didn't resolve, it most likely means we have a named partial\n  \t// (i.e. `{{>foo}}` means 'use the foo partial', not 'use the partial\n  \t// whose name is the value of `foo`')\n  \tif (!this.keypath) {\n  \t\tif (template = Partial_getPartialTemplate(this.root, this.name, parentFragment)) {\n  \t\t\tshared_unbind.call(this); // prevent any further changes\n  \t\t\tthis.isNamed = true;\n  \t\t\tthis.setTemplate(template);\n  \t\t} else {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name);\n  \t\t}\n  \t}\n  };\n\n  Partial.prototype = {\n  \tbubble: function () {\n  \t\tthis.parentFragment.bubble();\n  \t},\n\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.parentFragment.findNextNode(this);\n  \t},\n\n  \tgetPartialName: function () {\n  \t\tif (this.isNamed && this.name) return this.name;else if (this.value === undefined) return this.name;else return this.value;\n  \t},\n\n  \tgetValue: function () {\n  \t\treturn this.fragment.getValue();\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\t// named partials aren't bound, so don't rebind\n  \t\tif (!this.isNamed) {\n  \t\t\tMustache_rebind.call(this, oldKeypath, newKeypath);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t},\n\n  \trender: function () {\n  \t\tthis.docFrag = document.createDocumentFragment();\n  \t\tthis.update();\n\n  \t\tthis.rendered = true;\n  \t\treturn this.docFrag;\n  \t},\n\n  \tresolve: Mustache.resolve,\n\n  \tsetValue: function (value) {\n  \t\tvar template;\n\n  \t\tif (value !== undefined && value === this.value) {\n  \t\t\t// nothing has changed, so no work to be done\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (value !== undefined) {\n  \t\t\ttemplate = Partial_getPartialTemplate(this.root, \"\" + value, this.parentFragment);\n  \t\t}\n\n  \t\t// we may be here if we have a partial like `{{>foo}}` and `foo` is the\n  \t\t// name of both a data property (whose value ISN'T the name of a partial)\n  \t\t// and a partial. In those cases, this becomes a named partial\n  \t\tif (!template && this.name && (template = Partial_getPartialTemplate(this.root, this.name, this.parentFragment))) {\n  \t\t\tshared_unbind.call(this);\n  \t\t\tthis.isNamed = true;\n  \t\t}\n\n  \t\tif (!template) {\n  \t\t\twarnOnceIfDebug(missingPartialMessage, this.name, { ractive: this.root });\n  \t\t}\n\n  \t\tthis.value = value;\n\n  \t\tthis.setTemplate(template || []);\n\n  \t\tthis.bubble();\n\n  \t\tif (this.rendered) {\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tsetTemplate: function (template) {\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t\tif (this.rendered) {\n  \t\t\t\tthis.fragmentToUnrender = this.fragment;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: template,\n  \t\t\troot: this.root,\n  \t\t\towner: this,\n  \t\t\tpElement: this.parentFragment.pElement\n  \t\t});\n\n  \t\tthis.fragmentToRender = this.fragment;\n  \t},\n\n  \ttoString: function (toString) {\n  \t\tvar string, previousItem, lastLine, match;\n\n  \t\tstring = this.fragment.toString(toString);\n\n  \t\tpreviousItem = this.parentFragment.items[this.index - 1];\n\n  \t\tif (!previousItem || previousItem.type !== TEXT) {\n  \t\t\treturn string;\n  \t\t}\n\n  \t\tlastLine = previousItem.text.split(\"\\n\").pop();\n\n  \t\tif (match = /^\\s+$/.exec(lastLine)) {\n  \t\t\treturn applyIndent(string, match[0]);\n  \t\t}\n\n  \t\treturn string;\n  \t},\n\n  \tunbind: function () {\n  \t\tif (!this.isNamed) {\n  \t\t\t// dynamic partial - need to unbind self\n  \t\t\tshared_unbind.call(this);\n  \t\t}\n\n  \t\tif (this.fragment) {\n  \t\t\tthis.fragment.unbind();\n  \t\t}\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (this.rendered) {\n  \t\t\tif (this.fragment) {\n  \t\t\t\tthis.fragment.unrender(shouldDestroy);\n  \t\t\t}\n  \t\t\tthis.rendered = false;\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tvar target, anchor;\n\n  \t\tif (this.fragmentToUnrender) {\n  \t\t\tthis.fragmentToUnrender.unrender(true);\n  \t\t\tthis.fragmentToUnrender = null;\n  \t\t}\n\n  \t\tif (this.fragmentToRender) {\n  \t\t\tthis.docFrag.appendChild(this.fragmentToRender.render());\n  \t\t\tthis.fragmentToRender = null;\n  \t\t}\n\n  \t\tif (this.rendered) {\n  \t\t\ttarget = this.parentFragment.getNode();\n  \t\t\tanchor = this.parentFragment.findNextNode(this);\n  \t\t\ttarget.insertBefore(this.docFrag, anchor);\n  \t\t}\n  \t}\n  };\n\n  var _Partial = Partial;\n\n  // finds the component constructor in the registry or view hierarchy registries\n\n  var Component_getComponent = getComponent;\n  function getComponent(ractive, name) {\n\n  \tvar Component,\n  \t    instance = findInstance(\"components\", ractive, name);\n\n  \tif (instance) {\n  \t\tComponent = instance.components[name];\n\n  \t\t// best test we have for not Ractive.extend\n  \t\tif (!Component._Parent) {\n  \t\t\t// function option, execute and store for reset\n  \t\t\tvar fn = Component.bind(instance);\n  \t\t\tfn.isOwner = instance.components.hasOwnProperty(name);\n  \t\t\tComponent = fn();\n\n  \t\t\tif (!Component) {\n  \t\t\t\twarnIfDebug(noRegistryFunctionReturn, name, \"component\", \"component\", { ractive: ractive });\n\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (typeof Component === \"string\") {\n  \t\t\t\t// allow string lookup\n  \t\t\t\tComponent = getComponent(ractive, Component);\n  \t\t\t}\n\n  \t\t\tComponent._fn = fn;\n  \t\t\tinstance.components[name] = Component;\n  \t\t}\n  \t}\n\n  \treturn Component;\n  }\n\n  var Component_prototype_detach = Component$detach;\n  var Component_prototype_detach__detachHook = new hooks_Hook(\"detach\");\n  function Component$detach() {\n  \tvar detached = this.instance.fragment.detach();\n  \tComponent_prototype_detach__detachHook.fire(this.instance);\n  \treturn detached;\n  }\n\n  var Component_prototype_find = Component$find;\n\n  function Component$find(selector) {\n  \treturn this.instance.fragment.find(selector);\n  }\n\n  var Component_prototype_findAll = Component$findAll;\n\n  function Component$findAll(selector, query) {\n  \treturn this.instance.fragment.findAll(selector, query);\n  }\n\n  var Component_prototype_findAllComponents = Component$findAllComponents;\n\n  function Component$findAllComponents(selector, query) {\n  \tquery._test(this, true);\n\n  \tif (this.instance.fragment) {\n  \t\tthis.instance.fragment.findAllComponents(selector, query);\n  \t}\n  }\n\n  var Component_prototype_findComponent = Component$findComponent;\n\n  function Component$findComponent(selector) {\n  \tif (!selector || selector === this.name) {\n  \t\treturn this.instance;\n  \t}\n\n  \tif (this.instance.fragment) {\n  \t\treturn this.instance.fragment.findComponent(selector);\n  \t}\n\n  \treturn null;\n  }\n\n  var Component_prototype_findNextNode = Component$findNextNode;\n\n  function Component$findNextNode() {\n  \treturn this.parentFragment.findNextNode(this);\n  }\n\n  var Component_prototype_firstNode = Component$firstNode;\n\n  function Component$firstNode() {\n  \tif (this.rendered) {\n  \t\treturn this.instance.fragment.firstNode();\n  \t}\n\n  \treturn null;\n  }\n\n  var processWrapper = function (wrapper, array, methodName, newIndices) {\n  \tvar root = wrapper.root;\n  \tvar keypath = wrapper.keypath;\n\n  \tif (!!newIndices) {\n  \t\troot.viewmodel.smartUpdate(keypath, array, newIndices);\n  \t} else {\n  \t\t// If this is a sort or reverse, we just do root.set()...\n  \t\t// TODO use merge logic?\n  \t\troot.viewmodel.mark(keypath);\n  \t}\n  };\n\n  var patchedArrayProto = [],\n      mutatorMethods = [\"pop\", \"push\", \"reverse\", \"shift\", \"sort\", \"splice\", \"unshift\"],\n      testObj,\n      patchArrayMethods,\n      unpatchArrayMethods;\n\n  mutatorMethods.forEach(function (methodName) {\n  \tvar method = function () {\n  \t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\t\targs[_key] = arguments[_key];\n  \t\t}\n\n  \t\tvar newIndices, result, wrapper, i;\n\n  \t\tnewIndices = shared_getNewIndices(this, methodName, args);\n\n  \t\t// apply the underlying method\n  \t\tresult = Array.prototype[methodName].apply(this, arguments);\n\n  \t\t// trigger changes\n  \t\tglobal_runloop.start();\n\n  \t\tthis._ractive.setting = true;\n  \t\ti = this._ractive.wrappers.length;\n  \t\twhile (i--) {\n  \t\t\twrapper = this._ractive.wrappers[i];\n\n  \t\t\tglobal_runloop.addRactive(wrapper.root);\n  \t\t\tprocessWrapper(wrapper, this, methodName, newIndices);\n  \t\t}\n\n  \t\tglobal_runloop.end();\n\n  \t\tthis._ractive.setting = false;\n  \t\treturn result;\n  \t};\n\n  \tdefineProperty(patchedArrayProto, methodName, {\n  \t\tvalue: method\n  \t});\n  });\n\n  // can we use prototype chain injection?\n  // http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection\n  testObj = {};\n\n  if (testObj.__proto__) {\n  \t// yes, we can\n  \tpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = patchedArrayProto;\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tarray.__proto__ = Array.prototype;\n  \t};\n  } else {\n  \t// no, we can't\n  \tpatchArrayMethods = function (array) {\n  \t\tvar i, methodName;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tmethodName = mutatorMethods[i];\n  \t\t\tdefineProperty(array, methodName, {\n  \t\t\t\tvalue: patchedArrayProto[methodName],\n  \t\t\t\tconfigurable: true\n  \t\t\t});\n  \t\t}\n  \t};\n\n  \tunpatchArrayMethods = function (array) {\n  \t\tvar i;\n\n  \t\ti = mutatorMethods.length;\n  \t\twhile (i--) {\n  \t\t\tdelete array[mutatorMethods[i]];\n  \t\t}\n  \t};\n  }\n\n  patchArrayMethods.unpatch = unpatchArrayMethods;\n  var patch = patchArrayMethods;\n\n  var arrayAdaptor,\n\n  // helpers\n  ArrayWrapper, array_index__errorMessage;\n\n  arrayAdaptor = {\n  \tfilter: function (object) {\n  \t\t// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,\n  \t\t// or the array didn't trigger the get() itself\n  \t\treturn isArray(object) && (!object._ractive || !object._ractive.setting);\n  \t},\n  \twrap: function (ractive, array, keypath) {\n  \t\treturn new ArrayWrapper(ractive, array, keypath);\n  \t}\n  };\n\n  ArrayWrapper = function (ractive, array, keypath) {\n  \tthis.root = ractive;\n  \tthis.value = array;\n  \tthis.keypath = getKeypath(keypath);\n\n  \t// if this array hasn't already been ractified, ractify it\n  \tif (!array._ractive) {\n\n  \t\t// define a non-enumerable _ractive property to store the wrappers\n  \t\tdefineProperty(array, \"_ractive\", {\n  \t\t\tvalue: {\n  \t\t\t\twrappers: [],\n  \t\t\t\tinstances: [],\n  \t\t\t\tsetting: false\n  \t\t\t},\n  \t\t\tconfigurable: true\n  \t\t});\n\n  \t\tpatch(array);\n  \t}\n\n  \t// store the ractive instance, so we can handle transitions later\n  \tif (!array._ractive.instances[ractive._guid]) {\n  \t\tarray._ractive.instances[ractive._guid] = 0;\n  \t\tarray._ractive.instances.push(ractive);\n  \t}\n\n  \tarray._ractive.instances[ractive._guid] += 1;\n  \tarray._ractive.wrappers.push(this);\n  };\n\n  ArrayWrapper.prototype = {\n  \tget: function () {\n  \t\treturn this.value;\n  \t},\n  \tteardown: function () {\n  \t\tvar array, storage, wrappers, instances, index;\n\n  \t\tarray = this.value;\n  \t\tstorage = array._ractive;\n  \t\twrappers = storage.wrappers;\n  \t\tinstances = storage.instances;\n\n  \t\t// if teardown() was invoked because we're clearing the cache as a result of\n  \t\t// a change that the array itself triggered, we can save ourselves the teardown\n  \t\t// and immediate setup\n  \t\tif (storage.setting) {\n  \t\t\treturn false; // so that we don't remove it from this.root.viewmodel.wrapped\n  \t\t}\n\n  \t\tindex = wrappers.indexOf(this);\n  \t\tif (index === -1) {\n  \t\t\tthrow new Error(array_index__errorMessage);\n  \t\t}\n\n  \t\twrappers.splice(index, 1);\n\n  \t\t// if nothing else depends on this array, we can revert it to its\n  \t\t// natural state\n  \t\tif (!wrappers.length) {\n  \t\t\tdelete array._ractive;\n  \t\t\tpatch.unpatch(this.value);\n  \t\t} else {\n  \t\t\t// remove ractive instance if possible\n  \t\t\tinstances[this.root._guid] -= 1;\n  \t\t\tif (!instances[this.root._guid]) {\n  \t\t\t\tindex = instances.indexOf(this.root);\n\n  \t\t\t\tif (index === -1) {\n  \t\t\t\t\tthrow new Error(array_index__errorMessage);\n  \t\t\t\t}\n\n  \t\t\t\tinstances.splice(index, 1);\n  \t\t\t}\n  \t\t}\n  \t}\n  };\n\n  array_index__errorMessage = \"Something went wrong in a rather interesting way\";\n  var array_index = arrayAdaptor;\n\n  var numeric = /^\\s*[0-9]+\\s*$/;\n\n  var createBranch = function (key) {\n  \treturn numeric.test(key) ? [] : {};\n  };\n\n  var magicAdaptor, MagicWrapper;\n\n  try {\n  \tObject.defineProperty({}, \"test\", { value: 0 });\n\n  \tmagicAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\tvar parentWrapper, parentValue;\n\n  \t\t\tif (!keypath) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tkeypath = getKeypath(keypath);\n\n  \t\t\t// If the parent value is a wrapper, other than a magic wrapper,\n  \t\t\t// we shouldn't wrap this property\n  \t\t\tif ((parentWrapper = ractive.viewmodel.wrapped[keypath.parent.str]) && !parentWrapper.magic) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\tparentValue = ractive.viewmodel.get(keypath.parent);\n\n  \t\t\t// if parentValue is an array that doesn't include this member,\n  \t\t\t// we should return false otherwise lengths will get messed up\n  \t\t\tif (isArray(parentValue) && /^[0-9]+$/.test(keypath.lastKey)) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\treturn parentValue && (typeof parentValue === \"object\" || typeof parentValue === \"function\");\n  \t\t},\n  \t\twrap: function (ractive, property, keypath) {\n  \t\t\treturn new MagicWrapper(ractive, property, keypath);\n  \t\t}\n  \t};\n\n  \tMagicWrapper = function (ractive, value, keypath) {\n  \t\tvar objKeypath, template, siblings;\n\n  \t\tkeypath = getKeypath(keypath);\n\n  \t\tthis.magic = true;\n\n  \t\tthis.ractive = ractive;\n  \t\tthis.keypath = keypath;\n  \t\tthis.value = value;\n\n  \t\tthis.prop = keypath.lastKey;\n\n  \t\tobjKeypath = keypath.parent;\n  \t\tthis.obj = objKeypath.isRoot ? ractive.viewmodel.data : ractive.viewmodel.get(objKeypath);\n\n  \t\ttemplate = this.originalDescriptor = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n\n  \t\t// Has this property already been wrapped?\n  \t\tif (template && template.set && (siblings = template.set._ractiveWrappers)) {\n\n  \t\t\t// Yes. Register this wrapper to this property, if it hasn't been already\n  \t\t\tif (siblings.indexOf(this) === -1) {\n  \t\t\t\tsiblings.push(this);\n  \t\t\t}\n\n  \t\t\treturn; // already wrapped\n  \t\t}\n\n  \t\t// No, it hasn't been wrapped\n  \t\tcreateAccessors(this, value, template);\n  \t};\n\n  \tMagicWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tthis.updating = true;\n  \t\t\tthis.obj[this.prop] = value; // trigger set() accessor\n  \t\t\tglobal_runloop.addRactive(this.ractive);\n  \t\t\tthis.ractive.viewmodel.mark(this.keypath, { keepExistingWrapper: true });\n  \t\t\tthis.updating = false;\n  \t\t\treturn true;\n  \t\t},\n  \t\tset: function (key, value) {\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tif (!this.obj[this.prop]) {\n  \t\t\t\tthis.updating = true;\n  \t\t\t\tthis.obj[this.prop] = createBranch(key);\n  \t\t\t\tthis.updating = false;\n  \t\t\t}\n\n  \t\t\tthis.obj[this.prop][key] = value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tvar template, set, value, wrappers, index;\n\n  \t\t\t// If this method was called because the cache was being cleared as a\n  \t\t\t// result of a set()/update() call made by this wrapper, we return false\n  \t\t\t// so that it doesn't get torn down\n  \t\t\tif (this.updating) {\n  \t\t\t\treturn false;\n  \t\t\t}\n\n  \t\t\ttemplate = Object.getOwnPropertyDescriptor(this.obj, this.prop);\n  \t\t\tset = template && template.set;\n\n  \t\t\tif (!set) {\n  \t\t\t\t// most likely, this was an array member that was spliced out\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\twrappers = set._ractiveWrappers;\n\n  \t\t\tindex = wrappers.indexOf(this);\n  \t\t\tif (index !== -1) {\n  \t\t\t\twrappers.splice(index, 1);\n  \t\t\t}\n\n  \t\t\t// Last one out, turn off the lights\n  \t\t\tif (!wrappers.length) {\n  \t\t\t\tvalue = this.obj[this.prop];\n\n  \t\t\t\tObject.defineProperty(this.obj, this.prop, this.originalDescriptor || {\n  \t\t\t\t\twritable: true,\n  \t\t\t\t\tenumerable: true,\n  \t\t\t\t\tconfigurable: true\n  \t\t\t\t});\n\n  \t\t\t\tthis.obj[this.prop] = value;\n  \t\t\t}\n  \t\t}\n  \t};\n  } catch (err) {\n  \tmagicAdaptor = false; // no magic in this browser\n  }\n\n  var adaptors_magic = magicAdaptor;\n\n  function createAccessors(originalWrapper, value, template) {\n\n  \tvar object, property, oldGet, oldSet, get, set;\n\n  \tobject = originalWrapper.obj;\n  \tproperty = originalWrapper.prop;\n\n  \t// Is this template configurable?\n  \tif (template && !template.configurable) {\n  \t\t// Special case - array length\n  \t\tif (property === \"length\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthrow new Error(\"Cannot use magic mode with property \\\"\" + property + \"\\\" - object is not configurable\");\n  \t}\n\n  \t// Time to wrap this property\n  \tif (template) {\n  \t\toldGet = template.get;\n  \t\toldSet = template.set;\n  \t}\n\n  \tget = oldGet || function () {\n  \t\treturn value;\n  \t};\n\n  \tset = function (v) {\n  \t\tif (oldSet) {\n  \t\t\toldSet(v);\n  \t\t}\n\n  \t\tvalue = oldGet ? oldGet() : v;\n  \t\tset._ractiveWrappers.forEach(updateWrapper);\n  \t};\n\n  \tfunction updateWrapper(wrapper) {\n  \t\tvar keypath, ractive;\n\n  \t\twrapper.value = value;\n\n  \t\tif (wrapper.updating) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tractive = wrapper.ractive;\n  \t\tkeypath = wrapper.keypath;\n\n  \t\twrapper.updating = true;\n  \t\tglobal_runloop.start(ractive);\n\n  \t\tractive.viewmodel.mark(keypath);\n\n  \t\tglobal_runloop.end();\n  \t\twrapper.updating = false;\n  \t}\n\n  \t// Create an array of wrappers, in case other keypaths/ractives depend on this property.\n  \t// Handily, we can store them as a property of the set function. Yay JavaScript.\n  \tset._ractiveWrappers = [originalWrapper];\n  \tObject.defineProperty(object, property, { get: get, set: set, enumerable: true, configurable: true });\n  }\n\n  var magicArrayAdaptor, MagicArrayWrapper;\n\n  if (adaptors_magic) {\n  \tmagicArrayAdaptor = {\n  \t\tfilter: function (object, keypath, ractive) {\n  \t\t\treturn adaptors_magic.filter(object, keypath, ractive) && array_index.filter(object);\n  \t\t},\n\n  \t\twrap: function (ractive, array, keypath) {\n  \t\t\treturn new MagicArrayWrapper(ractive, array, keypath);\n  \t\t}\n  \t};\n\n  \tMagicArrayWrapper = function (ractive, array, keypath) {\n  \t\tthis.value = array;\n\n  \t\tthis.magic = true;\n\n  \t\tthis.magicWrapper = adaptors_magic.wrap(ractive, array, keypath);\n  \t\tthis.arrayWrapper = array_index.wrap(ractive, array, keypath);\n  \t};\n\n  \tMagicArrayWrapper.prototype = {\n  \t\tget: function () {\n  \t\t\treturn this.value;\n  \t\t},\n  \t\tteardown: function () {\n  \t\t\tthis.arrayWrapper.teardown();\n  \t\t\tthis.magicWrapper.teardown();\n  \t\t},\n  \t\treset: function (value) {\n  \t\t\treturn this.magicWrapper.reset(value);\n  \t\t}\n  \t};\n  }\n\n  var magicArray = magicArrayAdaptor;\n\n  var prototype_adapt = Viewmodel$adapt;\n\n  var prefixers = {};\n  function Viewmodel$adapt(keypath, value) {\n  \tvar len, i, adaptor, wrapped;\n\n  \tif (!this.adaptors) return;\n\n  \t// Do we have an adaptor for this value?\n  \tlen = this.adaptors.length;\n  \tfor (i = 0; i < len; i += 1) {\n  \t\tadaptor = this.adaptors[i];\n\n  \t\tif (adaptor.filter(value, keypath, this.ractive)) {\n  \t\t\twrapped = this.wrapped[keypath] = adaptor.wrap(this.ractive, value, keypath, getPrefixer(keypath));\n  \t\t\twrapped.value = value;\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n\n  function prefixKeypath(obj, prefix) {\n  \tvar prefixed = {},\n  \t    key;\n\n  \tif (!prefix) {\n  \t\treturn obj;\n  \t}\n\n  \tprefix += \".\";\n\n  \tfor (key in obj) {\n  \t\tif (obj.hasOwnProperty(key)) {\n  \t\t\tprefixed[prefix + key] = obj[key];\n  \t\t}\n  \t}\n\n  \treturn prefixed;\n  }\n\n  function getPrefixer(rootKeypath) {\n  \tvar rootDot;\n\n  \tif (!prefixers[rootKeypath]) {\n  \t\trootDot = rootKeypath ? rootKeypath + \".\" : \"\";\n\n  \t\tprefixers[rootKeypath] = function (relativeKeypath, value) {\n  \t\t\tvar obj;\n\n  \t\t\tif (typeof relativeKeypath === \"string\") {\n  \t\t\t\tobj = {};\n  \t\t\t\tobj[rootDot + relativeKeypath] = value;\n  \t\t\t\treturn obj;\n  \t\t\t}\n\n  \t\t\tif (typeof relativeKeypath === \"object\") {\n  \t\t\t\t// 'relativeKeypath' is in fact a hash, not a keypath\n  \t\t\t\treturn rootDot ? prefixKeypath(relativeKeypath, rootKeypath) : relativeKeypath;\n  \t\t\t}\n  \t\t};\n  \t}\n\n  \treturn prefixers[rootKeypath];\n  }\n\n  // TEMP\n\n  var helpers_getUpstreamChanges = getUpstreamChanges;\n  function getUpstreamChanges(changes) {\n  \tvar upstreamChanges = [rootKeypath],\n  \t    i,\n  \t    keypath;\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tkeypath = changes[i].parent;\n\n  \t\twhile (keypath && !keypath.isRoot) {\n  \t\t\tif (changes.indexOf(keypath) === -1) {\n  \t\t\t\taddToArray(upstreamChanges, keypath);\n  \t\t\t}\n  \t\t\tkeypath = keypath.parent;\n  \t\t}\n  \t}\n\n  \treturn upstreamChanges;\n  }\n\n  var applyChanges_notifyPatternObservers = notifyPatternObservers;\n\n  function notifyPatternObservers(viewmodel, keypath, onlyDirect) {\n  \tvar potentialWildcardMatches;\n\n  \tupdateMatchingPatternObservers(viewmodel, keypath);\n\n  \tif (onlyDirect) {\n  \t\treturn;\n  \t}\n\n  \tpotentialWildcardMatches = keypath.wildcardMatches();\n  \tpotentialWildcardMatches.forEach(function (upstreamPattern) {\n  \t\tcascade(viewmodel, upstreamPattern, keypath);\n  \t});\n  }\n\n  function cascade(viewmodel, upstreamPattern, keypath) {\n  \tvar group, map, actualChildKeypath;\n\n  \t// TODO should be one or the other\n  \tupstreamPattern = upstreamPattern.str || upstreamPattern;\n\n  \tgroup = viewmodel.depsMap.patternObservers;\n  \tmap = group && group[upstreamPattern];\n\n  \tif (!map) {\n  \t\treturn;\n  \t}\n\n  \tmap.forEach(function (childKeypath) {\n  \t\tactualChildKeypath = keypath.join(childKeypath.lastKey); // 'foo.bar.baz'\n\n  \t\tupdateMatchingPatternObservers(viewmodel, actualChildKeypath);\n  \t\tcascade(viewmodel, childKeypath, actualChildKeypath);\n  \t});\n  }\n\n  function updateMatchingPatternObservers(viewmodel, keypath) {\n  \tviewmodel.patternObservers.forEach(function (observer) {\n  \t\tif (observer.regex.test(keypath.str)) {\n  \t\t\tobserver.update(keypath);\n  \t\t}\n  \t});\n  }\n\n  var applyChanges = Viewmodel$applyChanges;\n\n  function Viewmodel$applyChanges() {\n  \tvar _this = this;\n\n  \tvar self = this,\n  \t    changes,\n  \t    upstreamChanges,\n  \t    hash = {},\n  \t    bindings;\n\n  \tchanges = this.changes;\n\n  \tif (!changes.length) {\n  \t\t// TODO we end up here on initial render. Perhaps we shouldn't?\n  \t\treturn;\n  \t}\n\n  \tfunction invalidateComputation(computation) {\n  \t\tvar key = computation.key;\n\n  \t\tif (computation.viewmodel === self) {\n  \t\t\tself.clearCache(key.str);\n  \t\t\tcomputation.invalidate();\n\n  \t\t\tchanges.push(key);\n  \t\t\tcascade(key);\n  \t\t} else {\n  \t\t\tcomputation.viewmodel.mark(key);\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar map, computations;\n\n  \t\tif (self.noCascade.hasOwnProperty(keypath.str)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (computations = self.deps.computed[keypath.str]) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n\n  \t\tif (map = self.depsMap.computed[keypath.str]) {\n  \t\t\tmap.forEach(cascade);\n  \t\t}\n  \t}\n\n  \tchanges.slice().forEach(cascade);\n\n  \tupstreamChanges = helpers_getUpstreamChanges(changes);\n  \tupstreamChanges.forEach(function (keypath) {\n  \t\tvar computations;\n\n  \t\t// make sure we haven't already been down this particular keypath in this turn\n  \t\tif (changes.indexOf(keypath) === -1 && (computations = self.deps.computed[keypath.str])) {\n  \t\t\tcomputations.forEach(invalidateComputation);\n  \t\t}\n  \t});\n\n  \tthis.changes = [];\n\n  \t// Pattern observers are a weird special case\n  \tif (this.patternObservers.length) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath, true);\n  \t\t});\n  \t\tchanges.forEach(function (keypath) {\n  \t\t\treturn applyChanges_notifyPatternObservers(_this, keypath);\n  \t\t});\n  \t}\n\n  \tif (this.deps.observers) {\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, null, keypath, \"observers\");\n  \t\t});\n  \t\tnotifyAllDependants(this, changes, \"observers\");\n  \t}\n\n  \tif (this.deps[\"default\"]) {\n  \t\tbindings = [];\n  \t\tupstreamChanges.forEach(function (keypath) {\n  \t\t\treturn notifyUpstreamDependants(_this, bindings, keypath, \"default\");\n  \t\t});\n\n  \t\tif (bindings.length) {\n  \t\t\tnotifyBindings(this, bindings, changes);\n  \t\t}\n\n  \t\tnotifyAllDependants(this, changes, \"default\");\n  \t}\n\n  \t// Return a hash of keypaths to updated values\n  \tchanges.forEach(function (keypath) {\n  \t\thash[keypath.str] = _this.get(keypath);\n  \t});\n\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \treturn hash;\n  }\n\n  function notifyUpstreamDependants(viewmodel, bindings, keypath, groupName) {\n  \tvar dependants, value;\n\n  \tif (dependants = findDependants(viewmodel, keypath, groupName)) {\n  \t\tvalue = viewmodel.get(keypath);\n\n  \t\tdependants.forEach(function (d) {\n  \t\t\t// don't \"set\" the parent value, refine it\n  \t\t\t// i.e. not data = value, but data[foo] = fooValue\n  \t\t\tif (bindings && d.refineValue) {\n  \t\t\t\tbindings.push(d);\n  \t\t\t} else {\n  \t\t\t\td.setValue(value);\n  \t\t\t}\n  \t\t});\n  \t}\n  }\n\n  function notifyBindings(viewmodel, bindings, changes) {\n\n  \tbindings.forEach(function (binding) {\n  \t\tvar useSet = false,\n  \t\t    i = 0,\n  \t\t    length = changes.length,\n  \t\t    refinements = [];\n\n  \t\twhile (i < length) {\n  \t\t\tvar keypath = changes[i];\n\n  \t\t\tif (keypath === binding.keypath) {\n  \t\t\t\tuseSet = true;\n  \t\t\t\tbreak;\n  \t\t\t}\n\n  \t\t\tif (keypath.slice(0, binding.keypath.length) === binding.keypath) {\n  \t\t\t\trefinements.push(keypath);\n  \t\t\t}\n\n  \t\t\ti++;\n  \t\t}\n\n  \t\tif (useSet) {\n  \t\t\tbinding.setValue(viewmodel.get(binding.keypath));\n  \t\t}\n\n  \t\tif (refinements.length) {\n  \t\t\tbinding.refineValue(refinements);\n  \t\t}\n  \t});\n  }\n\n  function notifyAllDependants(viewmodel, keypaths, groupName) {\n  \tvar queue = [];\n\n  \taddKeypaths(keypaths);\n  \tqueue.forEach(dispatch);\n\n  \tfunction addKeypaths(keypaths) {\n  \t\tkeypaths.forEach(addKeypath);\n  \t\tkeypaths.forEach(cascade);\n  \t}\n\n  \tfunction addKeypath(keypath) {\n  \t\tvar deps = findDependants(viewmodel, keypath, groupName);\n\n  \t\tif (deps) {\n  \t\t\tqueue.push({\n  \t\t\t\tkeypath: keypath,\n  \t\t\t\tdeps: deps\n  \t\t\t});\n  \t\t}\n  \t}\n\n  \tfunction cascade(keypath) {\n  \t\tvar childDeps;\n\n  \t\tif (childDeps = viewmodel.depsMap[groupName][keypath.str]) {\n  \t\t\taddKeypaths(childDeps);\n  \t\t}\n  \t}\n\n  \tfunction dispatch(set) {\n  \t\tvar value = viewmodel.get(set.keypath);\n  \t\tset.deps.forEach(function (d) {\n  \t\t\treturn d.setValue(value);\n  \t\t});\n  \t}\n  }\n\n  function findDependants(viewmodel, keypath, groupName) {\n  \tvar group = viewmodel.deps[groupName];\n  \treturn group ? group[keypath.str] : null;\n  }\n\n  var capture = Viewmodel$capture;\n\n  function Viewmodel$capture() {\n  \tthis.captureGroups.push([]);\n  }\n\n  var clearCache = Viewmodel$clearCache;\n\n  function Viewmodel$clearCache(keypath, keepExistingWrapper) {\n  \tvar cacheMap, wrapper;\n\n  \tif (!keepExistingWrapper) {\n  \t\t// Is there a wrapped property at this keypath?\n  \t\tif (wrapper = this.wrapped[keypath]) {\n  \t\t\t// Did we unwrap it?\n  \t\t\tif (wrapper.teardown() !== false) {\n  \t\t\t\t// Is this right?\n  \t\t\t\t// What's the meaning of returning false from teardown?\n  \t\t\t\t// Could there be a GC ramification if this is a \"real\" ractive.teardown()?\n  \t\t\t\tthis.wrapped[keypath] = null;\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tthis.cache[keypath] = undefined;\n\n  \tif (cacheMap = this.cacheMap[keypath]) {\n  \t\twhile (cacheMap.length) {\n  \t\t\tthis.clearCache(cacheMap.pop());\n  \t\t}\n  \t}\n  }\n\n  var UnresolvedDependency = function (computation, ref) {\n  \tthis.computation = computation;\n  \tthis.viewmodel = computation.viewmodel;\n  \tthis.ref = ref;\n\n  \t// TODO this seems like a red flag!\n  \tthis.root = this.viewmodel.ractive;\n  \tthis.parentFragment = this.root.component && this.root.component.parentFragment;\n  };\n\n  UnresolvedDependency.prototype = {\n  \tresolve: function (keypath) {\n  \t\tthis.computation.softDeps.push(keypath);\n  \t\tthis.computation.unresolvedDeps[keypath.str] = null;\n  \t\tthis.viewmodel.register(keypath, this.computation, \"computed\");\n  \t}\n  };\n\n  var Computation_UnresolvedDependency = UnresolvedDependency;\n\n  var Computation = function (key, signature) {\n  \tthis.key = key;\n\n  \tthis.getter = signature.getter;\n  \tthis.setter = signature.setter;\n\n  \tthis.hardDeps = signature.deps || [];\n  \tthis.softDeps = [];\n  \tthis.unresolvedDeps = {};\n\n  \tthis.depValues = {};\n\n  \tthis._dirty = this._firstRun = true;\n  };\n\n  Computation.prototype = {\n  \tconstructor: Computation,\n\n  \tinit: function (viewmodel) {\n  \t\tvar _this = this;\n\n  \t\tvar initial;\n\n  \t\tthis.viewmodel = viewmodel;\n  \t\tthis.bypass = true;\n\n  \t\tinitial = viewmodel.get(this.key);\n  \t\tviewmodel.clearCache(this.key.str);\n\n  \t\tthis.bypass = false;\n\n  \t\tif (this.setter && initial !== undefined) {\n  \t\t\tthis.set(initial);\n  \t\t}\n\n  \t\tif (this.hardDeps) {\n  \t\t\tthis.hardDeps.forEach(function (d) {\n  \t\t\t\treturn viewmodel.register(d, _this, \"computed\");\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \tinvalidate: function () {\n  \t\tthis._dirty = true;\n  \t},\n\n  \tget: function () {\n  \t\tvar _this = this;\n\n  \t\tvar newDeps,\n  \t\t    dependenciesChanged,\n  \t\t    dependencyValuesChanged = false;\n\n  \t\tif (this.getting) {\n  \t\t\t// prevent double-computation (e.g. caused by array mutation inside computation)\n  \t\t\tvar msg = \"The \" + this.key.str + \" computation indirectly called itself. This probably indicates a bug in the computation. It is commonly caused by `array.sort(...)` - if that's the case, clone the array first with `array.slice().sort(...)`\";\n  \t\t\twarnOnce(msg);\n  \t\t\treturn this.value;\n  \t\t}\n\n  \t\tthis.getting = true;\n\n  \t\tif (this._dirty) {\n  \t\t\t// determine whether the inputs have changed, in case this depends on\n  \t\t\t// other computed values\n  \t\t\tif (this._firstRun || !this.hardDeps.length && !this.softDeps.length) {\n  \t\t\t\tdependencyValuesChanged = true;\n  \t\t\t} else {\n  \t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\tvar keypath, value, i;\n\n  \t\t\t\t\tif (dependencyValuesChanged) {\n  \t\t\t\t\t\treturn;\n  \t\t\t\t\t}\n\n  \t\t\t\t\ti = deps.length;\n  \t\t\t\t\twhile (i--) {\n  \t\t\t\t\t\tkeypath = deps[i];\n  \t\t\t\t\t\tvalue = _this.viewmodel.get(keypath);\n\n  \t\t\t\t\t\tif (!isEqual(value, _this.depValues[keypath.str])) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = value;\n  \t\t\t\t\t\t\tdependencyValuesChanged = true;\n\n  \t\t\t\t\t\t\treturn;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t});\n  \t\t\t}\n\n  \t\t\tif (dependencyValuesChanged) {\n  \t\t\t\tthis.viewmodel.capture();\n\n  \t\t\t\ttry {\n  \t\t\t\t\tthis.value = this.getter();\n  \t\t\t\t} catch (err) {\n  \t\t\t\t\twarnIfDebug(\"Failed to compute \\\"%s\\\"\", this.key.str);\n  \t\t\t\t\tlogIfDebug(err.stack || err);\n\n  \t\t\t\t\tthis.value = void 0;\n  \t\t\t\t}\n\n  \t\t\t\tnewDeps = this.viewmodel.release();\n  \t\t\t\tdependenciesChanged = this.updateDependencies(newDeps);\n\n  \t\t\t\tif (dependenciesChanged) {\n  \t\t\t\t\t[this.hardDeps, this.softDeps].forEach(function (deps) {\n  \t\t\t\t\t\tdeps.forEach(function (keypath) {\n  \t\t\t\t\t\t\t_this.depValues[keypath.str] = _this.viewmodel.get(keypath);\n  \t\t\t\t\t\t});\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tthis._dirty = false;\n  \t\t}\n\n  \t\tthis.getting = this._firstRun = false;\n  \t\treturn this.value;\n  \t},\n\n  \tset: function (value) {\n  \t\tif (this.setting) {\n  \t\t\tthis.value = value;\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!this.setter) {\n  \t\t\tthrow new Error(\"Computed properties without setters are read-only. (This may change in a future version of Ractive!)\");\n  \t\t}\n\n  \t\tthis.setter(value);\n  \t},\n\n  \tupdateDependencies: function (newDeps) {\n  \t\tvar i, oldDeps, keypath, dependenciesChanged, unresolved;\n\n  \t\toldDeps = this.softDeps;\n\n  \t\t// remove dependencies that are no longer used\n  \t\ti = oldDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = oldDeps[i];\n\n  \t\t\tif (newDeps.indexOf(keypath) === -1) {\n  \t\t\t\tdependenciesChanged = true;\n  \t\t\t\tthis.viewmodel.unregister(keypath, this, \"computed\");\n  \t\t\t}\n  \t\t}\n\n  \t\t// create references for any new dependencies\n  \t\ti = newDeps.length;\n  \t\twhile (i--) {\n  \t\t\tkeypath = newDeps[i];\n\n  \t\t\tif (oldDeps.indexOf(keypath) === -1 && (!this.hardDeps || this.hardDeps.indexOf(keypath) === -1)) {\n  \t\t\t\tdependenciesChanged = true;\n\n  \t\t\t\t// if this keypath is currently unresolved, we need to mark\n  \t\t\t\t// it as such. TODO this is a bit muddy...\n  \t\t\t\tif (isUnresolved(this.viewmodel, keypath) && !this.unresolvedDeps[keypath.str]) {\n  \t\t\t\t\tunresolved = new Computation_UnresolvedDependency(this, keypath.str);\n  \t\t\t\t\tnewDeps.splice(i, 1);\n\n  \t\t\t\t\tthis.unresolvedDeps[keypath.str] = unresolved;\n  \t\t\t\t\tglobal_runloop.addUnresolved(unresolved);\n  \t\t\t\t} else {\n  \t\t\t\t\tthis.viewmodel.register(keypath, this, \"computed\");\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\tif (dependenciesChanged) {\n  \t\t\tthis.softDeps = newDeps.slice();\n  \t\t}\n\n  \t\treturn dependenciesChanged;\n  \t}\n  };\n\n  function isUnresolved(viewmodel, keypath) {\n  \tvar key = keypath.firstKey;\n\n  \treturn !(key in viewmodel.data) && !(key in viewmodel.computations) && !(key in viewmodel.mappings);\n  }\n\n  var Computation_Computation = Computation;\n\n  var compute = Viewmodel$compute;\n  function Viewmodel$compute(key, signature) {\n  \tvar computation = new Computation_Computation(key, signature);\n\n  \tif (this.ready) {\n  \t\tcomputation.init(this);\n  \t}\n\n  \treturn this.computations[key.str] = computation;\n  }\n\n  var FAILED_LOOKUP = { FAILED_LOOKUP: true };\n\n  var viewmodel_prototype_get = Viewmodel$get;\n\n  var viewmodel_prototype_get__empty = {};\n  function Viewmodel$get(keypath, options) {\n  \tvar cache = this.cache,\n  \t    value,\n  \t    computation,\n  \t    wrapped,\n  \t    captureGroup,\n  \t    keypathStr = keypath.str,\n  \t    key;\n\n  \toptions = options || viewmodel_prototype_get__empty;\n\n  \t// capture the keypath, if we're inside a computation\n  \tif (options.capture && (captureGroup = lastItem(this.captureGroups))) {\n  \t\tif (! ~captureGroup.indexOf(keypath)) {\n  \t\t\tcaptureGroup.push(keypath);\n  \t\t}\n  \t}\n\n  \tif (hasOwn.call(this.mappings, keypath.firstKey)) {\n  \t\treturn this.mappings[keypath.firstKey].get(keypath, options);\n  \t}\n\n  \tif (keypath.isSpecial) {\n  \t\treturn keypath.value;\n  \t}\n\n  \tif (cache[keypathStr] === undefined) {\n\n  \t\t// Is this a computed property?\n  \t\tif ((computation = this.computations[keypathStr]) && !computation.bypass) {\n  \t\t\tvalue = computation.get();\n  \t\t\tthis.adapt(keypathStr, value);\n  \t\t}\n\n  \t\t// Is this a wrapped property?\n  \t\telse if (wrapped = this.wrapped[keypathStr]) {\n  \t\t\tvalue = wrapped.value;\n  \t\t}\n\n  \t\t// Is it the root?\n  \t\telse if (keypath.isRoot) {\n  \t\t\tthis.adapt(\"\", this.data);\n  \t\t\tvalue = this.data;\n  \t\t}\n\n  \t\t// No? Then we need to retrieve the value one key at a time\n  \t\telse {\n  \t\t\tvalue = retrieve(this, keypath);\n  \t\t}\n\n  \t\tcache[keypathStr] = value;\n  \t} else {\n  \t\tvalue = cache[keypathStr];\n  \t}\n\n  \tif (!options.noUnwrap && (wrapped = this.wrapped[keypathStr])) {\n  \t\tvalue = wrapped.get();\n  \t}\n\n  \tif (keypath.isRoot && options.fullRootGet) {\n  \t\tfor (key in this.mappings) {\n  \t\t\tvalue[key] = this.mappings[key].getValue();\n  \t\t}\n  \t}\n\n  \treturn value === FAILED_LOOKUP ? void 0 : value;\n  }\n\n  function retrieve(viewmodel, keypath) {\n\n  \tvar parentValue, cacheMap, value, wrapped;\n\n  \tparentValue = viewmodel.get(keypath.parent);\n\n  \tif (wrapped = viewmodel.wrapped[keypath.parent.str]) {\n  \t\tparentValue = wrapped.get();\n  \t}\n\n  \tif (parentValue === null || parentValue === undefined) {\n  \t\treturn;\n  \t}\n\n  \t// update cache map\n  \tif (!(cacheMap = viewmodel.cacheMap[keypath.parent.str])) {\n  \t\tviewmodel.cacheMap[keypath.parent.str] = [keypath.str];\n  \t} else {\n  \t\tif (cacheMap.indexOf(keypath.str) === -1) {\n  \t\t\tcacheMap.push(keypath.str);\n  \t\t}\n  \t}\n\n  \t// If this property doesn't exist, we return a sentinel value\n  \t// so that we know to query parent scope (if such there be)\n  \tif (typeof parentValue === \"object\" && !(keypath.lastKey in parentValue)) {\n  \t\treturn viewmodel.cache[keypath.str] = FAILED_LOOKUP;\n  \t}\n\n  \tvalue = parentValue[keypath.lastKey];\n\n  \t// Do we have an adaptor for this value?\n  \tviewmodel.adapt(keypath.str, value, false);\n\n  \t// Update cache\n  \tviewmodel.cache[keypath.str] = value;\n  \treturn value;\n  }\n\n  var viewmodel_prototype_init = Viewmodel$init;\n\n  function Viewmodel$init() {\n  \tvar key;\n\n  \tfor (key in this.computations) {\n  \t\tthis.computations[key].init(this);\n  \t}\n  }\n\n  var prototype_map = Viewmodel$map;\n\n  function Viewmodel$map(key, options) {\n  \tvar mapping = this.mappings[key.str] = new Mapping(key, options);\n  \tmapping.initViewmodel(this);\n  \treturn mapping;\n  }\n\n  var Mapping = function (localKey, options) {\n  \tthis.localKey = localKey;\n  \tthis.keypath = options.keypath;\n  \tthis.origin = options.origin;\n\n  \tthis.deps = [];\n  \tthis.unresolved = [];\n\n  \tthis.resolved = false;\n  };\n\n  Mapping.prototype = {\n  \tforceResolution: function () {\n  \t\t// TODO warn, as per #1692?\n  \t\tthis.keypath = this.localKey;\n  \t\tthis.setup();\n  \t},\n\n  \tget: function (keypath, options) {\n  \t\tif (!this.resolved) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.map(keypath), options);\n  \t},\n\n  \tgetValue: function () {\n  \t\tif (!this.keypath) {\n  \t\t\treturn undefined;\n  \t\t}\n  \t\treturn this.origin.get(this.keypath);\n  \t},\n\n  \tinitViewmodel: function (viewmodel) {\n  \t\tthis.local = viewmodel;\n  \t\tthis.setup();\n  \t},\n\n  \tmap: function (keypath) {\n  \t\tif (typeof this.keypath === undefined) {\n  \t\t\treturn this.localKey;\n  \t\t}\n  \t\treturn keypath.replace(this.localKey, this.keypath);\n  \t},\n\n  \tregister: function (keypath, dependant, group) {\n  \t\tthis.deps.push({ keypath: keypath, dep: dependant, group: group });\n\n  \t\tif (this.resolved) {\n  \t\t\tthis.origin.register(this.map(keypath), dependant, group);\n  \t\t}\n  \t},\n\n  \tresolve: function (keypath) {\n  \t\tif (this.keypath !== undefined) {\n  \t\t\tthis.unbind(true);\n  \t\t}\n\n  \t\tthis.keypath = keypath;\n  \t\tthis.setup();\n  \t},\n\n  \tset: function (keypath, value) {\n  \t\tif (!this.resolved) {\n  \t\t\tthis.forceResolution();\n  \t\t}\n\n  \t\tthis.origin.set(this.map(keypath), value);\n  \t},\n\n  \tsetup: function () {\n  \t\tvar _this = this;\n\n  \t\tif (this.keypath === undefined) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.resolved = true;\n\n  \t\t// accumulated dependants can now be registered\n  \t\tif (this.deps.length) {\n  \t\t\tthis.deps.forEach(function (d) {\n  \t\t\t\tvar keypath = _this.map(d.keypath);\n  \t\t\t\t_this.origin.register(keypath, d.dep, d.group);\n\n  \t\t\t\t// TODO this is a bit of a red flag... all deps should be the same?\n  \t\t\t\tif (d.dep.setValue) {\n  \t\t\t\t\td.dep.setValue(_this.origin.get(keypath));\n  \t\t\t\t} else if (d.dep.invalidate) {\n  \t\t\t\t\td.dep.invalidate();\n  \t\t\t\t} else {\n  \t\t\t\t\tthrow new Error(\"An unexpected error occurred. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t\t\t}\n  \t\t\t});\n\n  \t\t\tthis.origin.mark(this.keypath);\n  \t\t}\n  \t},\n\n  \tsetValue: function (value) {\n  \t\tif (!this.keypath) {\n  \t\t\tthrow new Error(\"Mapping does not have keypath, cannot set value. Please raise an issue at https://github.com/ractivejs/ractive/issues - thanks!\");\n  \t\t}\n\n  \t\tthis.origin.set(this.keypath, value);\n  \t},\n\n  \tunbind: function (keepLocal) {\n  \t\tvar _this = this;\n\n  \t\tif (!keepLocal) {\n  \t\t\tdelete this.local.mappings[this.localKey];\n  \t\t}\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tthis.deps.forEach(function (d) {\n  \t\t\t_this.origin.unregister(_this.map(d.keypath), d.dep, d.group);\n  \t\t});\n\n  \t\tif (this.tracker) {\n  \t\t\tthis.origin.unregister(this.keypath, this.tracker);\n  \t\t}\n  \t},\n\n  \tunregister: function (keypath, dependant, group) {\n  \t\tvar deps, i;\n\n  \t\tif (!this.resolved) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tdeps = this.deps;\n  \t\ti = deps.length;\n\n  \t\twhile (i--) {\n  \t\t\tif (deps[i].dep === dependant) {\n  \t\t\t\tdeps.splice(i, 1);\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t}\n  \t\tthis.origin.unregister(this.map(keypath), dependant, group);\n  \t}\n  };\n\n  var mark = Viewmodel$mark;\n\n  function Viewmodel$mark(keypath, options) {\n  \tvar computation,\n  \t    keypathStr = keypath.str;\n\n  \t// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)\n  \t// should not be picked up by pattern observers\n  \tif (options) {\n  \t\tif (options.implicit) {\n  \t\t\tthis.implicitChanges[keypathStr] = true;\n  \t\t}\n  \t\tif (options.noCascade) {\n  \t\t\tthis.noCascade[keypathStr] = true;\n  \t\t}\n  \t}\n\n  \tif (computation = this.computations[keypathStr]) {\n  \t\tcomputation.invalidate();\n  \t}\n\n  \tif (this.changes.indexOf(keypath) === -1) {\n  \t\tthis.changes.push(keypath);\n  \t}\n\n  \t// pass on keepExistingWrapper, if we can\n  \tvar keepExistingWrapper = options ? options.keepExistingWrapper : false;\n\n  \tthis.clearCache(keypathStr, keepExistingWrapper);\n\n  \tif (this.ready) {\n  \t\tthis.onchange();\n  \t}\n  }\n\n  var mapOldToNewIndex = function (oldArray, newArray) {\n  \tvar usedIndices, firstUnusedIndex, newIndices, changed;\n\n  \tusedIndices = {};\n  \tfirstUnusedIndex = 0;\n\n  \tnewIndices = oldArray.map(function (item, i) {\n  \t\tvar index, start, len;\n\n  \t\tstart = firstUnusedIndex;\n  \t\tlen = newArray.length;\n\n  \t\tdo {\n  \t\t\tindex = newArray.indexOf(item, start);\n\n  \t\t\tif (index === -1) {\n  \t\t\t\tchanged = true;\n  \t\t\t\treturn -1;\n  \t\t\t}\n\n  \t\t\tstart = index + 1;\n  \t\t} while (usedIndices[index] && start < len);\n\n  \t\t// keep track of the first unused index, so we don't search\n  \t\t// the whole of newArray for each item in oldArray unnecessarily\n  \t\tif (index === firstUnusedIndex) {\n  \t\t\tfirstUnusedIndex += 1;\n  \t\t}\n\n  \t\tif (index !== i) {\n  \t\t\tchanged = true;\n  \t\t}\n\n  \t\tusedIndices[index] = true;\n  \t\treturn index;\n  \t});\n\n  \treturn newIndices;\n  };\n\n  var merge = Viewmodel$merge;\n\n  var comparators = {};\n  function Viewmodel$merge(keypath, currentArray, array, options) {\n  \tvar oldArray, newArray, comparator, newIndices;\n\n  \tthis.mark(keypath);\n\n  \tif (options && options.compare) {\n\n  \t\tcomparator = getComparatorFunction(options.compare);\n\n  \t\ttry {\n  \t\t\toldArray = currentArray.map(comparator);\n  \t\t\tnewArray = array.map(comparator);\n  \t\t} catch (err) {\n  \t\t\t// fallback to an identity check - worst case scenario we have\n  \t\t\t// to do more DOM manipulation than we thought...\n  \t\t\twarnIfDebug(\"merge(): \\\"%s\\\" comparison failed. Falling back to identity checking\", keypath);\n\n  \t\t\toldArray = currentArray;\n  \t\t\tnewArray = array;\n  \t\t}\n  \t} else {\n  \t\toldArray = currentArray;\n  \t\tnewArray = array;\n  \t}\n\n  \t// find new indices for members of oldArray\n  \tnewIndices = mapOldToNewIndex(oldArray, newArray);\n\n  \tthis.smartUpdate(keypath, array, newIndices, currentArray.length !== array.length);\n  }\n\n  function stringify(item) {\n  \treturn JSON.stringify(item);\n  }\n\n  function getComparatorFunction(comparator) {\n  \t// If `compare` is `true`, we use JSON.stringify to compare\n  \t// objects that are the same shape, but non-identical - i.e.\n  \t// { foo: 'bar' } !== { foo: 'bar' }\n  \tif (comparator === true) {\n  \t\treturn stringify;\n  \t}\n\n  \tif (typeof comparator === \"string\") {\n  \t\tif (!comparators[comparator]) {\n  \t\t\tcomparators[comparator] = function (item) {\n  \t\t\t\treturn item[comparator];\n  \t\t\t};\n  \t\t}\n\n  \t\treturn comparators[comparator];\n  \t}\n\n  \tif (typeof comparator === \"function\") {\n  \t\treturn comparator;\n  \t}\n\n  \tthrow new Error(\"The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)\");\n  }\n\n  var register = Viewmodel$register;\n\n  function Viewmodel$register(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, depsByKeypath, deps;\n\n  \tif (dependant.isStatic) {\n  \t\treturn; // TODO we should never get here if a dependant is static...\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\tmapping.register(keypath, dependant, group);\n  \t} else {\n  \t\tdepsByKeypath = this.deps[group] || (this.deps[group] = {});\n  \t\tdeps = depsByKeypath[keypath.str] || (depsByKeypath[keypath.str] = []);\n\n  \t\tdeps.push(dependant);\n\n  \t\tif (!this.depsMap[group]) {\n  \t\t\tthis.depsMap[group] = {};\n  \t\t}\n\n  \t\tif (!keypath.isRoot) {\n  \t\t\tregister__updateDependantsMap(this, keypath, group);\n  \t\t}\n  \t}\n  }\n\n  function register__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent, keypathStr;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str] || (map[keypath.parent.str] = []);\n\n  \t\tkeypathStr = keypath.str;\n\n  \t\t// TODO find an alternative to this nasty approach\n  \t\tif (parent[\"_\" + keypathStr] === undefined) {\n  \t\t\tparent[\"_\" + keypathStr] = 0;\n  \t\t\tparent.push(keypath);\n  \t\t}\n\n  \t\tparent[\"_\" + keypathStr] += 1;\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var release = Viewmodel$release;\n\n  function Viewmodel$release() {\n  \treturn this.captureGroups.pop();\n  }\n\n  var reset = Viewmodel$reset;\n\n  function Viewmodel$reset(data) {\n  \tthis.data = data;\n  \tthis.clearCache(\"\");\n  }\n\n  var prototype_set = Viewmodel$set;\n\n  function Viewmodel$set(keypath, value) {\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar mapping, computation, wrapper, keepExistingWrapper;\n\n  \t// unless data is being set for data tracking purposes\n  \tif (!options.noMapping) {\n  \t\t// If this data belongs to a different viewmodel,\n  \t\t// pass the change along\n  \t\tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\t\treturn mapping.set(keypath, value);\n  \t\t}\n  \t}\n\n  \tcomputation = this.computations[keypath.str];\n  \tif (computation) {\n  \t\tif (computation.setting) {\n  \t\t\t// let the other computation set() handle things...\n  \t\t\treturn;\n  \t\t}\n  \t\tcomputation.set(value);\n  \t\tvalue = computation.get();\n  \t}\n\n  \tif (isEqual(this.cache[keypath.str], value)) {\n  \t\treturn;\n  \t}\n\n  \twrapper = this.wrapped[keypath.str];\n\n  \t// If we have a wrapper with a `reset()` method, we try and use it. If the\n  \t// `reset()` method returns false, the wrapper should be torn down, and\n  \t// (most likely) a new one should be created later\n  \tif (wrapper && wrapper.reset) {\n  \t\tkeepExistingWrapper = wrapper.reset(value) !== false;\n\n  \t\tif (keepExistingWrapper) {\n  \t\t\tvalue = wrapper.get();\n  \t\t}\n  \t}\n\n  \tif (!computation && !keepExistingWrapper) {\n  \t\tresolveSet(this, keypath, value);\n  \t}\n\n  \tif (!options.silent) {\n  \t\tthis.mark(keypath);\n  \t} else {\n  \t\t// We're setting a parent of the original target keypath (i.e.\n  \t\t// creating a fresh branch) - we need to clear the cache, but\n  \t\t// not mark it as a change\n  \t\tthis.clearCache(keypath.str);\n  \t}\n  }\n\n  function resolveSet(viewmodel, keypath, value) {\n  \tvar wrapper, parentValue, wrapperSet, valueSet;\n\n  \twrapperSet = function () {\n  \t\tif (wrapper.set) {\n  \t\t\twrapper.set(keypath.lastKey, value);\n  \t\t} else {\n  \t\t\tparentValue = wrapper.get();\n  \t\t\tvalueSet();\n  \t\t}\n  \t};\n\n  \tvalueSet = function () {\n  \t\tif (!parentValue) {\n  \t\t\tparentValue = createBranch(keypath.lastKey);\n  \t\t\tviewmodel.set(keypath.parent, parentValue, { silent: true });\n  \t\t}\n  \t\tparentValue[keypath.lastKey] = value;\n  \t};\n\n  \twrapper = viewmodel.wrapped[keypath.parent.str];\n\n  \tif (wrapper) {\n  \t\twrapperSet();\n  \t} else {\n  \t\tparentValue = viewmodel.get(keypath.parent);\n\n  \t\t// may have been wrapped via the above .get()\n  \t\t// call on viewmodel if this is first access via .set()!\n  \t\tif (wrapper = viewmodel.wrapped[keypath.parent.str]) {\n  \t\t\twrapperSet();\n  \t\t} else {\n  \t\t\tvalueSet();\n  \t\t}\n  \t}\n  }\n\n  var smartUpdate = Viewmodel$smartUpdate;\n\n  var implicitOption = { implicit: true },\n      noCascadeOption = { noCascade: true };\n  function Viewmodel$smartUpdate(keypath, array, newIndices) {\n  \tvar _this = this;\n\n  \tvar dependants, oldLength, i;\n\n  \toldLength = newIndices.length;\n\n  \t// Indices that are being removed should be marked as dirty\n  \tnewIndices.forEach(function (newIndex, oldIndex) {\n  \t\tif (newIndex === -1) {\n  \t\t\t_this.mark(keypath.join(oldIndex), noCascadeOption);\n  \t\t}\n  \t});\n\n  \t// Update the model\n  \t// TODO allow existing array to be updated in place, rather than replaced?\n  \tthis.set(keypath, array, { silent: true });\n\n  \tif (dependants = this.deps[\"default\"][keypath.str]) {\n  \t\tdependants.filter(canShuffle).forEach(function (d) {\n  \t\t\treturn d.shuffle(newIndices, array);\n  \t\t});\n  \t}\n\n  \tif (oldLength !== array.length) {\n  \t\tthis.mark(keypath.join(\"length\"), implicitOption);\n\n  \t\tfor (i = newIndices.touchedFrom; i < array.length; i += 1) {\n  \t\t\tthis.mark(keypath.join(i));\n  \t\t}\n\n  \t\t// don't allow removed indexes beyond end of new array to trigger recomputations\n  \t\t// TODO is this still necessary, now that computations are lazy?\n  \t\tfor (i = array.length; i < oldLength; i += 1) {\n  \t\t\tthis.mark(keypath.join(i), noCascadeOption);\n  \t\t}\n  \t}\n  }\n\n  function canShuffle(dependant) {\n  \treturn typeof dependant.shuffle === \"function\";\n  }\n\n  var prototype_teardown = Viewmodel$teardown;\n\n  function Viewmodel$teardown() {\n  \tvar _this = this;\n\n  \tvar unresolvedImplicitDependency;\n\n  \t// Clear entire cache - this has the desired side-effect\n  \t// of unwrapping adapted values (e.g. arrays)\n  \tObject.keys(this.cache).forEach(function (keypath) {\n  \t\treturn _this.clearCache(keypath);\n  \t});\n\n  \t// Teardown any failed lookups - we don't need them to resolve any more\n  \twhile (unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop()) {\n  \t\tunresolvedImplicitDependency.teardown();\n  \t}\n  }\n\n  var unregister = Viewmodel$unregister;\n\n  function Viewmodel$unregister(keypath, dependant) {\n  \tvar group = arguments[2] === undefined ? \"default\" : arguments[2];\n\n  \tvar mapping, deps, index;\n\n  \tif (dependant.isStatic) {\n  \t\treturn;\n  \t}\n\n  \tif (mapping = this.mappings[keypath.firstKey]) {\n  \t\treturn mapping.unregister(keypath, dependant, group);\n  \t}\n\n  \tdeps = this.deps[group][keypath.str];\n  \tindex = deps.indexOf(dependant);\n\n  \tif (index === -1) {\n  \t\tthrow new Error(\"Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks\");\n  \t}\n\n  \tdeps.splice(index, 1);\n\n  \tif (keypath.isRoot) {\n  \t\treturn;\n  \t}\n\n  \tunregister__updateDependantsMap(this, keypath, group);\n  }\n\n  function unregister__updateDependantsMap(viewmodel, keypath, group) {\n  \tvar map, parent;\n\n  \t// update dependants map\n  \twhile (!keypath.isRoot) {\n  \t\tmap = viewmodel.depsMap[group];\n  \t\tparent = map[keypath.parent.str];\n\n  \t\tparent[\"_\" + keypath.str] -= 1;\n\n  \t\tif (!parent[\"_\" + keypath.str]) {\n  \t\t\t// remove from parent deps map\n  \t\t\tremoveFromArray(parent, keypath);\n  \t\t\tparent[\"_\" + keypath.str] = undefined;\n  \t\t}\n\n  \t\tkeypath = keypath.parent;\n  \t}\n  }\n\n  var Viewmodel = function (options) {\n  \tvar adapt = options.adapt;\n  \tvar data = options.data;\n  \tvar ractive = options.ractive;\n  \tvar computed = options.computed;\n  \tvar mappings = options.mappings;\n  \tvar key;\n  \tvar mapping;\n\n  \t// TODO is it possible to remove this reference?\n  \tthis.ractive = ractive;\n\n  \tthis.adaptors = adapt;\n  \tthis.onchange = options.onchange;\n\n  \tthis.cache = {}; // we need to be able to use hasOwnProperty, so can't inherit from null\n  \tthis.cacheMap = create(null);\n\n  \tthis.deps = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n  \tthis.depsMap = {\n  \t\tcomputed: create(null),\n  \t\t\"default\": create(null)\n  \t};\n\n  \tthis.patternObservers = [];\n\n  \tthis.specials = create(null);\n\n  \tthis.wrapped = create(null);\n  \tthis.computations = create(null);\n\n  \tthis.captureGroups = [];\n  \tthis.unresolvedImplicitDependencies = [];\n\n  \tthis.changes = [];\n  \tthis.implicitChanges = {};\n  \tthis.noCascade = {};\n\n  \tthis.data = data;\n\n  \t// set up explicit mappings\n  \tthis.mappings = create(null);\n  \tfor (key in mappings) {\n  \t\tthis.map(getKeypath(key), mappings[key]);\n  \t}\n\n  \tif (data) {\n  \t\t// if data exists locally, but is missing on the parent,\n  \t\t// we transfer ownership to the parent\n  \t\tfor (key in data) {\n  \t\t\tif ((mapping = this.mappings[key]) && mapping.getValue() === undefined) {\n  \t\t\t\tmapping.setValue(data[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tfor (key in computed) {\n  \t\tif (mappings && key in mappings) {\n  \t\t\tfatal(\"Cannot map to a computed property ('%s')\", key);\n  \t\t}\n\n  \t\tthis.compute(getKeypath(key), computed[key]);\n  \t}\n\n  \tthis.ready = true;\n  };\n\n  Viewmodel.prototype = {\n  \tadapt: prototype_adapt,\n  \tapplyChanges: applyChanges,\n  \tcapture: capture,\n  \tclearCache: clearCache,\n  \tcompute: compute,\n  \tget: viewmodel_prototype_get,\n  \tinit: viewmodel_prototype_init,\n  \tmap: prototype_map,\n  \tmark: mark,\n  \tmerge: merge,\n  \tregister: register,\n  \trelease: release,\n  \treset: reset,\n  \tset: prototype_set,\n  \tsmartUpdate: smartUpdate,\n  \tteardown: prototype_teardown,\n  \tunregister: unregister\n  };\n\n  var viewmodel_Viewmodel = Viewmodel;\n\n  function HookQueue(event) {\n  \tthis.hook = new hooks_Hook(event);\n  \tthis.inProcess = {};\n  \tthis.queue = {};\n  }\n\n  HookQueue.prototype = {\n\n  \tconstructor: HookQueue,\n\n  \tbegin: function (ractive) {\n  \t\tthis.inProcess[ractive._guid] = true;\n  \t},\n\n  \tend: function (ractive) {\n\n  \t\tvar parent = ractive.parent;\n\n  \t\t// If this is *isn't* a child of a component that's in process,\n  \t\t// it should call methods or fire at this point\n  \t\tif (!parent || !this.inProcess[parent._guid]) {\n  \t\t\tfire(this, ractive);\n  \t\t}\n  \t\t// elsewise, handoff to parent to fire when ready\n  \t\telse {\n  \t\t\tgetChildQueue(this.queue, parent).push(ractive);\n  \t\t}\n\n  \t\tdelete this.inProcess[ractive._guid];\n  \t}\n  };\n\n  function getChildQueue(queue, ractive) {\n  \treturn queue[ractive._guid] || (queue[ractive._guid] = []);\n  }\n\n  function fire(hookQueue, ractive) {\n\n  \tvar childQueue = getChildQueue(hookQueue.queue, ractive);\n\n  \thookQueue.hook.fire(ractive);\n\n  \t// queue is \"live\" because components can end up being\n  \t// added while hooks fire on parents that modify data values.\n  \twhile (childQueue.length) {\n  \t\tfire(hookQueue, childQueue.shift());\n  \t}\n\n  \tdelete hookQueue.queue[ractive._guid];\n  }\n\n  var hooks_HookQueue = HookQueue;\n\n  var helpers_getComputationSignatures = getComputationSignatures;\n\n  var helpers_getComputationSignatures__pattern = /\\$\\{([^\\}]+)\\}/g;\n  function getComputationSignatures(ractive, computed) {\n  \tvar signatures = {},\n  \t    key;\n\n  \tfor (key in computed) {\n  \t\tsignatures[key] = getComputationSignature(ractive, key, computed[key]);\n  \t}\n\n  \treturn signatures;\n  }\n\n  function getComputationSignature(ractive, key, signature) {\n  \tvar getter, setter;\n\n  \tif (typeof signature === \"function\") {\n  \t\tgetter = helpers_getComputationSignatures__bind(signature, ractive);\n  \t}\n\n  \tif (typeof signature === \"string\") {\n  \t\tgetter = createFunctionFromString(ractive, signature);\n  \t}\n\n  \tif (typeof signature === \"object\") {\n  \t\tif (typeof signature.get === \"string\") {\n  \t\t\tgetter = createFunctionFromString(ractive, signature.get);\n  \t\t} else if (typeof signature.get === \"function\") {\n  \t\t\tgetter = helpers_getComputationSignatures__bind(signature.get, ractive);\n  \t\t} else {\n  \t\t\tfatal(\"`%s` computation must have a `get()` method\", key);\n  \t\t}\n\n  \t\tif (typeof signature.set === \"function\") {\n  \t\t\tsetter = helpers_getComputationSignatures__bind(signature.set, ractive);\n  \t\t}\n  \t}\n\n  \treturn { getter: getter, setter: setter };\n  }\n\n  function createFunctionFromString(ractive, str) {\n  \tvar functionBody, hasThis, fn;\n\n  \tfunctionBody = \"return (\" + str.replace(helpers_getComputationSignatures__pattern, function (match, keypath) {\n  \t\thasThis = true;\n  \t\treturn \"__ractive.get(\\\"\" + keypath + \"\\\")\";\n  \t}) + \");\";\n\n  \tif (hasThis) {\n  \t\tfunctionBody = \"var __ractive = this; \" + functionBody;\n  \t}\n\n  \tfn = new Function(functionBody);\n  \treturn hasThis ? fn.bind(ractive) : fn;\n  }\n\n  function helpers_getComputationSignatures__bind(fn, context) {\n  \treturn /this/.test(fn.toString()) ? fn.bind(context) : fn;\n  }\n\n  var constructHook = new hooks_Hook(\"construct\");\n  var configHook = new hooks_Hook(\"config\");\n  var initHook = new hooks_HookQueue(\"init\");\n  var initialise__uid = 0;\n\n  var initialise__registryNames = [\"adaptors\", \"components\", \"decorators\", \"easing\", \"events\", \"interpolators\", \"partials\", \"transitions\"];\n\n  var initialise = initialiseRactiveInstance;\n\n  function initialiseRactiveInstance(ractive) {\n  \tvar userOptions = arguments[1] === undefined ? {} : arguments[1];\n  \tvar options = arguments[2] === undefined ? {} : arguments[2];\n\n  \tvar el, viewmodel;\n\n  \tif (_Ractive.DEBUG) {\n  \t\twelcome();\n  \t}\n\n  \tinitialiseProperties(ractive, options);\n\n  \t// TODO remove this, eventually\n  \tdefineProperty(ractive, \"data\", { get: deprecateRactiveData });\n\n  \t// TODO don't allow `onconstruct` with `new Ractive()`, there's no need for it\n  \tconstructHook.fire(ractive, userOptions);\n\n  \t// Add registries\n  \tinitialise__registryNames.forEach(function (name) {\n  \t\tractive[name] = utils_object__extend(create(ractive.constructor[name] || null), userOptions[name]);\n  \t});\n\n  \t// Create a viewmodel\n  \tviewmodel = new viewmodel_Viewmodel({\n  \t\tadapt: getAdaptors(ractive, ractive.adapt, userOptions),\n  \t\tdata: custom_data.init(ractive.constructor, ractive, userOptions),\n  \t\tcomputed: helpers_getComputationSignatures(ractive, utils_object__extend(create(ractive.constructor.prototype.computed), userOptions.computed)),\n  \t\tmappings: options.mappings,\n  \t\tractive: ractive,\n  \t\tonchange: function () {\n  \t\t\treturn global_runloop.addRactive(ractive);\n  \t\t}\n  \t});\n\n  \tractive.viewmodel = viewmodel;\n\n  \t// This can't happen earlier, because computed properties may call `ractive.get()`, etc\n  \tviewmodel.init();\n\n  \t// init config from Parent and options\n  \tconfig_config.init(ractive.constructor, ractive, userOptions);\n\n  \tconfigHook.fire(ractive);\n  \tinitHook.begin(ractive);\n\n  \t// // If this is a component with a function `data` property, call the function\n  \t// // with `ractive` as context (unless the child was also a function)\n  \t// if ( typeof ractive.constructor.prototype.data === 'function' && typeof userOptions.data !== 'function' ) {\n  \t// \tviewmodel.reset( ractive.constructor.prototype.data.call( ractive ) || fatal( '`data` functions must return a data object' ) );\n  \t// }\n\n  \t// Render virtual DOM\n  \tif (ractive.template) {\n  \t\tvar cssIds = undefined;\n\n  \t\tif (options.cssIds || ractive.cssId) {\n  \t\t\tcssIds = options.cssIds ? options.cssIds.slice() : [];\n\n  \t\t\tif (ractive.cssId) {\n  \t\t\t\tcssIds.push(ractive.cssId);\n  \t\t\t}\n  \t\t}\n\n  \t\tractive.fragment = new virtualdom_Fragment({\n  \t\t\ttemplate: ractive.template,\n  \t\t\troot: ractive,\n  \t\t\towner: ractive, // saves doing `if ( this.parent ) { /*...*/ }` later on\n  \t\t\tcssIds: cssIds\n  \t\t});\n  \t}\n\n  \tinitHook.end(ractive);\n\n  \t// render automatically ( if `el` is specified )\n  \tif (el = getElement(ractive.el)) {\n  \t\tvar promise = ractive.render(el, ractive.append);\n\n  \t\tif (_Ractive.DEBUG_PROMISES) {\n  \t\t\tpromise[\"catch\"](function (err) {\n  \t\t\t\twarnOnceIfDebug(\"Promise debugging is enabled, to help solve errors that happen asynchronously. Some browsers will log unhandled promise rejections, in which case you can safely disable promise debugging:\\n  Ractive.DEBUG_PROMISES = false;\");\n  \t\t\t\twarnIfDebug(\"An error happened during rendering\", { ractive: ractive });\n  \t\t\t\terr.stack && logIfDebug(err.stack);\n\n  \t\t\t\tthrow err;\n  \t\t\t});\n  \t\t}\n  \t}\n  }\n\n  function getAdaptors(ractive, protoAdapt, userOptions) {\n  \tvar adapt, magic, modifyArrays;\n\n  \tprotoAdapt = protoAdapt.map(lookup);\n  \tadapt = ensureArray(userOptions.adapt).map(lookup);\n\n  \tadapt = initialise__combine(protoAdapt, adapt);\n\n  \tmagic = \"magic\" in userOptions ? userOptions.magic : ractive.magic;\n  \tmodifyArrays = \"modifyArrays\" in userOptions ? userOptions.modifyArrays : ractive.modifyArrays;\n\n  \tif (magic) {\n  \t\tif (!environment__magic) {\n  \t\t\tthrow new Error(\"Getters and setters (magic mode) are not supported in this browser\");\n  \t\t}\n\n  \t\tif (modifyArrays) {\n  \t\t\tadapt.push(magicArray);\n  \t\t}\n\n  \t\tadapt.push(adaptors_magic);\n  \t}\n\n  \tif (modifyArrays) {\n  \t\tadapt.push(array_index);\n  \t}\n\n  \treturn adapt;\n\n  \tfunction lookup(adaptor) {\n  \t\tif (typeof adaptor === \"string\") {\n  \t\t\tadaptor = findInViewHierarchy(\"adaptors\", ractive, adaptor);\n\n  \t\t\tif (!adaptor) {\n  \t\t\t\tfatal(missingPlugin(adaptor, \"adaptor\"));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn adaptor;\n  \t}\n  }\n\n  function initialise__combine(a, b) {\n  \tvar c = a.slice(),\n  \t    i = b.length;\n\n  \twhile (i--) {\n  \t\tif (! ~c.indexOf(b[i])) {\n  \t\t\tc.push(b[i]);\n  \t\t}\n  \t}\n\n  \treturn c;\n  }\n\n  function initialiseProperties(ractive, options) {\n  \t// Generate a unique identifier, for places where you'd use a weak map if it\n  \t// existed\n  \tractive._guid = \"r-\" + initialise__uid++;\n\n  \t// events\n  \tractive._subs = create(null);\n\n  \t// storage for item configuration from instantiation to reset,\n  \t// like dynamic functions or original values\n  \tractive._config = {};\n\n  \t// two-way bindings\n  \tractive._twowayBindings = create(null);\n\n  \t// animations (so we can stop any in progress at teardown)\n  \tractive._animations = [];\n\n  \t// nodes registry\n  \tractive.nodes = {};\n\n  \t// live queries\n  \tractive._liveQueries = [];\n  \tractive._liveComponentQueries = [];\n\n  \t// bound data functions\n  \tractive._boundFunctions = [];\n\n  \t// observers\n  \tractive._observers = [];\n\n  \t// properties specific to inline components\n  \tif (options.component) {\n  \t\tractive.parent = options.parent;\n  \t\tractive.container = options.container || null;\n  \t\tractive.root = ractive.parent.root;\n\n  \t\tractive.component = options.component;\n  \t\toptions.component.instance = ractive;\n\n  \t\t// for hackability, this could be an open option\n  \t\t// for any ractive instance, but for now, just\n  \t\t// for components and just for ractive...\n  \t\tractive._inlinePartials = options.inlinePartials;\n  \t} else {\n  \t\tractive.root = ractive;\n  \t\tractive.parent = ractive.container = null;\n  \t}\n  }\n\n  function deprecateRactiveData() {\n  \tthrow new Error(\"Using `ractive.data` is no longer supported - you must use the `ractive.get()` API instead\");\n  }\n\n  function ComplexParameter(component, template, callback) {\n  \tthis.parentFragment = component.parentFragment;\n  \tthis.callback = callback;\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: template,\n  \t\troot: component.root,\n  \t\towner: this\n  \t});\n\n  \tthis.update();\n  }\n\n  var initialise_ComplexParameter = ComplexParameter;\n\n  ComplexParameter.prototype = {\n  \tbubble: function () {\n  \t\tif (!this.dirty) {\n  \t\t\tthis.dirty = true;\n  \t\t\tglobal_runloop.addView(this);\n  \t\t}\n  \t},\n\n  \tupdate: function () {\n  \t\tthis.callback(this.fragment.getValue());\n  \t\tthis.dirty = false;\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t}\n  };\n\n  var createInstance = function (component, Component, attributes, yieldTemplate, partials) {\n  \tvar instance,\n  \t    parentFragment,\n  \t    ractive,\n  \t    fragment,\n  \t    container,\n  \t    inlinePartials = {},\n  \t    data = {},\n  \t    mappings = {},\n  \t    ready,\n  \t    resolvers = [];\n\n  \tparentFragment = component.parentFragment;\n  \tractive = component.root;\n\n  \tpartials = partials || {};\n  \tutils_object__extend(inlinePartials, partials);\n\n  \t// Make contents available as a {{>content}} partial\n  \tpartials.content = yieldTemplate || [];\n\n  \t// set a default partial for yields with no name\n  \tinlinePartials[\"\"] = partials.content;\n\n  \tif (Component.defaults.el) {\n  \t\twarnIfDebug(\"The <%s/> component has a default `el` property; it has been disregarded\", component.name);\n  \t}\n\n  \t// find container\n  \tfragment = parentFragment;\n  \twhile (fragment) {\n  \t\tif (fragment.owner.type === YIELDER) {\n  \t\t\tcontainer = fragment.owner.container;\n  \t\t\tbreak;\n  \t\t}\n\n  \t\tfragment = fragment.parent;\n  \t}\n\n  \t// each attribute represents either a) data or b) a mapping\n  \tif (attributes) {\n  \t\tObject.keys(attributes).forEach(function (key) {\n  \t\t\tvar attribute = attributes[key],\n  \t\t\t    parsed,\n  \t\t\t    resolver;\n\n  \t\t\tif (typeof attribute === \"string\") {\n  \t\t\t\t// it's static data\n  \t\t\t\tparsed = parseJSON(attribute);\n  \t\t\t\tdata[key] = parsed ? parsed.value : attribute;\n  \t\t\t} else if (attribute === 0) {\n  \t\t\t\t// it had no '=', so we'll call it true\n  \t\t\t\tdata[key] = true;\n  \t\t\t} else if (isArray(attribute)) {\n  \t\t\t\t// this represents dynamic data\n  \t\t\t\tif (isSingleInterpolator(attribute)) {\n  \t\t\t\t\tmappings[key] = {\n  \t\t\t\t\t\torigin: component.root.viewmodel,\n  \t\t\t\t\t\tkeypath: undefined\n  \t\t\t\t\t};\n\n  \t\t\t\t\tresolver = createResolver(component, attribute[0], function (keypath) {\n  \t\t\t\t\t\tif (keypath.isSpecial) {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.set(key, keypath.value); // TODO use viewmodel?\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\tdata[key] = keypath.value;\n\n  \t\t\t\t\t\t\t\t// TODO errr.... would be better if we didn't have to do this\n  \t\t\t\t\t\t\t\tdelete mappings[key];\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\t\tinstance.viewmodel.mappings[key].resolve(keypath);\n  \t\t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\t\t// resolved immediately\n  \t\t\t\t\t\t\t\tmappings[key].keypath = keypath;\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t} else {\n  \t\t\t\t\tresolver = new initialise_ComplexParameter(component, attribute, function (value) {\n  \t\t\t\t\t\tif (ready) {\n  \t\t\t\t\t\t\tinstance.set(key, value); // TODO use viewmodel?\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tdata[key] = value;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t});\n  \t\t\t\t}\n\n  \t\t\t\tresolvers.push(resolver);\n  \t\t\t} else {\n  \t\t\t\tthrow new Error(\"erm wut\");\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tinstance = create(Component.prototype);\n\n  \tinitialise(instance, {\n  \t\tel: null,\n  \t\tappend: true,\n  \t\tdata: data,\n  \t\tpartials: partials,\n  \t\tmagic: ractive.magic || Component.defaults.magic,\n  \t\tmodifyArrays: ractive.modifyArrays,\n  \t\t// need to inherit runtime parent adaptors\n  \t\tadapt: ractive.adapt\n  \t}, {\n  \t\tparent: ractive,\n  \t\tcomponent: component,\n  \t\tcontainer: container,\n  \t\tmappings: mappings,\n  \t\tinlinePartials: inlinePartials,\n  \t\tcssIds: parentFragment.cssIds\n  \t});\n\n  \tready = true;\n  \tcomponent.resolvers = resolvers;\n\n  \treturn instance;\n  };\n\n  function createResolver(component, template, callback) {\n  \tvar resolver;\n\n  \tif (template.r) {\n  \t\tresolver = Resolvers_createReferenceResolver(component, template.r, callback);\n  \t} else if (template.x) {\n  \t\tresolver = new Resolvers_ExpressionResolver(component, component.parentFragment, template.x, callback);\n  \t} else if (template.rx) {\n  \t\tresolver = new ReferenceExpressionResolver_ReferenceExpressionResolver(component, template.rx, callback);\n  \t}\n\n  \treturn resolver;\n  }\n\n  function isSingleInterpolator(template) {\n  \treturn template.length === 1 && template[0].t === INTERPOLATOR;\n  }\n\n  // TODO how should event arguments be handled? e.g.\n  // <widget on-foo='bar:1,2,3'/>\n  // The event 'bar' will be fired on the parent instance\n  // when 'foo' fires on the child, but the 1,2,3 arguments\n  // will be lost\n\n  var initialise_propagateEvents = propagateEvents;\n\n  function propagateEvents(component, eventsDescriptor) {\n  \tvar eventName;\n\n  \tfor (eventName in eventsDescriptor) {\n  \t\tif (eventsDescriptor.hasOwnProperty(eventName)) {\n  \t\t\tpropagateEvent(component.instance, component.root, eventName, eventsDescriptor[eventName]);\n  \t\t}\n  \t}\n  }\n\n  function propagateEvent(childInstance, parentInstance, eventName, proxyEventName) {\n  \tif (typeof proxyEventName !== \"string\") {\n  \t\tfatal(\"Components currently only support simple events - you cannot include arguments. Sorry!\");\n  \t}\n\n  \tchildInstance.on(eventName, function () {\n  \t\tvar event, args;\n\n  \t\t// semi-weak test, but what else? tag the event obj ._isEvent ?\n  \t\tif (arguments.length && arguments[0] && arguments[0].node) {\n  \t\t\tevent = Array.prototype.shift.call(arguments);\n  \t\t}\n\n  \t\targs = Array.prototype.slice.call(arguments);\n\n  \t\tshared_fireEvent(parentInstance, proxyEventName, { event: event, args: args });\n\n  \t\t// cancel bubbling\n  \t\treturn false;\n  \t});\n  }\n\n  var initialise_updateLiveQueries = function (component) {\n  \tvar ancestor, query;\n\n  \t// If there's a live query for this component type, add it\n  \tancestor = component.root;\n  \twhile (ancestor) {\n  \t\tif (query = ancestor._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery.push(component.instance);\n  \t\t}\n\n  \t\tancestor = ancestor.parent;\n  \t}\n  };\n\n  var Component_prototype_init = Component$init;\n  function Component$init(options, Component) {\n  \tvar parentFragment, root;\n\n  \tif (!Component) {\n  \t\tthrow new Error(\"Component \\\"\" + this.name + \"\\\" not found\");\n  \t}\n\n  \tparentFragment = this.parentFragment = options.parentFragment;\n  \troot = parentFragment.root;\n\n  \tthis.root = root;\n  \tthis.type = COMPONENT;\n  \tthis.name = options.template.e;\n  \tthis.index = options.index;\n  \tthis.indexRefBindings = {};\n  \tthis.yielders = {};\n  \tthis.resolvers = [];\n\n  \tcreateInstance(this, Component, options.template.a, options.template.f, options.template.p);\n  \tinitialise_propagateEvents(this, options.template.v);\n\n  \t// intro, outro and decorator directives have no effect\n  \tif (options.template.t0 || options.template.t1 || options.template.t2 || options.template.o) {\n  \t\twarnIfDebug(\"The \\\"intro\\\", \\\"outro\\\" and \\\"decorator\\\" directives have no effect on components\", { ractive: this.instance });\n  \t}\n\n  \tinitialise_updateLiveQueries(this);\n  }\n\n  var Component_prototype_rebind = Component$rebind;\n\n  function Component$rebind(oldKeypath, newKeypath) {\n  \tvar query;\n\n  \tthis.resolvers.forEach(rebind);\n\n  \tfor (var k in this.yielders) {\n  \t\tif (this.yielders[k][0]) {\n  \t\t\trebind(this.yielders[k][0]);\n  \t\t}\n  \t}\n\n  \tif (query = this.root._liveComponentQueries[\"_\" + this.name]) {\n  \t\tquery._makeDirty();\n  \t}\n\n  \tfunction rebind(x) {\n  \t\tx.rebind(oldKeypath, newKeypath);\n  \t}\n  }\n\n  var Component_prototype_render = Component$render;\n\n  function Component$render() {\n  \tvar instance = this.instance;\n\n  \tinstance.render(this.parentFragment.getNode());\n\n  \tthis.rendered = true;\n  \treturn instance.fragment.detach();\n  }\n\n  var Component_prototype_toString = Component$toString;\n\n  function Component$toString() {\n  \treturn this.instance.fragment.toString();\n  }\n\n  var Component_prototype_unbind = Component$unbind;\n\n  var Component_prototype_unbind__teardownHook = new hooks_Hook(\"teardown\");\n  function Component$unbind() {\n  \tvar instance = this.instance;\n\n  \tthis.resolvers.forEach(methodCallers__unbind);\n\n  \tremoveFromLiveComponentQueries(this);\n\n  \tinstance._observers.forEach(cancel);\n\n  \t// teardown the instance\n  \tinstance.fragment.unbind();\n  \tinstance.viewmodel.teardown();\n\n  \tif (instance.fragment.rendered && instance.el.__ractive_instances__) {\n  \t\tremoveFromArray(instance.el.__ractive_instances__, instance);\n  \t}\n\n  \tComponent_prototype_unbind__teardownHook.fire(instance);\n  }\n\n  function removeFromLiveComponentQueries(component) {\n  \tvar instance, query;\n\n  \tinstance = component.root;\n\n  \tdo {\n  \t\tif (query = instance._liveComponentQueries[\"_\" + component.name]) {\n  \t\t\tquery._remove(component);\n  \t\t}\n  \t} while (instance = instance.parent);\n  }\n\n  var Component_prototype_unrender = Component$unrender;\n\n  function Component$unrender(shouldDestroy) {\n  \tthis.shouldDestroy = shouldDestroy;\n  \tthis.instance.unrender();\n  }\n\n  var Component = function (options, Constructor) {\n  \tthis.init(options, Constructor);\n  };\n\n  Component.prototype = {\n  \tdetach: Component_prototype_detach,\n  \tfind: Component_prototype_find,\n  \tfindAll: Component_prototype_findAll,\n  \tfindAllComponents: Component_prototype_findAllComponents,\n  \tfindComponent: Component_prototype_findComponent,\n  \tfindNextNode: Component_prototype_findNextNode,\n  \tfirstNode: Component_prototype_firstNode,\n  \tinit: Component_prototype_init,\n  \trebind: Component_prototype_rebind,\n  \trender: Component_prototype_render,\n  \ttoString: Component_prototype_toString,\n  \tunbind: Component_prototype_unbind,\n  \tunrender: Component_prototype_unrender\n  };\n\n  var _Component = Component;\n\n  var Comment = function (options) {\n  \tthis.type = COMMENT;\n  \tthis.value = options.template.c;\n  };\n\n  Comment.prototype = {\n  \tdetach: shared_detach,\n\n  \tfirstNode: function () {\n  \t\treturn this.node;\n  \t},\n\n  \trender: function () {\n  \t\tif (!this.node) {\n  \t\t\tthis.node = document.createComment(this.value);\n  \t\t}\n\n  \t\treturn this.node;\n  \t},\n\n  \ttoString: function () {\n  \t\treturn \"<!--\" + this.value + \"-->\";\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tif (shouldDestroy) {\n  \t\t\tthis.node.parentNode.removeChild(this.node);\n  \t\t}\n  \t}\n  };\n\n  var items_Comment = Comment;\n\n  var Yielder = function (options) {\n  \tvar container, component;\n\n  \tthis.type = YIELDER;\n\n  \tthis.container = container = options.parentFragment.root;\n  \tthis.component = component = container.component;\n\n  \tthis.container = container;\n  \tthis.containerFragment = options.parentFragment;\n  \tthis.parentFragment = component.parentFragment;\n\n  \tvar name = this.name = options.template.n || \"\";\n\n  \tvar template = container._inlinePartials[name];\n\n  \tif (!template) {\n  \t\twarnIfDebug(\"Could not find template for partial \\\"\" + name + \"\\\"\", { ractive: options.root });\n  \t\ttemplate = [];\n  \t}\n\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\towner: this,\n  \t\troot: container.parent,\n  \t\ttemplate: template,\n  \t\tpElement: this.containerFragment.pElement\n  \t});\n\n  \t// even though only one yielder is allowed, we need to have an array of them\n  \t// as it's possible to cause a yielder to be created before the last one\n  \t// was destroyed in the same turn of the runloop\n  \tif (!isArray(component.yielders[name])) {\n  \t\tcomponent.yielders[name] = [this];\n  \t} else {\n  \t\tcomponent.yielders[name].push(this);\n  \t}\n\n  \tglobal_runloop.scheduleTask(function () {\n  \t\tif (component.yielders[name].length > 1) {\n  \t\t\tthrow new Error(\"A component template can only have one {{yield\" + (name ? \" \" + name : \"\") + \"}} declaration at a time\");\n  \t\t}\n  \t});\n  };\n\n  Yielder.prototype = {\n  \tdetach: function () {\n  \t\treturn this.fragment.detach();\n  \t},\n\n  \tfind: function (selector) {\n  \t\treturn this.fragment.find(selector);\n  \t},\n\n  \tfindAll: function (selector, query) {\n  \t\treturn this.fragment.findAll(selector, query);\n  \t},\n\n  \tfindComponent: function (selector) {\n  \t\treturn this.fragment.findComponent(selector);\n  \t},\n\n  \tfindAllComponents: function (selector, query) {\n  \t\treturn this.fragment.findAllComponents(selector, query);\n  \t},\n\n  \tfindNextNode: function () {\n  \t\treturn this.containerFragment.findNextNode(this);\n  \t},\n\n  \tfirstNode: function () {\n  \t\treturn this.fragment.firstNode();\n  \t},\n\n  \tgetValue: function (options) {\n  \t\treturn this.fragment.getValue(options);\n  \t},\n\n  \trender: function () {\n  \t\treturn this.fragment.render();\n  \t},\n\n  \tunbind: function () {\n  \t\tthis.fragment.unbind();\n  \t},\n\n  \tunrender: function (shouldDestroy) {\n  \t\tthis.fragment.unrender(shouldDestroy);\n  \t\tremoveFromArray(this.component.yielders[this.name], this);\n  \t},\n\n  \trebind: function (oldKeypath, newKeypath) {\n  \t\tthis.fragment.rebind(oldKeypath, newKeypath);\n  \t},\n\n  \ttoString: function () {\n  \t\treturn this.fragment.toString();\n  \t}\n  };\n\n  var items_Yielder = Yielder;\n\n  var Doctype = function (options) {\n  \tthis.declaration = options.template.a;\n  };\n\n  Doctype.prototype = {\n  \tinit: noop,\n  \trender: noop,\n  \tunrender: noop,\n  \tteardown: noop,\n  \ttoString: function () {\n  \t\treturn \"<!DOCTYPE\" + this.declaration + \">\";\n  \t}\n  };\n\n  var items_Doctype = Doctype;\n\n  var Fragment_prototype_init = Fragment$init;\n\n  function Fragment$init(options) {\n  \tvar _this = this;\n\n  \tthis.owner = options.owner; // The item that owns this fragment - an element, section, partial, or attribute\n  \tthis.parent = this.owner.parentFragment;\n\n  \t// inherited properties\n  \tthis.root = options.root;\n  \tthis.pElement = options.pElement;\n  \tthis.context = options.context;\n  \tthis.index = options.index;\n  \tthis.key = options.key;\n  \tthis.registeredIndexRefs = [];\n\n  \t// encapsulated styles should be inherited until they get applied by an element\n  \tthis.cssIds = \"cssIds\" in options ? options.cssIds : this.parent ? this.parent.cssIds : null;\n\n  \tthis.items = options.template.map(function (template, i) {\n  \t\treturn createItem({\n  \t\t\tparentFragment: _this,\n  \t\t\tpElement: options.pElement,\n  \t\t\ttemplate: template,\n  \t\t\tindex: i\n  \t\t});\n  \t});\n\n  \tthis.value = this.argsList = null;\n  \tthis.dirtyArgs = this.dirtyValue = true;\n\n  \tthis.bound = true;\n  }\n\n  function createItem(options) {\n  \tif (typeof options.template === \"string\") {\n  \t\treturn new items_Text(options);\n  \t}\n\n  \tswitch (options.template.t) {\n  \t\tcase YIELDER:\n  \t\t\treturn new items_Yielder(options);\n  \t\tcase INTERPOLATOR:\n  \t\t\treturn new items_Interpolator(options);\n  \t\tcase SECTION:\n  \t\t\treturn new _Section(options);\n  \t\tcase TRIPLE:\n  \t\t\treturn new _Triple(options);\n  \t\tcase ELEMENT:\n  \t\t\tvar constructor = undefined;\n  \t\t\tif (constructor = Component_getComponent(options.parentFragment.root, options.template.e)) {\n  \t\t\t\treturn new _Component(options, constructor);\n  \t\t\t}\n  \t\t\treturn new _Element(options);\n  \t\tcase PARTIAL:\n  \t\t\treturn new _Partial(options);\n  \t\tcase COMMENT:\n  \t\t\treturn new items_Comment(options);\n  \t\tcase DOCTYPE:\n  \t\t\treturn new items_Doctype(options);\n\n  \t\tdefault:\n  \t\t\tthrow new Error(\"Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!\");\n  \t}\n  }\n\n  var Fragment_prototype_rebind = Fragment$rebind;\n  function Fragment$rebind(oldKeypath, newKeypath) {\n\n  \t// assign new context keypath if needed\n  \tif (!this.owner || this.owner.hasContext) {\n  \t\tassignNewKeypath(this, \"context\", oldKeypath, newKeypath);\n  \t}\n\n  \tthis.items.forEach(function (item) {\n  \t\tif (item.rebind) {\n  \t\t\titem.rebind(oldKeypath, newKeypath);\n  \t\t}\n  \t});\n  }\n\n  var Fragment_prototype_render = Fragment$render;\n\n  function Fragment$render() {\n  \tvar result;\n\n  \tif (this.items.length === 1) {\n  \t\tresult = this.items[0].render();\n  \t} else {\n  \t\tresult = document.createDocumentFragment();\n\n  \t\tthis.items.forEach(function (item) {\n  \t\t\tresult.appendChild(item.render());\n  \t\t});\n  \t}\n\n  \tthis.rendered = true;\n  \treturn result;\n  }\n\n  var Fragment_prototype_toString = Fragment$toString;\n\n  function Fragment$toString(escape) {\n  \tif (!this.items) {\n  \t\treturn \"\";\n  \t}\n\n  \treturn this.items.map(escape ? toEscapedString : Fragment_prototype_toString__toString).join(\"\");\n  }\n\n  function Fragment_prototype_toString__toString(item) {\n  \treturn item.toString();\n  }\n\n  function toEscapedString(item) {\n  \treturn item.toString(true);\n  }\n\n  var Fragment_prototype_unbind = Fragment$unbind;\n\n  function Fragment$unbind() {\n  \tif (!this.bound) {\n  \t\treturn;\n  \t}\n\n  \tthis.items.forEach(unbindItem);\n  \tthis.bound = false;\n  }\n\n  function unbindItem(item) {\n  \tif (item.unbind) {\n  \t\titem.unbind();\n  \t}\n  }\n\n  var Fragment_prototype_unrender = Fragment$unrender;\n\n  function Fragment$unrender(shouldDestroy) {\n  \tif (!this.rendered) {\n  \t\tthrow new Error(\"Attempted to unrender a fragment that was not rendered\");\n  \t}\n\n  \tthis.items.forEach(function (i) {\n  \t\treturn i.unrender(shouldDestroy);\n  \t});\n  \tthis.rendered = false;\n  }\n\n  var Fragment = function (options) {\n  \tthis.init(options);\n  };\n\n  Fragment.prototype = {\n  \tbubble: prototype_bubble,\n  \tdetach: Fragment_prototype_detach,\n  \tfind: Fragment_prototype_find,\n  \tfindAll: Fragment_prototype_findAll,\n  \tfindAllComponents: Fragment_prototype_findAllComponents,\n  \tfindComponent: Fragment_prototype_findComponent,\n  \tfindNextNode: prototype_findNextNode,\n  \tfirstNode: prototype_firstNode,\n  \tgetArgsList: getArgsList,\n  \tgetNode: getNode,\n  \tgetValue: prototype_getValue,\n  \tinit: Fragment_prototype_init,\n  \trebind: Fragment_prototype_rebind,\n  \tregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tif (idxs.indexOf(idx) === -1) {\n  \t\t\tidxs.push(idx);\n  \t\t}\n  \t},\n  \trender: Fragment_prototype_render,\n  \ttoString: Fragment_prototype_toString,\n  \tunbind: Fragment_prototype_unbind,\n  \tunregisterIndexRef: function (idx) {\n  \t\tvar idxs = this.registeredIndexRefs;\n  \t\tidxs.splice(idxs.indexOf(idx), 1);\n  \t},\n  \tunrender: Fragment_prototype_unrender\n  };\n\n  var virtualdom_Fragment = Fragment;\n\n  var prototype_reset = Ractive$reset;\n  var shouldRerender = [\"template\", \"partials\", \"components\", \"decorators\", \"events\"],\n      resetHook = new hooks_Hook(\"reset\");\n  function Ractive$reset(data) {\n  \tvar promise, wrapper, changes, i, rerender;\n\n  \tdata = data || {};\n\n  \tif (typeof data !== \"object\") {\n  \t\tthrow new Error(\"The reset method takes either no arguments, or an object containing new data\");\n  \t}\n\n  \t// If the root object is wrapped, try and use the wrapper's reset value\n  \tif ((wrapper = this.viewmodel.wrapped[\"\"]) && wrapper.reset) {\n  \t\tif (wrapper.reset(data) === false) {\n  \t\t\t// reset was rejected, we need to replace the object\n  \t\t\tthis.viewmodel.reset(data);\n  \t\t}\n  \t} else {\n  \t\tthis.viewmodel.reset(data);\n  \t}\n\n  \t// reset config items and track if need to rerender\n  \tchanges = config_config.reset(this);\n\n  \ti = changes.length;\n  \twhile (i--) {\n  \t\tif (shouldRerender.indexOf(changes[i]) > -1) {\n  \t\t\trerender = true;\n  \t\t\tbreak;\n  \t\t}\n  \t}\n\n  \tif (rerender) {\n  \t\tvar component = undefined;\n\n  \t\tthis.viewmodel.mark(rootKeypath);\n\n  \t\t// Is this is a component, we need to set the `shouldDestroy`\n  \t\t// flag, otherwise it will assume by default that a parent node\n  \t\t// will be detached, and therefore it doesn't need to bother\n  \t\t// detaching its own nodes\n  \t\tif (component = this.component) {\n  \t\t\tcomponent.shouldDestroy = true;\n  \t\t}\n\n  \t\tthis.unrender();\n\n  \t\tif (component) {\n  \t\t\tcomponent.shouldDestroy = false;\n  \t\t}\n\n  \t\t// If the template changed, we need to destroy the parallel DOM\n  \t\t// TODO if we're here, presumably it did?\n  \t\tif (this.fragment.template !== this.template) {\n  \t\t\tthis.fragment.unbind();\n\n  \t\t\tthis.fragment = new virtualdom_Fragment({\n  \t\t\t\ttemplate: this.template,\n  \t\t\t\troot: this,\n  \t\t\t\towner: this\n  \t\t\t});\n  \t\t}\n\n  \t\tpromise = this.render(this.el, this.anchor);\n  \t} else {\n  \t\tpromise = global_runloop.start(this, true);\n  \t\tthis.viewmodel.mark(rootKeypath);\n  \t\tglobal_runloop.end();\n  \t}\n\n  \tresetHook.fire(this, data);\n\n  \treturn promise;\n  }\n\n  var resetPartial = function (name, partial) {\n  \tvar promise,\n  \t    collection = [];\n\n  \tfunction collect(source, dest, ractive) {\n  \t\t// if this is a component and it has its own partial, bail\n  \t\tif (ractive && ractive.partials[name]) return;\n\n  \t\tsource.forEach(function (item) {\n  \t\t\t// queue to rerender if the item is a partial and the current name matches\n  \t\t\tif (item.type === PARTIAL && item.getPartialName() === name) {\n  \t\t\t\tdest.push(item);\n  \t\t\t}\n\n  \t\t\t// if it has a fragment, process its items\n  \t\t\tif (item.fragment) {\n  \t\t\t\tcollect(item.fragment.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it has fragments\n  \t\t\tif (isArray(item.fragments)) {\n  \t\t\t\tcollect(item.fragments, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is itself a fragment, process its items\n  \t\t\telse if (isArray(item.items)) {\n  \t\t\t\tcollect(item.items, dest, ractive);\n  \t\t\t}\n\n  \t\t\t// or if it is a component, step in and process its items\n  \t\t\telse if (item.type === COMPONENT && item.instance) {\n  \t\t\t\tcollect(item.instance.fragment.items, dest, item.instance);\n  \t\t\t}\n\n  \t\t\t// if the item is an element, process its attributes too\n  \t\t\tif (item.type === ELEMENT) {\n  \t\t\t\tif (isArray(item.attributes)) {\n  \t\t\t\t\tcollect(item.attributes, dest, ractive);\n  \t\t\t\t}\n\n  \t\t\t\tif (isArray(item.conditionalAttributes)) {\n  \t\t\t\t\tcollect(item.conditionalAttributes, dest, ractive);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \tcollect(this.fragment.items, collection);\n  \tthis.partials[name] = partial;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \tcollection.forEach(function (item) {\n  \t\titem.value = undefined;\n  \t\titem.setValue(name);\n  \t});\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  };\n\n  // TODO should resetTemplate be asynchronous? i.e. should it be a case\n  // of outro, update template, intro? I reckon probably not, since that\n  // could be achieved with unrender-resetTemplate-render. Also, it should\n  // conceptually be similar to resetPartial, which couldn't be async\n\n  var resetTemplate = Ractive$resetTemplate;\n  function Ractive$resetTemplate(template) {\n  \tvar transitionsEnabled, component;\n\n  \ttemplate_template.init(null, this, { template: template });\n\n  \ttransitionsEnabled = this.transitionsEnabled;\n  \tthis.transitionsEnabled = false;\n\n  \t// Is this is a component, we need to set the `shouldDestroy`\n  \t// flag, otherwise it will assume by default that a parent node\n  \t// will be detached, and therefore it doesn't need to bother\n  \t// detaching its own nodes\n  \tif (component = this.component) {\n  \t\tcomponent.shouldDestroy = true;\n  \t}\n\n  \tthis.unrender();\n\n  \tif (component) {\n  \t\tcomponent.shouldDestroy = false;\n  \t}\n\n  \t// remove existing fragment and create new one\n  \tthis.fragment.unbind();\n  \tthis.fragment = new virtualdom_Fragment({\n  \t\ttemplate: this.template,\n  \t\troot: this,\n  \t\towner: this\n  \t});\n\n  \tthis.render(this.el, this.anchor);\n\n  \tthis.transitionsEnabled = transitionsEnabled;\n  }\n\n  var reverse = makeArrayMethod(\"reverse\");\n\n  var Ractive_prototype_set = Ractive$set;\n\n  function Ractive$set(keypath, value) {\n  \tvar map, promise;\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// Set multiple keypaths in one go\n  \tif (isObject(keypath)) {\n  \t\tmap = keypath;\n\n  \t\tfor (keypath in map) {\n  \t\t\tif (map.hasOwnProperty(keypath)) {\n  \t\t\t\tvalue = map[keypath];\n  \t\t\t\tset(this, keypath, value);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \t// Set a single keypath\n  \telse {\n  \t\tset(this, keypath, value);\n  \t}\n\n  \tglobal_runloop.end();\n\n  \treturn promise;\n  }\n\n  function set(ractive, keypath, value) {\n  \tkeypath = getKeypath(normalise(keypath));\n\n  \tif (keypath.isPattern) {\n  \t\tgetMatchingKeypaths(ractive, keypath).forEach(function (keypath) {\n  \t\t\tractive.viewmodel.set(keypath, value);\n  \t\t});\n  \t} else {\n  \t\tractive.viewmodel.set(keypath, value);\n  \t}\n  }\n\n  var shift = makeArrayMethod(\"shift\");\n\n  var prototype_sort = makeArrayMethod(\"sort\");\n\n  var splice = makeArrayMethod(\"splice\");\n\n  var subtract = Ractive$subtract;\n  function Ractive$subtract(keypath, d) {\n  \treturn shared_add(this, keypath, d === undefined ? -1 : -d);\n  }\n\n  // Teardown. This goes through the root fragment and all its children, removing observers\n  // and generally cleaning up after itself\n\n  var Ractive_prototype_teardown = Ractive$teardown;\n\n  var Ractive_prototype_teardown__teardownHook = new hooks_Hook(\"teardown\");\n  function Ractive$teardown() {\n  \tvar promise;\n\n  \tthis.fragment.unbind();\n  \tthis.viewmodel.teardown();\n\n  \tthis._observers.forEach(cancel);\n\n  \tif (this.fragment.rendered && this.el.__ractive_instances__) {\n  \t\tremoveFromArray(this.el.__ractive_instances__, this);\n  \t}\n\n  \tthis.shouldDestroy = true;\n  \tpromise = this.fragment.rendered ? this.unrender() : utils_Promise.resolve();\n\n  \tRactive_prototype_teardown__teardownHook.fire(this);\n\n  \tthis._boundFunctions.forEach(deleteFunctionCopy);\n\n  \treturn promise;\n  }\n\n  function deleteFunctionCopy(bound) {\n  \tdelete bound.fn[bound.prop];\n  }\n\n  var toggle = Ractive$toggle;\n  function Ractive$toggle(keypath) {\n  \tvar _this = this;\n\n  \tif (typeof keypath !== \"string\") {\n  \t\tthrow new TypeError(badArguments);\n  \t}\n\n  \tvar changes = undefined;\n\n  \tif (/\\*/.test(keypath)) {\n  \t\tchanges = {};\n\n  \t\tgetMatchingKeypaths(this, getKeypath(normalise(keypath))).forEach(function (keypath) {\n  \t\t\tchanges[keypath.str] = !_this.viewmodel.get(keypath);\n  \t\t});\n\n  \t\treturn this.set(changes);\n  \t}\n\n  \treturn this.set(keypath, !this.get(keypath));\n  }\n\n  var toHTML = Ractive$toHTML;\n\n  function Ractive$toHTML() {\n  \treturn this.fragment.toString(true);\n  }\n\n  var Ractive_prototype_unrender = Ractive$unrender;\n  var unrenderHook = new hooks_Hook(\"unrender\");\n  function Ractive$unrender() {\n  \tvar promise, shouldDestroy;\n\n  \tif (!this.fragment.rendered) {\n  \t\twarnIfDebug(\"ractive.unrender() was called on a Ractive instance that was not rendered\");\n  \t\treturn utils_Promise.resolve();\n  \t}\n\n  \tpromise = global_runloop.start(this, true);\n\n  \t// If this is a component, and the component isn't marked for destruction,\n  \t// don't detach nodes from the DOM unnecessarily\n  \tshouldDestroy = !this.component || this.component.shouldDestroy || this.shouldDestroy;\n\n  \t// Cancel any animations in progress\n  \twhile (this._animations[0]) {\n  \t\tthis._animations[0].stop(); // it will remove itself from the index\n  \t}\n\n  \tthis.fragment.unrender(shouldDestroy);\n\n  \tremoveFromArray(this.el.__ractive_instances__, this);\n\n  \tunrenderHook.fire(this);\n\n  \tglobal_runloop.end();\n  \treturn promise;\n  }\n\n  var unshift = makeArrayMethod(\"unshift\");\n\n  var Ractive_prototype_update = Ractive$update;\n  var updateHook = new hooks_Hook(\"update\");\n  function Ractive$update(keypath) {\n  \tvar promise;\n\n  \tkeypath = getKeypath(keypath) || rootKeypath;\n\n  \tpromise = global_runloop.start(this, true);\n  \tthis.viewmodel.mark(keypath);\n  \tglobal_runloop.end();\n\n  \tupdateHook.fire(this, keypath);\n\n  \treturn promise;\n  }\n\n  var prototype_updateModel = Ractive$updateModel;\n\n  function Ractive$updateModel(keypath, cascade) {\n  \tvar values, key, bindings;\n\n  \tif (typeof keypath === \"string\" && !cascade) {\n  \t\tbindings = this._twowayBindings[keypath];\n  \t} else {\n  \t\tbindings = [];\n\n  \t\tfor (key in this._twowayBindings) {\n  \t\t\tif (!keypath || getKeypath(key).equalsOrStartsWith(keypath)) {\n  \t\t\t\t// TODO is this right?\n  \t\t\t\tbindings.push.apply(bindings, this._twowayBindings[key]);\n  \t\t\t}\n  \t\t}\n  \t}\n\n  \tvalues = consolidate(this, bindings);\n  \treturn this.set(values);\n  }\n\n  function consolidate(ractive, bindings) {\n  \tvar values = {},\n  \t    checkboxGroups = [];\n\n  \tbindings.forEach(function (b) {\n  \t\tvar oldValue, newValue;\n\n  \t\t// special case - radio name bindings\n  \t\tif (b.radioName && !b.element.node.checked) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// special case - checkbox name bindings come in groups, so\n  \t\t// we want to get the value once at most\n  \t\tif (b.checkboxName) {\n  \t\t\tif (!checkboxGroups[b.keypath.str] && !b.changed()) {\n  \t\t\t\tcheckboxGroups.push(b.keypath);\n  \t\t\t\tcheckboxGroups[b.keypath.str] = b;\n  \t\t\t}\n\n  \t\t\treturn;\n  \t\t}\n\n  \t\toldValue = b.attribute.value;\n  \t\tnewValue = b.getValue();\n\n  \t\tif (arrayContentsMatch(oldValue, newValue)) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (!isEqual(oldValue, newValue)) {\n  \t\t\tvalues[b.keypath.str] = newValue;\n  \t\t}\n  \t});\n\n  \t// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`\n  \tif (checkboxGroups.length) {\n  \t\tcheckboxGroups.forEach(function (keypath) {\n  \t\t\tvar binding, oldValue, newValue;\n\n  \t\t\tbinding = checkboxGroups[keypath.str]; // one to represent the entire group\n  \t\t\toldValue = binding.attribute.value;\n  \t\t\tnewValue = binding.getValue();\n\n  \t\t\tif (!arrayContentsMatch(oldValue, newValue)) {\n  \t\t\t\tvalues[keypath.str] = newValue;\n  \t\t\t}\n  \t\t});\n  \t}\n\n  \treturn values;\n  }\n\n  var prototype = {\n  \tadd: prototype_add,\n  \tanimate: prototype_animate,\n  \tdetach: prototype_detach,\n  \tfind: prototype_find,\n  \tfindAll: prototype_findAll,\n  \tfindAllComponents: prototype_findAllComponents,\n  \tfindComponent: prototype_findComponent,\n  \tfindContainer: findContainer,\n  \tfindParent: findParent,\n  \tfire: prototype_fire,\n  \tget: prototype_get,\n  \tinsert: insert,\n  \tmerge: prototype_merge,\n  \tobserve: observe,\n  \tobserveOnce: observeOnce,\n  \toff: off,\n  \ton: on,\n  \tonce: once,\n  \tpop: pop,\n  \tpush: push,\n  \trender: prototype_render,\n  \treset: prototype_reset,\n  \tresetPartial: resetPartial,\n  \tresetTemplate: resetTemplate,\n  \treverse: reverse,\n  \tset: Ractive_prototype_set,\n  \tshift: shift,\n  \tsort: prototype_sort,\n  \tsplice: splice,\n  \tsubtract: subtract,\n  \tteardown: Ractive_prototype_teardown,\n  \ttoggle: toggle,\n  \ttoHTML: toHTML,\n  \ttoHtml: toHTML,\n  \tunrender: Ractive_prototype_unrender,\n  \tunshift: unshift,\n  \tupdate: Ractive_prototype_update,\n  \tupdateModel: prototype_updateModel\n  };\n\n  var wrapMethod = function (method, superMethod, force) {\n\n  \tif (force || needsSuper(method, superMethod)) {\n\n  \t\treturn function () {\n\n  \t\t\tvar hasSuper = (\"_super\" in this),\n  \t\t\t    _super = this._super,\n  \t\t\t    result;\n\n  \t\t\tthis._super = superMethod;\n\n  \t\t\tresult = method.apply(this, arguments);\n\n  \t\t\tif (hasSuper) {\n  \t\t\t\tthis._super = _super;\n  \t\t\t}\n\n  \t\t\treturn result;\n  \t\t};\n  \t} else {\n  \t\treturn method;\n  \t}\n  };\n\n  function needsSuper(method, superMethod) {\n  \treturn typeof superMethod === \"function\" && /_super/.test(method);\n  }\n\n  var unwrapExtended = unwrap;\n\n  function unwrap(Child) {\n  \tvar options = {};\n\n  \twhile (Child) {\n  \t\taddRegistries(Child, options);\n  \t\taddOtherOptions(Child, options);\n\n  \t\tif (Child._Parent !== _Ractive) {\n  \t\t\tChild = Child._Parent;\n  \t\t} else {\n  \t\t\tChild = false;\n  \t\t}\n  \t}\n\n  \treturn options;\n  }\n\n  function addRegistries(Child, options) {\n  \tconfig_registries.forEach(function (r) {\n  \t\taddRegistry(r.useDefaults ? Child.prototype : Child, options, r.name);\n  \t});\n  }\n\n  function addRegistry(target, options, name) {\n  \tvar registry,\n  \t    keys = Object.keys(target[name]);\n\n  \tif (!keys.length) {\n  \t\treturn;\n  \t}\n\n  \tif (!(registry = options[name])) {\n  \t\tregistry = options[name] = {};\n  \t}\n\n  \tkeys.filter(function (key) {\n  \t\treturn !(key in registry);\n  \t}).forEach(function (key) {\n  \t\treturn registry[key] = target[name][key];\n  \t});\n  }\n\n  function addOtherOptions(Child, options) {\n  \tObject.keys(Child.prototype).forEach(function (key) {\n  \t\tif (key === \"computed\") {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tvar value = Child.prototype[key];\n\n  \t\tif (!(key in options)) {\n  \t\t\toptions[key] = value._method ? value._method : value;\n  \t\t}\n\n  \t\t// is it a wrapped function?\n  \t\telse if (typeof options[key] === \"function\" && typeof value === \"function\" && options[key]._method) {\n\n  \t\t\tvar result = undefined,\n  \t\t\t    needsSuper = value._method;\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tvalue = value._method;\n  \t\t\t}\n\n  \t\t\t// rewrap bound directly to parent fn\n  \t\t\tresult = wrapMethod(options[key]._method, value);\n\n  \t\t\tif (needsSuper) {\n  \t\t\t\tresult._method = result;\n  \t\t\t}\n\n  \t\t\toptions[key] = result;\n  \t\t}\n  \t});\n  }\n\n  var _extend = _extend__extend;\n\n  function _extend__extend() {\n  \tfor (var _len = arguments.length, options = Array(_len), _key = 0; _key < _len; _key++) {\n  \t\toptions[_key] = arguments[_key];\n  \t}\n\n  \tif (!options.length) {\n  \t\treturn extendOne(this);\n  \t} else {\n  \t\treturn options.reduce(extendOne, this);\n  \t}\n  }\n\n  function extendOne(Parent) {\n  \tvar options = arguments[1] === undefined ? {} : arguments[1];\n\n  \tvar Child, proto;\n\n  \t// if we're extending with another Ractive instance...\n  \t//\n  \t//   var Human = Ractive.extend(...), Spider = Ractive.extend(...);\n  \t//   var Spiderman = Human.extend( Spider );\n  \t//\n  \t// ...inherit prototype methods and default options as well\n  \tif (options.prototype instanceof _Ractive) {\n  \t\toptions = unwrapExtended(options);\n  \t}\n\n  \tChild = function (options) {\n  \t\tif (!(this instanceof Child)) return new Child(options);\n  \t\tinitialise(this, options);\n  \t};\n\n  \tproto = create(Parent.prototype);\n  \tproto.constructor = Child;\n\n  \t// Static properties\n  \tdefineProperties(Child, {\n  \t\t// alias prototype as defaults\n  \t\tdefaults: { value: proto },\n\n  \t\t// extendable\n  \t\textend: { value: _extend__extend, writable: true, configurable: true },\n\n  \t\t// Parent - for IE8, can't use Object.getPrototypeOf\n  \t\t_Parent: { value: Parent }\n  \t});\n\n  \t// extend configuration\n  \tconfig_config.extend(Parent, proto, options);\n\n  \tcustom_data.extend(Parent, proto, options);\n\n  \tif (options.computed) {\n  \t\tproto.computed = utils_object__extend(create(Parent.prototype.computed), options.computed);\n  \t}\n\n  \tChild.prototype = proto;\n\n  \treturn Child;\n  }\n\n  var getNodeInfo = function (node) {\n  \tvar info = {},\n  \t    priv,\n  \t    indices;\n\n  \tif (!node || !(priv = node._ractive)) {\n  \t\treturn info;\n  \t}\n\n  \tinfo.ractive = priv.root;\n  \tinfo.keypath = priv.keypath.str;\n  \tinfo.index = {};\n\n  \t// find all index references and resolve them\n  \tif (indices = Resolvers_findIndexRefs(priv.proxy.parentFragment)) {\n  \t\tinfo.index = Resolvers_findIndexRefs.resolve(indices);\n  \t}\n\n  \treturn info;\n  };\n\n  var Ractive, properties;\n\n  // Main Ractive required object\n  Ractive = function (options) {\n  \tif (!(this instanceof Ractive)) return new Ractive(options);\n  \tinitialise(this, options);\n  };\n\n  // Ractive properties\n  properties = {\n\n  \t// debug flag\n  \tDEBUG: { writable: true, value: true },\n  \tDEBUG_PROMISES: { writable: true, value: true },\n\n  \t// static methods:\n  \textend: { value: _extend },\n  \tgetNodeInfo: { value: getNodeInfo },\n  \tparse: { value: _parse },\n\n  \t// Namespaced constructors\n  \tPromise: { value: utils_Promise },\n\n  \t// support\n  \tsvg: { value: svg },\n  \tmagic: { value: environment__magic },\n\n  \t// version\n  \tVERSION: { value: \"0.7.3\" },\n\n  \t// Plugins\n  \tadaptors: { writable: true, value: {} },\n  \tcomponents: { writable: true, value: {} },\n  \tdecorators: { writable: true, value: {} },\n  \teasing: { writable: true, value: static_easing },\n  \tevents: { writable: true, value: {} },\n  \tinterpolators: { writable: true, value: static_interpolators },\n  \tpartials: { writable: true, value: {} },\n  \ttransitions: { writable: true, value: {} }\n  };\n\n  // Ractive properties\n  defineProperties(Ractive, properties);\n\n  Ractive.prototype = utils_object__extend(prototype, config_defaults);\n\n  Ractive.prototype.constructor = Ractive;\n\n  // alias prototype as defaults\n  Ractive.defaults = Ractive.prototype;\n\n  // Ractive.js makes liberal use of things like Array.prototype.indexOf. In\n  // older browsers, these are made available via a shim - here, we do a quick\n  // pre-flight check to make sure that either a) we're not in a shit browser,\n  // or b) we're using a Ractive-legacy.js build\n  var FUNCTION = \"function\";\n\n  if (typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== \"undefined\" && typeof window.addEventListener !== FUNCTION) {\n  \tthrow new Error(\"It looks like you're attempting to use Ractive.js in an older browser. You'll need to use one of the 'legacy builds' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.\");\n  }\n\n  var _Ractive = Ractive;\n\n  return _Ractive;\n\n}));\n//# sourceMappingURL=ractive.js.map\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ractive/ractive.js\n ** module id = 46\n ** module chunks = 1\n **/","module.exports = \"<div class=\\\"container fixed-header\\\"><div class=\\\"col-xs-12\\\">  {{>resolveComponent( \\\"Header\\\",        {state: \\\"state\\\"}) }}</div></div><div class=\\\"after-fixed\\\"></div><div class=\\\"fluid-container fixed-menu\\\"><div class=\\\"col-xs-12\\\">  {{>resolveComponent( \\\"TopMenu\\\",       {state: \\\"state\\\", search_input: \\\"search_input\\\" }) }}</div></div><div class=\\\"after-fixed\\\"></div><div class=\\\"fluid-container\\\"><div class=\\\"col-xs-12\\\">  {{>resolveComponent( \\\"MainContainer\\\", {state: \\\"state\\\"}) }}</div></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/Layout.ractive.jade\n ** module id = 48\n ** module chunks = 1\n **/","module.exports = \"<div class=\\\"col-xs-2\\\"><div class=\\\"fixed-sidebar\\\">Builder sidebar here<br>{{search_input}}</div><div class=\\\"after-fixed\\\"></div></div><div class=\\\"col-xs-10\\\"><p>TBD</p></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Builder/Builder.ractive.jade\n ** module id = 49\n ** module chunks = 1\n **/","module.exports = \"<div class=\\\"col-xs-12 col-sm-2\\\"><div class=\\\"fixed-sidebar hidden-xs\\\"><div class=\\\"row\\\">{{#items}}<a href=\\\"/infrastructure/{{state.screen}}/{{.}}\\\" class=\\\"sidebar-item col-xs-10 {{condition(state.tab === ., 'active')}}\\\">{{this.replace(/([a-z])([A-Z])/g, \\\"$1 $2\\\")}}</a>{{/items}}</div></div><div class=\\\"after-fixed\\\"></div></div><div class=\\\"col-xs-10\\\">{{>TabPartial}}</div><div class=\\\"col-xs-10 pull-right\\\"><div class=\\\"page-header\\\"><div class=\\\"row\\\">{{#previous}} <div class=\\\"col-xs-2 pull-left text-left\\\"><a href=\\\"/infrastructure/{{state.screen}}/{{previous}}\\\" class=\\\"btn btn-default\\\">{{previous.replace(/([a-z])([A-Z])/g, \\\"$1 $2\\\")}}</a></div>{{/previous}} \\n{{#next}}<div class=\\\"col-xs-2 pull-right text-right\\\"><a href=\\\"/infrastructure/{{state.screen}}/{{next}}\\\" class=\\\"btn btn-default\\\">{{next.replace(/([a-z])([A-Z])/g, \\\"$1 $2\\\")}}</a></div>{{/next}}</div></div></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/Docs.ractive.jade\n ** module id = 50\n ** module chunks = 1\n **/","module.exports = \"\\n\\n<div class=\\\"page-header\\\"><h1>Setup</h1></div><div class=\\\"page-header\\\"><h2>Installation</h2></div><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(setup_1.cli || !setup_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('setup_1.cli', true)\\\">command line</a></li><li class=\\\"{{condition(setup_1.package, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('setup_1.package', true)\\\">package.json</a></li></ul><div class=\\\"code-block medium {{condition(!setup_1.cli,  condition( setup_1.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-bash\\\">$> npm install infrastructure\\n</code></pre></div><div class=\\\"code-block medium {{condition(!setup_1.package, 'hide'  )}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"dependencies\\\": {\\n    \\\"infrastructure\\\": \\\"^1.1.0\\\"\\n  }  \\n}\\n</code></pre></div><p></p><div class=\\\"page-header\\\"><h2>Running</h2></div><p> \\nCreate <mark>app.js</mark> in project folder with following content, then run it. It should exit immediately without any messages, because there are no active workers.</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(setup_2.app_js || !setup_2.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('setup_2.app_js', true)\\\">app.js</a></li><li class=\\\"{{condition(setup_2.cli, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('setup_2.cli', true)\\\">command line</a></li></ul><div class=\\\"code-block medium {{condition(!setup_2.app_js,  condition( setup_2.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* configuration goes here */ }, function(err, env){\\n  if(err){\\n    throw err;\\n  }\\n});</code></pre></div><div class=\\\"code-block medium {{condition(!setup_2.cli, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app.js\\n$></code></pre></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i1_SetupApplication.ractive.jade\n ** module id = 51\n ** module chunks = 1\n **/","module.exports = \"\\n\\n<div class=\\\"page-header\\\"><h1>The Logger</h1></div><p>The logger is a built-in structure inside infrastructure application, so we need to define it in the config:</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(logger_1.app || !logger_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('logger_1.app', true)\\\">app.js</a></li><li class=\\\"{{condition(logger_1.cli, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('logger_1.cli', true)\\\">command line</a></li></ul><div class=\\\"code-block large {{condition(!logger_1.app,  condition( logger_1.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({\\n  structures: {\\n    log: {\\n      engine:  \\\"log\\\" ,\\n      options: { sys: true }\\n    }\\n  }\\n}, function(err, env) {\\n  if (err) {\\n    throw err;\\n  }\\n});\\n</code></pre></div><div class=\\\"code-block large {{condition(!logger_1.cli, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app.js\\n[sys]  [2015-11-08 21:40:37][logger]........................... options: sys\\n[sys]  [2015-11-08 21:40:37][application started].............. 30ms, process_mode: single, application mode: undefined\\n$>\\n</code></pre></div><p></p><p> \\nFirst - it's a <a href=\\\"/infrastructure/{{state.screen}}/Structures\\\"><mark>structure.</mark></a>It uses built-in engine, called <mark>log</mark>. Also, it's config has options. The <mark>options</mark> object represents which log types are turned on.\\nOnly <mark>sys </mark>option is used by the system to report some initialization stuff. \\nAny other option is custom. Let's create log type <mark>debug</mark>and use it to log some message.</p><p>The logger is a built-in structure inside infrastructure application, so we need to define it in the config:</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(logger_2.app || !logger_2.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('logger_2.app', true)\\\">app.js</a></li><li class=\\\"{{condition(logger_2.cli, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('logger_2.cli', true)\\\">command line</a></li></ul><iv class=\\\"code-block large {{condition(!logger_2.app,  condition( logger_2.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({\\n  structures: {\\n    log: {\\n      engine:  \\\"log\\\",\\n      options: { sys: true, debug: true }\\n    }\\n  }\\n}, function(err, env) {\\n  if (err) {\\n    throw err;\\n  }\\n  env.i.do(\\\"log.debug\\\", \\\"hello\\\", \\\"logger\\\");\\n});\\n</code></pre></iv><div class=\\\"code-block large {{condition(!logger_2.cli, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app.js\\n[sys]  [2015-11-08 21:42:53][logger]........................... options: sys, debug\\n[sys]  [2015-11-08 21:42:53][application started].............. 30ms, process_mode: single, application mode: undefined\\n[debug]  [2015-11-08 21:42:53][hello]............................ logger\\n$></code></pre></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i2_TheLogger.ractive.jade\n ** module id = 52\n ** module chunks = 1\n **/","module.exports = \"\\n<div class=\\\"page-header\\\"><h1>Configuration</h1></div><div class=\\\"page-header\\\"><h2>Let's expand our configuration</h2></div><p> \\nWe passed the configuration object. \\nBut <mark>infrastructure</mark> will try to find some files or folders in project root folder and will extend passed config.\\nPossible variants are:</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(configuration_1.app_js || !configuration_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.app_js', true)\\\">app.js</a></li><li class=\\\"{{condition(configuration_1.config_json, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.config_json', true)\\\">config.json</a></li><li class=\\\"{{condition(configuration_1.config_js, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.config_js', true)\\\">config.js</a></li><li class=\\\"{{condition(configuration_1.config_yml, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.config_yml', true)\\\">config.yml</a></li><li class=\\\"{{condition(configuration_1.config_folder, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.config_folder', true)\\\">config folder</a></li><li class=\\\"{{condition(configuration_1.command_line, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_1.command_line', true)\\\">command line</a></li></ul><div class=\\\"code-block large {{condition(!configuration_1.app_js,  condition( configuration_1.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n});</code></pre></div><div class=\\\"code-block large {{condition(!configuration_1.config_json, 'hide'  )}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"structures\\\": {\\n    \\\"log\\\": {\\n      \\\"engine\\\":  \\\"log\\\",\\n      \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n    }\\n  }\\n}</code></pre></div><div class=\\\"code-block large {{condition(!configuration_1.config_js, 'hide'  )}}\\\"><pre><code class=\\\"language-javascript\\\">module.exports = {\\n  structures: {\\n    log: {\\n      engine:  \\\"log\\\",\\n      options: { sys: true, debug: true }\\n    }\\n  }\\n};</code></pre></div><div class=\\\"code-block large {{condition(!configuration_1.config_yml, 'hide'  )}}\\\"><pre><code class=\\\"language-yaml\\\">---\\n  structures: \\n    log: \\n      engine: \\\"log\\\"\\n      options: \\n        sys: true\\n        debug: true</code></pre></div><div class=\\\"code-block large {{condition(!configuration_1.command_line, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app.js --config.structures.log.engine=log --config.structures.log.options.sys --config.structures.log.options.debug\\n</code></pre></div><div class=\\\"code-block large {{condition(!configuration_1.config_folder, 'hide'  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('conf_fs_1.app_js', true)\\\" class=\\\"fs-file {{condition( conf_fs_1.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('conf_fs_1.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( conf_fs_1.config_structures_log_json || !(conf_fs_1.__active), 'active')}}\\\">log.json</a></div></div></div><div class=\\\"col-xs-10 code-block large {{condition(!conf_fs_1.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!conf_fs_1.config_structures_log_json, condition(conf_fs_1.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engines\\\": [ \\\"log\\\" ],\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}\\n</code></pre></div></div><div class=\\\"page-header\\\"><h2>Application mode</h2></div><p>If we pass config option \\\"mode\\\" in config root, infrastructure will try to find </p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(configuration_2.application_mode || !configuration_2.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('configuration_2.application_mode', true)\\\">application mode</a></li></ul><div class=\\\"code-block large {{condition(!configuration_2.application_mode,  condition( configuration_2.__active ,'hide' )  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('conf_fs_2.app_js', true)\\\" class=\\\"fs-file {{condition( conf_fs_2.app_js || !(conf_fs_2.__active), 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('conf_fs_2.config_development_json', true)\\\" class=\\\"fs-file {{condition( conf_fs_2.config_development_json, 'active')}}\\\">development.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('conf_fs_2.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( conf_fs_2.config_structures_log_json, 'active')}}\\\">log.json</a></div></div></div><div class=\\\"col-xs-10 code-block large {{condition(!conf_fs_2.config_development_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"structures\\\": {\\n    \\\"log\\\": {\\n      \\\"options\\\": { \\\"sys\\\": false }\\n    }\\n  }\\n}\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!conf_fs_2.app_js, condition(conf_fs_2.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\n// config/development.json will \\\"patch\\\" config tree when mode is \\\"development\\\"\\ninfrastructure({ mode: \\\"development\\\" }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!conf_fs_2.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\" ,\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}</code></pre></div></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i3_Configuration.ractive.jade\n ** module id = 53\n ** module chunks = 1\n **/","module.exports = \"\\n<div class=\\\"page-header\\\"><h1>Process modes</h1></div><p>By default, if not specified, process_mode is \\\"single\\\". If we set it to \\\"cluster\\\", every structure will be executed in separate child_process.</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(process_modes_1.app_js || !process_modes_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_1.app_js', true)\\\">in app.js</a></li><li class=\\\"{{condition(process_modes_1.in_configuration, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_1.in_configuration', true)\\\">in configuration</a></li><li class=\\\"{{condition(process_modes_1.cli, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_1.cli', true)\\\">command line</a></li></ul><div class=\\\"code-block large {{condition(!process_modes_1.app_js,  condition( process_modes_1.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ process_mode: \\\"cluster\\\" }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"code-block large {{condition(!process_modes_1.in_configuration, 'hide'  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_fs_1.app_js', true)\\\" class=\\\"fs-file {{condition( process_modes_fs_1.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_fs_1.config_process_mode_json', true)\\\" class=\\\"fs-file {{condition( process_modes_fs_1.config_process_mode_json || !(process_modes_fs_1.__active), 'active')}}\\\">process_mode.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('process_modes_fs_1.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( process_modes_fs_1.config_structures_log_json, 'active')}}\\\">log.json</a></div></div></div><div class=\\\"col-xs-10 code-block large {{condition(!process_modes_fs_1.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!process_modes_fs_1.config_process_mode_json, condition(process_modes_fs_1.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">\\\"cluster\\\"\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!process_modes_fs_1.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\" ,\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}\\n</code></pre></div></div><div class=\\\"code-block large {{condition(!process_modes_1.cli, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app --config.process_mode=cluster\\n[sys]  [2015-11-09 20:49:00][logger]........................... options: sys, debug\\n[sys]  [2015-11-09 20:49:00][worker]........................... log\\n[sys]  [2015-11-09 20:49:00][worker started]................... 56ms, structures: log\\n[sys]  [2015-11-09 20:49:00][application started].............. 466ms, process_mode: cluster, application mode: undefined\\n</code></pre></div><p>In this case, the app keeps it's running state.</p>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i4_ProcessMode.ractive.jade\n ** module id = 54\n ** module chunks = 1\n **/","module.exports = \"\\n<div class=\\\"page-header\\\"><h1>Structures</h1></div><p>Structures are group of similar classes which will be instantiated and structured in tree-like structure.</p><p>Lets define our structure in configuration. For the exampe, we will give the structure name \\\"workers\\\".</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(structures_1.configuration || !structures_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_1.configuration', true)\\\">configuration</a></li></ul><div class=\\\"code-block large {{condition(!structures_1.configuration,  condition( structures_1.__active ,'hide' )  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_1.app_js', true)\\\" class=\\\"fs-file {{condition( structures_fs_1.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_1.config_process_mode_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_1.config_process_mode_json, 'active')}}\\\">process_mode.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_1.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_1.config_structures_log_json, 'active')}}\\\">log.json</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_1.config_structures_workers_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_1.config_structures_workers_json || !(structures_fs_1.__active), 'active')}}\\\">workers.json</a></div></div></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_1.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_1.config_process_mode_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">\\\"cluster\\\"\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_1.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\",\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_1.config_structures_workers_json, condition(structures_fs_1.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"path\\\": \\\"workers\\\"\\n}\\n</code></pre></div></div><p></p><p>This configuration shows that the structure files must be placed in folder \\\"workers\\\" (based on project root). Lets create the folder and some files in it.</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(structures_2.configuration || !structures_2.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_2.configuration', true)\\\">configuration</a></li><li class=\\\"{{condition(structures_2.cli, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_2.cli', true)\\\">cli</a></li></ul><div class=\\\"code-block large {{condition(!structures_2.configuration,  condition( structures_2.__active ,'hide' )  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.app_js', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.config_process_mode_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.config_process_mode_json, 'active')}}\\\">process_mode.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.config_structures_log_json, 'active')}}\\\">log.json</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.config_structures_workers_json', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.config_structures_workers_json, 'active')}}\\\">workers.json</a></div></div><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">workers</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.workers_worker_1_js', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.workers_worker_1_js || !(structures_fs_2.__active), 'active')}}\\\">worker_1.js</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('structures_fs_2.workers_worker_2_js', true)\\\" class=\\\"fs-file {{condition( structures_fs_2.workers_worker_2_js, 'active')}}\\\">worker_2.js</a></div></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n\\n  // Check that workers are callable\\n  env.i.do(\\\"workers.worker_1.worker_1_method\\\", \\\"hello worker 1\\\", function(err, response){\\n    console.log(response);\\n  });\\n  env.i.do(\\\"workers.worker_2.worker_2_method\\\", \\\"hello worker 2\\\", function(err, response){\\n    console.log(response);\\n  });\\n\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.workers_worker_1_js, condition(structures_fs_2.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_1(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_1\\\");\\n}\\nWorker_1.prototype.worker_1_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_1;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.workers_worker_2_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_2(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_2\\\");\\n}\\nWorker_2.prototype.worker_2_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_2;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.config_process_mode_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">\\\"cluster\\\"\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\" ,\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!structures_fs_2.config_structures_workers_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"path\\\": \\\"workers\\\"\\n}\\n</code></pre></div></div><div class=\\\"code-block large {{condition(!structures_2.cli, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> node app\\n[sys]  [2015-11-23 22:04:01][logger]........................... options: sys, debug\\n[sys]  [2015-11-23 22:04:01][worker]........................... log\\n[sys]  [2015-11-23 22:04:01][worker started]................... 37ms, structures: log\\n[sys]  [2015-11-23 22:04:02][application started].............. 450ms, process_mode: cluster, application mode: undefined\\n[sys]  [2015-11-23 22:04:02][worker instantiated].............. Worker_1\\n[sys]  [2015-11-23 22:04:02][worker instantiated].............. Worker_2\\n[sys]  [2015-11-23 22:04:02][worker]........................... workers\\n[sys]  [2015-11-23 22:04:02][worker started]................... 42ms, structures: workers\\n[ 'hello worker 1', 'hello master' ]\\n[ 'hello worker 2', 'hello master' ]</code></pre></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i5_Structures.ractive.jade\n ** module id = 55\n ** module chunks = 1\n **/","module.exports = \"\\n<div class=\\\"page-header\\\"><h1>Tests</h1></div><p>For this example we will use mocha.</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(tests_1.install_mocha || !tests_1.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1.install_mocha', true)\\\">Install mocha</a></li><li class=\\\"{{condition(tests_1.package_json, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1.package_json', true)\\\">package.json</a></li><li class=\\\"{{condition(tests_1.test_file, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1.test_file', true)\\\">test file</a></li><li class=\\\"{{condition(tests_1.run_test, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1.run_test', true)\\\">run test</a></li></ul><div class=\\\"code-block large {{condition(!tests_1.install_mocha,  condition( tests_1.__active ,'hide' )  )}}\\\"><pre><code class=\\\"language-bash\\\">$> npm install mocha --save-dev\\n</code></pre></div><div class=\\\"code-block large {{condition(!tests_1.run_test, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> npm test\\n\\n> test@1.0.0 test /project/project\\n> mocha test\\n\\n\\n\\n  Start/stop application\\n[sys]  [2015-11-29 16:37:14][logger]........................... options: sys, debug\\n[sys]  [2015-11-29 16:37:14][worker]........................... log\\n[sys]  [2015-11-29 16:37:14][worker started]................... 74ms, structures: log\\n[sys]  [2015-11-29 16:37:14][application started].............. 891ms, process_mode: cluster, application mode: test\\n    ✓ Starts application (895ms)\\n[sys]  [2015-11-29 16:37:14][worker instantiated].............. Worker_1\\n[sys]  [2015-11-29 16:37:14][worker instantiated].............. Worker_2\\n[sys]  [2015-11-29 16:37:14][worker]........................... workers\\n[sys]  [2015-11-29 16:37:14][worker started]................... 59ms, structures: workers\\n  ✓ Calls our custom structure member and inspect the result\\ntry Gracefull shutdown for structure:  log\\nGracefull shutdown success for worker: log\\ntry Gracefull shutdown for structure:  workers\\nGracefull shutdown success for worker: workers\\n    ✓ Stops application\\n\\n\\n  3 passing (934ms)\\n</code></pre></div><div class=\\\"code-block large {{condition(!tests_1.package_json, 'hide'  )}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"name\\\": \\\"test\\\",\\n  \\\"version\\\": \\\"1.0.0\\\",\\n  \\\"description\\\": \\\"\\\",\\n  \\\"main\\\": \\\"app.js\\\",\\n  \\\"scripts\\\": {\\n    \\\"test\\\": \\\"mocha test\\\"\\n  },\\n  \\\"dependencies\\\": {\\n    \\\"infrastructure\\\": \\\"^1.1.0\\\"\\n  },\\n  \\\"devDependencies\\\": {\\n    \\\"mocha\\\": \\\"^2.3.4\\\"\\n  }\\n}\\n\\n</code></pre></div><div class=\\\"code-block large {{condition(!tests_1.test_file, 'hide'  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.app_js', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.config_process_mode_json', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.config_process_mode_json, 'active')}}\\\">process_mode.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.config_structures_log_json, 'active')}}\\\">log.json</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.config_structures_workers_json', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.config_structures_workers_json, 'active')}}\\\">workers.json</a></div></div><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">test</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.test_test_js', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.test_test_js || !(tests_1_fs.__active), 'active')}}\\\">test.js</a></div><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">workers</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.workers_worker_1_js', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.workers_worker_1_js, 'active')}}\\\">worker_1.js</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_1_fs.workers_worker_2_js', true)\\\" class=\\\"fs-file {{condition( tests_1_fs.workers_worker_2_js, 'active')}}\\\">worker_2.js</a></div></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.test_test_js, condition(tests_1_fs.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">var assert = require(\\\"assert\\\");\\ndescribe(\\\"Start/stop application\\\", function(){\\n  \\n  var infrastructure_test_env = require(\\\"infrastructure/test_env\\\");\\n  var env;\\n\\n  it(\\\"Starts application\\\", function(done){\\n    infrastructure_test_env.start({ process_mode: \\\"single\\\" }, function(err, test_env){\\n      assert.equal(err, null);\\n      env = test_env;\\n      done();\\n    });\\n  });\\n\\n  it(\\\"Calls our custom structure member and inspect the result\\\", function(done){\\n    env.i.do(\\\"workers.worker_1.worker_1_method\\\", \\\"hello worker 1\\\", function(err, response){\\n      assert.equal(err, null);\\n      assert.deepEqual(response, [ 'hello worker 1', 'hello master' ]);\\n      done();\\n    });\\n  });\\n\\n  it(\\\"Stops application\\\", function(done){\\n    env.stop(function(err){\\n      assert.equal(err, null);\\n      done();\\n    });\\n  });\\n\\n});\\n\\n\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n\\n  // Check that workers are callable\\n  env.i.do(\\\"workers.worker_1.worker_1_method\\\", \\\"hello worker 1\\\", function(err, response){\\n    console.log(response);\\n  });\\n  env.i.do(\\\"workers.worker_2.worker_2_method\\\", \\\"hello worker 2\\\", function(err, response){\\n    console.log(response);\\n  });\\n\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.workers_worker_1_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_1(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_1\\\");\\n}\\nWorker_1.prototype.worker_1_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_1;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.workers_worker_2_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_2(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_2\\\");\\n}\\nWorker_2.prototype.worker_2_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_2;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.config_process_mode_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">\\\"cluster\\\"\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\" ,\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_1_fs.config_structures_workers_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"path\\\": \\\"workers\\\"\\n}\\n</code></pre></div></div><p></p><p>Well, test passes, but we still see system logs. Test runs under application mode \\\"test\\\", so we will attach \\\"test\\\" branch to our config root.</p><ul class=\\\"nav nav-tabs\\\"><li class=\\\"{{condition(tests_2.test_config || !tests_2.__active, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2.test_config', true)\\\">test config</a></li><li class=\\\"{{condition(tests_2.run_test, 'active')}}\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2.run_test', true)\\\">run test</a></li></ul><div class=\\\"code-block large {{condition(!tests_2.test_config,  condition( tests_2.__active ,'hide' )  )}}\\\"><div class=\\\"col-xs-2 fs-block\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.app_js', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.app_js, 'active')}}\\\">app.js</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">config</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.config_process_mode_json', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.config_process_mode_json, 'active')}}\\\">process_mode.json</a><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">structures</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.config_structures_log_json', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.config_structures_log_json, 'active')}}\\\">log.json</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.config_structures_workers_json', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.config_structures_workers_json, 'active')}}\\\">workers.json</a></div><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.config_test_json', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.config_test_json || !(tests_2_fs.__active), 'active')}}\\\">test.json</a></div><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">test</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.test_test_js', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.test_test_js, 'active')}}\\\">test.js</a></div><p onclick=\\\"javascript:this.classList.toggle('closed');\\\" class=\\\"fs-dir\\\"><a href=\\\"javascript:void(0);\\\">workers</a></p><div class=\\\"fs-dir\\\"><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.workers_worker_1_js', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.workers_worker_1_js, 'active')}}\\\">worker_1.js</a><a href=\\\"javascript: void(0);\\\" on-click=\\\"radioToggle('tests_2_fs.workers_worker_2_js', true)\\\" class=\\\"fs-file {{condition( tests_2_fs.workers_worker_2_js, 'active')}}\\\">worker_2.js</a></div></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.config_test_json, condition(tests_2_fs.__active, 'hide'))}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"structures\\\": {\\n    \\\"log\\\": {\\n      \\\"options\\\": {\\n        \\\"sys\\\": false\\n      }\\n    }\\n  }\\n}\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.test_test_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var assert = require(\\\"assert\\\");\\ndescribe(\\\"Start/stop application\\\", function(){\\n  \\n  var infrastructure_test_env = require(\\\"infrastructure/test_env\\\");\\n  var env;\\n\\n  it(\\\"Starts application\\\", function(done){\\n    infrastructure_test_env.start({ process_mode: \\\"single\\\" }, function(err, test_env){\\n      assert.equal(err, null);\\n      env = test_env;\\n      done();\\n    });\\n  });\\n\\n  it(\\\"Calls our custom structure member and inspect the result\\\", function(done){\\n    env.i.do(\\\"workers.worker_1.worker_1_method\\\", \\\"hello worker 1\\\", function(err, response){\\n      assert.equal(err, null);\\n      assert.deepEqual(response, [ 'hello worker 1', 'hello master' ]);\\n      done();\\n    });\\n  });\\n\\n  it(\\\"Stops application\\\", function(done){\\n    env.stop(function(err){\\n      assert.equal(err, null);\\n      done();\\n    });\\n  });\\n\\n});\\n\\n\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.app_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">var infrastructure = require(\\\"infrastructure\\\");\\ninfrastructure({ /* Write config here */ }, function(err, env) {\\n  if (err) { throw err; }\\n});\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.workers_worker_1_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_1(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_1\\\");\\n}\\nWorker_1.prototype.worker_1_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_1;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.workers_worker_2_js, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">function Worker_2(env){\\n  env.i.do(\\\"log.sys\\\", \\\"worker instantiated\\\", \\\"Worker_2\\\");\\n}\\nWorker_2.prototype.worker_2_method = function(text, cb){\\n  cb(null, [text, \\\"hello master\\\"]);\\n}\\nmodule.exports = Worker_2;\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.config_process_mode_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">\\\"cluster\\\"\\n</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.config_structures_log_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"engine\\\":  \\\"log\\\" ,\\n  \\\"options\\\": { \\\"sys\\\": true, \\\"debug\\\": true }\\n}</code></pre></div><div class=\\\"col-xs-10 code-block large {{condition(!tests_2_fs.config_structures_workers_json, 'hide')}}\\\"><pre><code class=\\\"language-javascript\\\">{\\n  \\\"path\\\": \\\"workers\\\"\\n}\\n</code></pre></div></div><div class=\\\"code-block large {{condition(!tests_2.run_test, 'hide'  )}}\\\"><pre><code class=\\\"language-bash\\\">$> npm test\\n\\n> test@1.0.0 test /project/project\\n> mocha test\\n\\n\\n\\n  Start/stop application\\n    ✓ Starts application (460ms)\\n    ✓ Calls our custom structure member and inspect the result\\n    ✓ Stops application\\n\\n\\n  3 passing (487ms)\\n</code></pre></div><p></p><p>The config tree is patched and system logs are not shown whem application mode is \\\"test\\\"</p>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Docs/partials/i6_Tests.ractive.jade\n ** module id = 56\n ** module chunks = 1\n **/","module.exports = \"<h1>Footer</h1>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Footer/Footer.ractive.jade\n ** module id = 57\n ** module chunks = 1\n **/","module.exports = \"<h1><a href=\\\"/infrastructure\\\">Infrastructure</a></h1>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/Header/Header.ractive.jade\n ** module id = 58\n ** module chunks = 1\n **/","module.exports = \"<h1>Finally, version 1.0 is released!!</h1><a href=\\\"/infrastructure/docs/SetupApplication\\\">Get started!</a>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/HelloWorld/HelloWorld.ractive.jade\n ** module id = 59\n ** module chunks = 1\n **/","module.exports = \"<div class=\\\"row\\\">{{#if !state.screen}}\\n  {{>resolveComponent(\\\"HelloWorld\\\", {})}}\\n{{else}}\\n  {{>resolveComponent(state.screen[0].toUpperCase() + state.screen.slice(1), {state: \\\"state\\\" , search_input: \\\"search_input\\\"})}}\\n{{/if}}</div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/MainContainer/MainContainer.ractive.jade\n ** module id = 60\n ** module chunks = 1\n **/","module.exports = \"<div class=\\\"row\\\"><!-- form.col-xs-2: .form-group: input.form-control(type=\\\"text\\\", placeholder=\\\"Search\\\", value=\\\"{{search_input}}\\\")--><div class=\\\"col-xs-12\\\"><div class=\\\"row\\\"><a href=\\\"/infrastructure/builder\\\" class=\\\"pull-right btn btn-default {{condition(state.screen === 'build', 'active')}}\\\">Build</a><a href=\\\"/infrastructure/docs/SetupApplication\\\" class=\\\"pull-right btn btn-default {{condition(state.screen === 'docs',  'active')}}\\\">Docs</a></div></div></div>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/TopMenu/TopMenu.ractive.jade\n ** module id = 61\n ** module chunks = 1\n **/","module.exports = \"<h1>Under Construction</h1>\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./app/client/infrastructure/views/sections/UnderConstruction/UnderConstruction.ractive.jade\n ** module id = 62\n ** module chunks = 1\n **/"],"sourceRoot":""}